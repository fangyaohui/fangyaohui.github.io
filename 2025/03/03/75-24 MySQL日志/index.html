<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>75-24 MySQL日志 | 孤岛</title><meta name="author" content="徐行"><meta name="copyright" content="徐行"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="75-24 MySQL日志前言MySQL中的日志主要用于数据恢复、性能优化、问题排查等。它们分为几类，每种日志都有不同的作用。主要包括：  错误日志（Error Log） 通用查询日志（General Query Log） 慢查询日志（Slow Query Log） 二进制日志（Binary Log, Binlog） 事务日志（Redo Log &amp; Undo Log） 中继日志（Relay">
<meta property="og:type" content="article">
<meta property="og:title" content="75-24 MySQL日志">
<meta property="og:url" content="http://example.com/2025/03/03/75-24%20MySQL%E6%97%A5%E5%BF%97/index.html">
<meta property="og:site_name" content="孤岛">
<meta property="og:description" content="75-24 MySQL日志前言MySQL中的日志主要用于数据恢复、性能优化、问题排查等。它们分为几类，每种日志都有不同的作用。主要包括：  错误日志（Error Log） 通用查询日志（General Query Log） 慢查询日志（Slow Query Log） 二进制日志（Binary Log, Binlog） 事务日志（Redo Log &amp; Undo Log） 中继日志（Relay">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/4.png">
<meta property="article:published_time" content="2025-03-03T15:44:18.000Z">
<meta property="article:modified_time" content="2025-03-04T08:49:30.866Z">
<meta property="article:author" content="徐行">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="日志">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/4.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "75-24 MySQL日志",
  "url": "http://example.com/2025/03/03/75-24%20MySQL%E6%97%A5%E5%BF%97/",
  "image": "http://example.com/img/4.png",
  "datePublished": "2025-03-03T15:44:18.000Z",
  "dateModified": "2025-03-04T08:49:30.866Z",
  "author": [
    {
      "@type": "Person",
      "name": "徐行",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/03/03/75-24%20MySQL%E6%97%A5%E5%BF%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '75-24 MySQL日志',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">118</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">84</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/4.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">孤岛</span></a><a class="nav-page-title" href="/"><span class="site-name">75-24 MySQL日志</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">75-24 MySQL日志</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-03T15:44:18.000Z" title="发表于 2025-03-03 23:44:18">2025-03-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-04T08:49:30.866Z" title="更新于 2025-03-04 16:49:30">2025-03-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>18分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="75-24-MySQL日志"><a href="#75-24-MySQL日志" class="headerlink" title="75-24 MySQL日志"></a>75-24 MySQL日志</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MySQL中的日志主要用于<strong>数据恢复、性能优化、问题排查</strong>等。它们分为几类，每种日志都有不同的作用。主要包括：</p>
<ol>
<li><strong>错误日志（Error Log）</strong></li>
<li><strong>通用查询日志（General Query Log）</strong></li>
<li><strong>慢查询日志（Slow Query Log）</strong></li>
<li><strong>二进制日志（Binary Log, Binlog）</strong></li>
<li><strong>事务日志（Redo Log &amp; Undo Log）</strong></li>
<li><strong>中继日志（Relay Log）</strong></li>
</ol>
<p>其中比较重要的日志有：<strong>二进制日志</strong>、<strong>事务日志（Redo Log &amp; Undo Log）</strong>。</p>
<p>对于MySQL中的日志，其日志的主要作用牢牢抓住数据恢复、性能优化和问题排查。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503032346671.png" alt="image-20250303234614620"></p>
<h2 id="Redo-Log"><a href="#Redo-Log" class="headerlink" title="Redo Log"></a>Redo Log</h2><p>redo log（重做日志）是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力。</p>
<p>比如 MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503032358239.png" alt="img"></p>
<p>MySQL中的数据是以页为基本单位进行操作的，如果在执行一条SQL语句时，MySQL会先将符合的那一页加载到Buffer Pool中。那么如果后续还执行这同样的SQL，那么MySQL则会优先在Buffer Pool中进行查找，同样的如果是更新，也会优先在Buffer Pool中查询后进行更新。</p>
<p>这里也同样是内存中和硬盘中的存取速度不一致导致的一些问题，为了解决这些问题，所以MySQL设计在内存（也就是InnoDB设计了一个Redo Log Buffer）任何的插入或者更新操作都会优先的写入这个Redo Log Buffer中，但是这里是内存中，如果这时候宕机了如何。且内存中并不支持持久化，所以需要按照一定的规则把Redo Pool Buffer中的刷新到硬盘中（Redo Log），我们也称这这操作为刷屏操作，那么刷盘时机几种情况呢。</p>
<h3 id="刷盘时机"><a href="#刷盘时机" class="headerlink" title="刷盘时机"></a>刷盘时机</h3><p>InnoDB 刷新重做日志的时机有几种情况：</p>
<p>InnoDB 将 redo log 刷到磁盘上有几种情况：</p>
<ol>
<li>事务提交：当事务提交时，log buffer 里的 redo log 会被刷新到磁盘（可以通过<code>innodb_flush_log_at_trx_commit</code>参数控制，后文会提到）。</li>
<li>log buffer 空间不足时：log buffer 中缓存的 redo log 已经占满了 log buffer 总容量的大约一半左右，就需要把这些日志刷新到磁盘上。</li>
<li>事务日志缓冲区满：InnoDB 使用一个事务日志缓冲区（transaction log buffer）来暂时存储事务的重做日志条目。当缓冲区满时，会触发日志的刷新，将日志写入磁盘。</li>
<li>Checkpoint（检查点）：InnoDB 定期会执行检查点操作，将内存中的脏数据（已修改但尚未写入磁盘的数据）刷新到磁盘，并且会将相应的重做日志一同刷新，以确保数据的一致性。</li>
<li>后台刷新线程：InnoDB 启动了一个后台线程，负责周期性（每隔 1 秒）地将脏页（已修改但尚未写入磁盘的数据页）刷新到磁盘，并将相关的重做日志一同刷新。</li>
<li>正常关闭服务器：MySQL 关闭的时候，redo log 都会刷入到磁盘里去。</li>
</ol>
<p>总之，InnoDB 在多种情况下会刷新重做日志，以保证数据的持久性和一致性。</p>
<p>Redo Log日志主要是为了保证MySQL崩溃后可以进行数据恢复，从而可以保证恢复后的数据与崩溃之前的数据一致性。</p>
<ul>
<li><strong>Redo Log 不是基于 SQL 语句的，而是基于物理页的变更记录。</strong></li>
<li><strong>Redo Log 可能在事务提交之前就被写入磁盘，但事务提交后才标记为持久化。</strong></li>
<li><strong>Redo Log 主要用于崩溃恢复，而不是用于回滚（回滚是通过 Undo Log 实现的）。</strong></li>
</ul>
<p><code>Redo Log</code> 是<strong>物理级别的日志</strong>，记录的是“<strong>某个数据页的某个位置修改了什么</strong>”，而<strong>不是 SQL 语句</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503041530356.png" alt="img"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>那么通过上面的了解学习，为什么在MySQL进行了一个SQL操作时，找到了对于的数据页并知道了需要对该数据页的哪些进行何种操作的话，为什么 MySQL 不直接写数据，而是先写 Redo Log？</p>
<p>因为 <strong>Redo Log 是顺序写入，磁盘 IO 更高效</strong>（相比之下，直接写数据是随机 IO，性能较差）。</p>
<p>事务执行时，直接写入 <code>Redo Log</code>，然后再通过后台线程慢慢将数据刷入数据页，提高了系统的吞吐量。</p>
<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p><strong>redo log 它是物理日志</strong>，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎。</p>
<p><strong>而 binlog 是逻辑日志</strong>，记录内容是语句的原始逻辑，类似于“给 ID&#x3D;2 这一行的 c 字段加 1”，属于<code>MySQL Server</code> 层。</p>
<p>不管用什么存储引擎，<strong>只要发生了表数据更新，都会产生 binlog 日志。</strong></p>
<p>binlog日志会记录下所有SQL相关操作，其属于MySQL服务层，而Redo log属于MySQL的存储引擎，且是物理日志。binlog日志一般会用来做数据同步，可以说 MySQL 数据库的<strong>数据备份、主备、主主、主从</strong>都离不开 binlog，需要依靠 binlog 来同步数据，保证数据一致性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503041544842.png" alt="img"></p>
<p>binlog 会记录所有涉及更新数据的逻辑操作，并且是<strong>顺序写</strong>。</p>
<blockquote>
<h3 id="1-什么是顺序写？"><a href="#1-什么是顺序写？" class="headerlink" title="1. 什么是顺序写？"></a><strong>1. 什么是顺序写？</strong></h3><p>在 MySQL 中，**顺序写（Sequential Write）**指的是数据按照**连续的物理地址**写入存储设备（通常是磁盘或 SSD）。顺序写数据时，磁头（对于机械硬盘）或者 Flash 控制器（对于 SSD）<strong>可以直接按顺序写入数据块，而不需要频繁地寻找新的存储位置</strong>。</p>
<p>在 <strong>binlog（Binary Log，二进制日志）</strong> 中，<strong>顺序写</strong>意味着：</p>
<ul>
<li><strong>事务执行后，MySQL 会将变更记录按顺序追加到 Binlog 文件的末尾</strong>，而不会频繁跳跃到磁盘的不同位置去写数据。</li>
<li>Binlog <strong>不会进行随机修改，而是一次性地追加新的日志记录</strong>，直到达到设定的 binlog 文件大小（由 <code>max_binlog_size</code> 控制），然后 MySQL 会创建新的 binlog 文件继续记录。</li>
</ul>
<hr>
<h3 id="2-顺序写的反面是什么？"><a href="#2-顺序写的反面是什么？" class="headerlink" title="2. 顺序写的反面是什么？"></a><strong>2. 顺序写的反面是什么？</strong></h3><p>顺序写的反面是 <strong>随机写（Random Write）</strong>。<br><strong>随机写</strong>指的是数据<strong>写入磁盘上的不同位置</strong>，而不是按照顺序追加。例如：</p>
<ul>
<li>当我们修改数据库的某个数据页时，如果数据存储的位置不连续，就会触发磁盘的<strong>随机 IO</strong>，需要磁头<strong>跳转到不同的物理位置</strong>写入数据。</li>
</ul>
<p>在 MySQL 里，<strong>数据页的修改（如 InnoDB 表的数据变更）通常涉及随机写</strong>：</p>
<ul>
<li>MySQL 需要在磁盘上的<strong>不同物理位置</strong>修改数据。</li>
<li>如果数据页未加载到缓冲池（Buffer Pool），需要额外的磁盘读取（即“读-修改-写”模式）。</li>
<li>这就导致了<strong>磁盘的随机 IO 负担较大</strong>。</li>
</ul>
</blockquote>
<h3 id="记录格式"><a href="#记录格式" class="headerlink" title="记录格式"></a>记录格式</h3><p>binlog 日志有三种格式，可以通过<code>binlog_format</code>参数指定。</p>
<ul>
<li><strong>statement</strong></li>
<li><strong>row</strong></li>
<li><strong>mixed</strong></li>
</ul>
<p>指定<code>statement</code>，记录的内容是<code>SQL</code>语句原文，比如执行一条<code>update T set update_time=now() where id=1</code>，记录的内容如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503041557544.png" alt="img"></p>
<p>同步数据时，会执行记录的<code>SQL</code>语句，但是有个问题，<code>update_time=now()</code>这里会获取当前系统时间，直接执行会导致与原库的数据不一致。</p>
<p>为了解决这种问题，我们需要指定为<code>row</code>，记录的内容不再是简单的<code>SQL</code>语句了，还包含操作的具体数据，记录内容如下。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503041558013.png" alt="img"></p>
<p><code>row</code>格式记录的内容看不到详细信息，要通过<code>mysqlbinlog</code>工具解析出来。</p>
<p><code>update_time=now()</code>变成了具体的时间<code>update_time=1627112756247</code>，条件后面的@1、@2、@3 都是该行数据第 1 个~3 个字段的原始值（<strong>假设这张表只有 3 个字段</strong>）。</p>
<p>这样就能保证同步数据的一致性，通常情况下都是指定为<code>row</code>，这样可以为数据库的恢复与同步带来更好的可靠性。</p>
<p>但是这种格式，需要更大的容量来记录，比较占用空间，恢复与同步时会更消耗 IO 资源，影响执行速度。</p>
<p>所以就有了一种折中的方案，指定为<code>mixed</code>，记录的内容是前两者的混合。</p>
<p>MySQL 会判断这条<code>SQL</code>语句是否可能引起数据不一致，如果是，就用<code>row</code>格式，否则就用<code>statement</code>格式。</p>
<h3 id="写入机制"><a href="#写入机制" class="headerlink" title="写入机制"></a>写入机制</h3><p>binlog 的写入时机也非常简单，事务执行过程中，先把日志写到<code>binlog cache</code>，事务提交的时候，再把<code>binlog cache</code>写到 binlog 文件中。</p>
<p>对于这里binlog的写入情况与Redo log写入机制差不多，在这里也引入了一个binlog cache，用来缓解内存与硬盘之间数据读取速度不匹配的矛盾。</p>
<p>但是因为一个事务具有原子性，其应当是不可拆分的，所以无论这个事务有多大，其应一次性写入binlog中，所以系统会为每个线程分配一个块内存来作为binlog cache。</p>
<blockquote>
<p>MySQL <strong>即使是执行一条简单的 SQL 语句</strong>，在 <strong>InnoDB</strong> 存储引擎下，也会<strong>以事务的方式执行</strong>，但具体情况取决于 SQL 语句的类型和 <code>autocommit</code> 设置。</p>
<ul>
<li><strong>在 MySQL 8.0 中，默认启用了 <code>autocommit=1</code>，即自动提交模式</strong>。</li>
<li><strong>如果 <code>autocommit=1</code>，那么每一条 SQL 语句都会被视为一个事务，并在执行完成后立即提交</strong>，写入 binlog（如果开启了 binlog）。</li>
<li><strong>如果 <code>autocommit=0</code>，则 SQL 语句执行后不会立即提交，需要手动 <code>COMMIT</code>，否则事务可能会回滚（ROLLBACK）。</strong></li>
</ul>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503041603989.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503041605520.png" alt="img"></p>
<h2 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h2><p><strong>redo log（重做日志）让 InnoDB 存储引擎拥有了崩溃恢复能力。</strong></p>
<p><strong>binlog（归档日志）保证了 MySQL 集群架构的数据一致性。</strong></p>
<p>虽然它们都属于持久化的保证，但是侧重点不同。</p>
<p>在执行更新语句过程，会记录 redo log 与 binlog 两块日志，以基本的事务为单位，redo log 在事务执行过程中可以不断写入，而 binlog 只有在提交事务时才写入，所以 redo log 与 binlog 的写入时机不一样。</p>
<blockquote>
<p>我们结合 <strong>一个简单的例子</strong> 来说明这一过程。</p>
<hr>
<h2 id="1-示例：MySQL-事务执行过程"><a href="#1-示例：MySQL-事务执行过程" class="headerlink" title="1. 示例：MySQL 事务执行过程"></a><strong>1. 示例：MySQL 事务执行过程</strong></h2><p>假设你在 MySQL 里执行以下事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;  <span class="comment">-- 开启事务</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">COMMIT</span>;  <span class="comment">-- 提交事务</span></span><br></pre></td></tr></table></figure>

<p>这个事务的作用是：</p>
<ul>
<li><strong>从 ID&#x3D;1 的账户中扣除 100 元</strong></li>
<li><strong>向 ID&#x3D;2 的账户中增加 100 元</strong></li>
<li><strong>最后提交事务，确保这两步修改要么全部生效，要么全部不生效</strong></li>
</ul>
<p>在 <strong>事务的执行过程中，MySQL 需要保证数据的可靠性和恢复能力</strong>，所以它会写两种日志：</p>
<ul>
<li><strong>Redo Log（重做日志）</strong>：用于崩溃恢复，保证数据持久化到磁盘，即使宕机也能恢复数据。</li>
<li><strong>Binlog（二进制日志）</strong>：用于主从复制和数据恢复，记录事务的逻辑操作。</li>
</ul>
<hr>
<h2 id="2-Redo-Log-和-Binlog-在事务中的写入时机"><a href="#2-Redo-Log-和-Binlog-在事务中的写入时机" class="headerlink" title="2. Redo Log 和 Binlog 在事务中的写入时机"></a><strong>2. Redo Log 和 Binlog 在事务中的写入时机</strong></h2><h3 id="【Step-1】开始事务"><a href="#【Step-1】开始事务" class="headerlink" title="【Step 1】开始事务"></a><strong>【Step 1】开始事务</strong></h3><ul>
<li><strong>MySQL 解析 <code>BEGIN;</code>，事务开始</strong></li>
<li><strong>此时，Redo Log 和 Binlog 里都没有任何内容</strong></li>
</ul>
<hr>
<h3 id="【Step-2】执行第一个-UPDATE-语句"><a href="#【Step-2】执行第一个-UPDATE-语句" class="headerlink" title="【Step 2】执行第一个 UPDATE 语句"></a><strong>【Step 2】执行第一个 <code>UPDATE</code> 语句</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>MySQL 执行这条语句后，修改的是 InnoDB 的数据页</strong>（假设数据页原本在 Buffer Pool 中）。</li>
<li><strong>此时，MySQL 需要记录该修改，以便宕机时能够恢复，因此会写入 Redo Log Buffer（Redo Log 先写入内存）。</strong></li>
<li><strong>但是 Binlog 并不会立即写入，而是先放到 Binlog Cache 中，并不会立即落盘。</strong></li>
</ul>
<p>✅ <strong>Redo Log（物理日志）</strong>：</p>
<ul>
<li>记录 <strong>“账户 1 余额减少 100 元”</strong> 的物理变更。</li>
<li><strong>可以随时写入</strong>（即使事务还没提交）。</li>
</ul>
<p>❌ <strong>Binlog（逻辑日志）</strong>：</p>
<ul>
<li><strong>不会立即写入 binlog，而是等到事务提交时再一次性写入。</strong></li>
</ul>
<hr>
<h3 id="【Step-3】执行第二个-UPDATE-语句"><a href="#【Step-3】执行第二个-UPDATE-语句" class="headerlink" title="【Step 3】执行第二个 UPDATE 语句"></a><strong>【Step 3】执行第二个 <code>UPDATE</code> 语句</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">+</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>同样，MySQL 记录了 ID&#x3D;2 账户增加 100 元的变更</strong>。</li>
<li><strong>Redo Log Buffer 再次写入这个修改，Binlog 仍然不会写入。</strong></li>
</ul>
<p>✅ <strong>Redo Log（物理日志）</strong>：</p>
<ul>
<li>记录 <strong>“账户 2 余额增加 100 元”</strong>。</li>
<li><strong>事务执行过程中不断写入 Redo Log Buffer</strong>。</li>
</ul>
<p>❌ <strong>Binlog（逻辑日志）</strong>：</p>
<ul>
<li>依然 <strong>不会立即写入</strong>，仍然在 Binlog Cache 里。</li>
</ul>
<hr>
<h3 id="【Step-4】提交事务（COMMIT）"><a href="#【Step-4】提交事务（COMMIT）" class="headerlink" title="【Step 4】提交事务（COMMIT）"></a><strong>【Step 4】提交事务（COMMIT）</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>当事务提交时，MySQL 采用<strong>两阶段提交（2PC）</strong>，以保证 Binlog 和 Redo Log 的一致性。流程如下：</p>
<ol>
<li><p><strong>写入 Binlog</strong>：</p>
<ul>
<li><p>事务提交时，MySQL <strong>一次性</strong> 把 <strong>整个事务的 SQL 语句记录</strong>（逻辑变更）<strong>写入 Binlog 文件</strong>。</p>
</li>
<li><p>这时候 Binlog 记录的内容类似：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UPDATE accounts SET balance = balance - 100 WHERE id = 1;</span><br><span class="line">UPDATE accounts SET balance = balance + 100 WHERE id = 2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Binlog <strong>必须一次性写入整个事务，否则无法用于主从复制和 Point-In-Time 恢复</strong>。</p>
</li>
</ul>
</li>
<li><p><strong>Redo Log 进入 Prepare 阶段</strong>：</p>
<ul>
<li><strong>在写入 Binlog 之后，MySQL 进入 Redo Log 的 prepare 阶段</strong>，确保 redo log 记录的物理变更与 binlog 对应。</li>
</ul>
</li>
<li><p><strong>Redo Log 标记 Commit 并落盘</strong>：</p>
<ul>
<li>在 <strong>事务提交成功后，Redo Log 记录 <code>commit</code>，此时数据才真正持久化到磁盘</strong>。</li>
<li>Redo Log <strong>先写入磁盘，数据页可以稍后再写入</strong>，这就是<strong>WAL（Write Ahead Logging）机制</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="3-为什么-Redo-Log-可以提前写入，而-Binlog-只能在提交时写？"><a href="#3-为什么-Redo-Log-可以提前写入，而-Binlog-只能在提交时写？" class="headerlink" title="3. 为什么 Redo Log 可以提前写入，而 Binlog 只能在提交时写？"></a><strong>3. 为什么 Redo Log 可以提前写入，而 Binlog 只能在提交时写？</strong></h2><table>
<thead>
<tr>
<th><strong>日志类型</strong></th>
<th><strong>写入时机</strong></th>
<th><strong>写入内容</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Redo Log（重做日志）</strong></td>
<td><strong>事务执行过程中不断写入</strong></td>
<td><strong>记录的是物理数据页的变化</strong></td>
<td><strong>保证崩溃恢复，即使宕机也能恢复数据</strong></td>
</tr>
<tr>
<td><strong>Binlog（二进制日志）</strong></td>
<td><strong>事务提交时一次性写入</strong></td>
<td><strong>记录的是 SQL 语句（逻辑变更）</strong></td>
<td><strong>用于主从复制和数据恢复，必须保证事务完整性</strong></td>
</tr>
</tbody></table>
<ul>
<li><strong>Redo Log 可以提前写入，因为它记录的是“物理变更”，即数据页的修改记录</strong>。即使事务最终回滚，Redo Log 也可以用来撤销修改（Undo Log 负责事务回滚）。</li>
<li><strong>Binlog 必须等到事务提交时一次性写入，原因是 Binlog 记录的是事务的逻辑 SQL 语句</strong>，如果事务未提交就写入，可能会导致数据不一致。</li>
</ul>
<hr>
<h2 id="4-现实场景下的作用"><a href="#4-现实场景下的作用" class="headerlink" title="4. 现实场景下的作用"></a><strong>4. 现实场景下的作用</strong></h2><h3 id="✅-场景-1：MySQL-崩溃恢复"><a href="#✅-场景-1：MySQL-崩溃恢复" class="headerlink" title="✅ 场景 1：MySQL 崩溃恢复"></a><strong>✅ 场景 1：MySQL 崩溃恢复</strong></h3><p>假设 MySQL 在 <code>COMMIT</code> 之前发生宕机：</p>
<ul>
<li><strong>由于 Redo Log 在事务执行过程中已经写入，所以可以用于恢复未提交的事务，使数据保持一致性</strong>。</li>
<li><strong>Binlog 只有在事务提交后才写入，因此 Binlog 不会包含未提交的事务</strong>。</li>
</ul>
<h3 id="✅-场景-2：MySQL-主从复制"><a href="#✅-场景-2：MySQL-主从复制" class="headerlink" title="✅ 场景 2：MySQL 主从复制"></a><strong>✅ 场景 2：MySQL 主从复制</strong></h3><ul>
<li><strong>主库的 Binlog 需要完整记录事务，以便从库可以进行一致性的重放</strong>。</li>
<li><strong>如果 Binlog 允许拆开写入，可能会导致从库的数据不一致（比如只执行了一半的 SQL 语句）</strong>。</li>
</ul>
</blockquote>
<ul>
<li><strong>Redo Log 可以提前写入，因为它记录的是“物理变更”，即数据页的修改记录</strong>。即使事务最终回滚，Redo Log 也可以用来撤销修改（Undo Log 负责事务回滚）。</li>
<li><strong>Binlog 必须等到事务提交时一次性写入，原因是 Binlog 记录的是事务的逻辑 SQL 语句</strong>，如果事务未提交就写入，可能会导致数据不一致。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503041613856.png" alt="img"></p>
<p>使用<strong>两阶段提交</strong>后，写入 binlog 时发生异常也不会有影响，因为 MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于<code>prepare</code>阶段，并且没有对应 binlog 日志，就会回滚该事务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503041614450.png" alt="img"></p>
<p>再看一个场景，redo log 设置<code>commit</code>阶段发生异常，那会不会回滚事务呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503041615730.png" alt="img"></p>
<p>并不会回滚事务，它会执行上图框住的逻辑，虽然 redo log 是处于<code>prepare</code>阶段，但是能通过事务<code>id</code>找到对应的 binlog 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据。</p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>每一个事务对数据的修改都会被记录到 undo log ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 undo log 将数据恢复到事务开始之前的状态。</p>
<p>undo log 属于逻辑日志，记录的是 SQL 语句，比如说事务执行一条 DELETE 语句，那 undo log 就会记录一条相对应的 INSERT 语句。同时，undo log 的信息也会被记录到 redo log 中，因为 undo log 也要实现持久性保护。并且，undo-log 本身是会被删除清理的，例如 INSERT 操作，在事务提交之后就可以清除掉了；UPDATE&#x2F;DELETE 操作在事务提交不会立即删除，会加入 history list，由后台线程 purge 进行清理。</p>
<p>undo log 是采用 segment（段）的方式来记录的，每个 undo 操作在记录的时候占用一个 <strong>undo log segment</strong>（undo 日志段），undo log segment 包含在 <strong>rollback segment</strong>（回滚段）中。事务开始时，需要为其分配一个 rollback segment。每个 rollback segment 有 1024 个 undo log segment，这有助于管理多个并发事务的回滚需求。</p>
<blockquote>
<h3 id="MySQL-事务中-Undo-Log、Redo-Log-和-Binlog-的协同工作"><a href="#MySQL-事务中-Undo-Log、Redo-Log-和-Binlog-的协同工作" class="headerlink" title="MySQL 事务中 Undo Log、Redo Log 和 Binlog 的协同工作"></a><strong>MySQL 事务中 Undo Log、Redo Log 和 Binlog 的协同工作</strong></h3><p>我们用一个<strong>具体的事务</strong>，结合 <strong>Undo Log</strong>、<strong>Redo Log</strong> 和 <strong>Binlog</strong>，详细讲解它们在 MySQL 中如何协同工作。</p>
<hr>
<h2 id="🔹-1-事务示例"><a href="#🔹-1-事务示例" class="headerlink" title="🔹 1. 事务示例"></a><strong>🔹 1. 事务示例</strong></h2><p>假设有一个 <code>accounts</code> 表：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> accounts (</span><br><span class="line">    id <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>,</span><br><span class="line">    balance <span class="type">INT</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT INTO</span> accounts <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>现在，我们执行下面的事务：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure>

<p>这个事务的执行流程涉及到 <strong>三种日志</strong>，分别承担不同的职责。</p>
<hr>
<h2 id="🔹-2-Undo-Log、Redo-Log-和-Binlog-在事务中的作用"><a href="#🔹-2-Undo-Log、Redo-Log-和-Binlog-在事务中的作用" class="headerlink" title="🔹 2. Undo Log、Redo Log 和 Binlog 在事务中的作用"></a><strong>🔹 2. Undo Log、Redo Log 和 Binlog 在事务中的作用</strong></h2><h3 id="🚀-Step-1：事务开始（BEGIN）"><a href="#🚀-Step-1：事务开始（BEGIN）" class="headerlink" title="🚀 Step 1：事务开始（BEGIN）"></a><strong>🚀 Step 1：事务开始（BEGIN）</strong></h3><ul>
<li>事务开始后，MySQL <strong>不会</strong> 立即写日志，但 <strong>Undo Log、Redo Log 和 Binlog 的空间已经准备好</strong>。</li>
</ul>
<hr>
<h3 id="🚀-Step-2：执行-UPDATE-语句"><a href="#🚀-Step-2：执行-UPDATE-语句" class="headerlink" title="🚀 Step 2：执行 UPDATE 语句"></a><strong>🚀 Step 2：执行 <code>UPDATE</code> 语句</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> accounts <span class="keyword">SET</span> balance <span class="operator">=</span> balance <span class="operator">-</span> <span class="number">100</span> <span class="keyword">WHERE</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这个 SQL 语句对 <code>id=1</code> 的 <code>balance</code> 进行了修改，涉及 <strong>数据页的变更</strong>，此时涉及 <strong>Undo Log、Redo Log 和缓冲池（Buffer Pool）</strong>。</p>
<h4 id="1-Undo-Log-记录数据的旧值"><a href="#1-Undo-Log-记录数据的旧值" class="headerlink" title="(1) Undo Log 记录数据的旧值"></a><strong>(1) Undo Log 记录数据的旧值</strong></h4><ul>
<li><pre><code>Undo Log
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> 记录 </span><br><span class="line"></span><br><span class="line">修改前的 `balance=1000`</span><br><span class="line"></span><br><span class="line">，以便事务回滚时能够恢复：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
UNDO_LOG: &#123; TABLE: accounts, ROW_ID: 1, OLD_VALUE: 1000, NEW_VALUE: 900 &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  Undo Log</span><br></pre></td></tr></table></figure>

 主要用于：

1. **事务回滚**：如果事务最终 `ROLLBACK`，MySQL 读取 `Undo Log` 并恢复 `balance = 1000`。
2. **MVCC（多版本并发控制）**：如果有事务要读取旧版本数据，MySQL 可以利用 `Undo Log` 构造**一致性快照**。
</code></pre>
</li>
</ul>
<h4 id="2-Redo-Log-记录数据变更"><a href="#2-Redo-Log-记录数据变更" class="headerlink" title="(2) Redo Log 记录数据变更"></a><strong>(2) Redo Log 记录数据变更</strong></h4><ul>
<li><pre><code>Redo Log
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> 记录 </span><br><span class="line"></span><br><span class="line">数据页的物理修改</span><br><span class="line"></span><br><span class="line">，保证事务崩溃后仍能恢复：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
REDO_LOG: &#123; TABLE: accounts, ROW_ID: 1, CHANGE: balance=900 &#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `Redo Log` **先写入 `Redo Buffer`，稍后刷盘到 `Redo Log` 文件**。</span><br><span class="line"></span><br><span class="line">#### **(3) 数据写入缓冲池（Buffer Pool）**</span><br><span class="line"></span><br><span class="line">- `UPDATE` 语句并不会**立即**将 `balance=900` 写入磁盘，而是修改 **Buffer Pool**（内存中的数据页）。</span><br><span class="line">- 之后 **由 InnoDB 的 Checkpoint 机制决定何时把数据同步到磁盘**。</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">### **🚀 Step 3：事务提交（COMMIT）**</span><br><span class="line"></span><br><span class="line">```sql</span><br><span class="line">COMMIT;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<p>当事务提交时，涉及 <strong>Redo Log、Binlog 以及 Undo Log</strong> 的处理。</p>
<h4 id="1-Binlog-记录完整的-SQL-操作"><a href="#1-Binlog-记录完整的-SQL-操作" class="headerlink" title="(1) Binlog 记录完整的 SQL 操作"></a><strong>(1) Binlog 记录完整的 SQL 操作</strong></h4><ul>
<li><p>Binlog 是逻辑日志</p>
<p>，记录的是 </p>
<p>SQL 语句</p>
<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BINLOG: &#123; TRANSACTION: &quot;UPDATE accounts SET balance = balance - 100 WHERE id = 1;&quot; &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Binlog </p>
<p>仅在事务提交时写入磁盘</p>
<p>，它的作用：</p>
<ol>
<li><strong>用于主从复制</strong>，保证主库与从库数据一致。</li>
<li><strong>用于 Point-in-Time Recovery（时间点恢复）</strong>，支持基于 Binlog 进行数据回溯。</li>
</ol>
</li>
</ul>
<h4 id="2-Redo-Log-标记事务提交"><a href="#2-Redo-Log-标记事务提交" class="headerlink" title="(2) Redo Log 标记事务提交"></a><strong>(2) Redo Log 标记事务提交</strong></h4><ul>
<li><p>Redo Log 采用 “WAL（Write-Ahead Logging）” 机制</p>
<p>，它在事务执行过程中就已经写入了 </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Redo Log Buffer</span><br></pre></td></tr></table></figure>

<p>，但 </p>
<p>只有在事务提交时，才会将事务标记为 “提交” 状态</p>
<p>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REDO_LOG: &#123; TRANSACTION_ID: 1001, STATUS: COMMITTED &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样，即使 MySQL <strong>崩溃重启</strong>，也能通过 Redo Log <strong>恢复已提交事务的数据</strong>。</p>
</li>
</ul>
<h4 id="3-Undo-Log-的处理"><a href="#3-Undo-Log-的处理" class="headerlink" title="(3) Undo Log 的处理"></a><strong>(3) Undo Log 的处理</strong></h4><ul>
<li><strong>Undo Log 不能立即删除！</strong></li>
<li><strong><code>Insert Undo Log</code> 可以立即删除</strong>（如果事务插入数据，回滚后不再需要）。</li>
<li><strong><code>Update Undo Log</code> 需要保留一段时间</strong>，用于 <strong>MVCC（多版本并发控制）</strong>。</li>
<li><strong>最终</strong>，当没有事务再需要这些 Undo Log 后，InnoDB 的 <code>Purge</code> 线程会清理它们。</li>
</ul>
<hr>
<h2 id="🔹-3-总结：三种日志的作用"><a href="#🔹-3-总结：三种日志的作用" class="headerlink" title="🔹 3. 总结：三种日志的作用"></a><strong>🔹 3. 总结：三种日志的作用</strong></h2><table>
<thead>
<tr>
<th><strong>日志类型</strong></th>
<th><strong>作用</strong></th>
<th><strong>写入时机</strong></th>
<th><strong>删除时机</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>Undo Log</strong></td>
<td>记录数据的<strong>旧值</strong>，支持事务回滚 &amp; MVCC</td>
<td>事务执行过程中写入</td>
<td><code>Insert Undo Log</code> 在 <code>COMMIT</code> 时可删除，<code>Update Undo Log</code> 需要等待 <code>MVCC</code> 处理后清理</td>
</tr>
<tr>
<td><strong>Redo Log</strong></td>
<td>记录<strong>数据页的物理修改</strong>，保证崩溃恢复</td>
<td>事务执行过程中写入</td>
<td>事务提交后，数据持久化到磁盘后可覆盖</td>
</tr>
<tr>
<td><strong>Binlog</strong></td>
<td>记录<strong>SQL 逻辑操作</strong>，用于主从复制 &amp; 数据恢复</td>
<td>事务提交时一次性写入</td>
<td>需要长期保留，以支持数据恢复</td>
</tr>
</tbody></table>
<hr>
<h2 id="🔹-4-事务回滚（ROLLBACK）"><a href="#🔹-4-事务回滚（ROLLBACK）" class="headerlink" title="🔹 4. 事务回滚（ROLLBACK）"></a><strong>🔹 4. 事务回滚（ROLLBACK）</strong></h2><p>如果事务 <strong>执行 <code>ROLLBACK</code></strong>，流程如下：</p>
<ol>
<li><strong>读取 <code>Undo Log</code></strong>，将 <code>balance = 900</code> 还原为 <code>1000</code>。</li>
<li><strong>不再写入 <code>Redo Log</code>（事务未提交）</strong>。</li>
<li><strong>Binlog 不会记录该事务（因为事务未提交）</strong>。</li>
</ol>
<hr>
<h2 id="🔹-5-事务崩溃恢复"><a href="#🔹-5-事务崩溃恢复" class="headerlink" title="🔹 5. 事务崩溃恢复"></a><strong>🔹 5. 事务崩溃恢复</strong></h2><p>如果在事务 <code>COMMIT</code> 之前发生崩溃：</p>
<ul>
<li><strong>Redo Log 记录了数据页修改</strong>，但 <strong>没有提交标记</strong>，MySQL 在恢复时会 <strong>丢弃这个未提交的事务</strong>。</li>
<li><strong>Undo Log 仍然有效</strong>，回滚事务，保证数据一致性。</li>
<li><strong>Binlog 没有记录这个事务（因为它在事务提交时才写入）</strong>。</li>
</ul>
<p>如果在事务 <code>COMMIT</code> 之后发生崩溃：</p>
<ul>
<li><strong>Redo Log 记录了事务提交标记</strong>，MySQL 通过 <code>Redo Log</code> 进行数据恢复。</li>
<li><strong>Binlog 记录完整事务，可用于主从复制</strong>。</li>
</ul>
<hr>
<h2 id="🔹-6-总结"><a href="#🔹-6-总结" class="headerlink" title="🔹 6. 总结"></a><strong>🔹 6. 总结</strong></h2><ol>
<li><strong>Undo Log</strong><ul>
<li><strong>作用</strong>：支持<strong>事务回滚</strong>和<strong>MVCC</strong>，记录<strong>数据的旧值</strong>。</li>
<li><strong>删除时机</strong>：Insert Undo 在事务提交时删除，Update Undo 需要等 MVCC 结束后清理。</li>
</ul>
</li>
<li><strong>Redo Log</strong><ul>
<li><strong>作用</strong>：保证数据 <strong>崩溃恢复</strong>，记录 <strong>数据页的物理修改</strong>。</li>
<li><strong>提交后数据才真正持久化</strong>，即使崩溃也能恢复。</li>
</ul>
</li>
<li><strong>Binlog</strong><ul>
<li><strong>作用</strong>：主从复制 &amp; 时间点恢复，记录 <strong>SQL 逻辑操作</strong>。</li>
<li><strong>提交时才写入</strong>，保证数据一致性。</li>
</ul>
</li>
</ol>
<p>👉 <strong>最终，MySQL 依靠</strong> <code>Undo Log</code> <strong>保证事务原子性（回滚）</strong>，<code>Redo Log</code> <strong>保证崩溃恢复</strong>，<code>Binlog</code> <strong>支持复制和数据恢复</strong>，三者互相配合，确保事务的可靠性和一致性。🚀</p>
<hr>
<p>你还有哪些疑问吗？😊</p>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a><a class="post-meta__tags" href="/tags/%E6%97%A5%E5%BF%97/">日志</a></div><div class="post-share"><div class="social-share" data-image="/img/4.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/03/03/80-05%20%E6%97%B6%E5%BA%8F%E9%A2%84%E6%B5%8B%E5%B7%A5%E4%B8%9A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/" title="80-05 时序预测工业应用场景"><img class="cover" src="/img/20.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">80-05 时序预测工业应用场景</div></div><div class="info-2"><div class="info-item-1">80-05 时序预测工业应用场景GPT推荐时序预测工业应用场景时间序列预测在工业场景中的应用分析时间序列预测在工业领域有广泛的应用，可以帮助优化生产、降低成本、提升效率和减少风险。以下是几个典型的工业应用场景：  1. 设备维护与故障预测（Predictive Maintenance）📌 场景：  工厂的传感器数据（如温度、振动、压力、电流等）可用于预测设备的健康状况，防止突发故障。 例如，风力发电机的传感器可以检测叶片的振动模式，预测可能的损坏时间，从而提前安排维修，降低停机损失。  📊 预测目标：  预测设备的剩余寿命（RUL，Remaining Useful Life）。 预测设备的异常趋势，提前进行预防性维护。  🔧 适用技术：  LSTM&#x2F;GRU（处理时间序列的状态变化）。 TCN（时间卷积网络）（捕捉长期依赖）。 Transformer（建模复杂的多变量时间序列）。   2. 生产需求预测（Demand Forecasting）📌...</div></div></div></a><a class="pagination-related" href="/2025/03/04/75-25%20MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7/" title="75-25 MySQL事务隔离等级"><img class="cover" src="/img/24.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">75-25 MySQL事务隔离等级</div></div><div class="info-2"><div class="info-item-1">75-25 MySQL事务隔离等级隔离级别 读未提交：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 读已提交：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 可重复读：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 可串行化：最高的隔离级别，完全服从 ACID...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/02/26/58%20MySQL/" title="58 MySQL"><img class="cover" src="/img/20.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-26</div><div class="info-item-2">58 MySQL</div></div><div class="info-2"><div class="info-item-1">58 MySQLMySQL基础基础概念元组：关系是⼀张表，表中的每⾏（即数据库中的 每条记录）就是⼀个元组，每列就是⼀个属性。 在⼆维表⾥，元组也称为**⾏**； 码：码指的是能够唯一标识&#x2F;区分元组（行）的一个或者一组属性； 候选码：在一个数据表中码可能存在很多组，而在这些码中存在其任何子集都不能唯一标识该元组的码我们称之为候选码； 主码：一个表存在多个候选码，从候选码中选出一个，我们把这个候选码称之为主码，一个表只能存在一个主码，我们也称主码为主键； 外码：我们类比一下，外码就是非本表的主码； 主属性：出现在候选码中的属性都称为主属性； 非主属性：在这个表中的所有属性中，只要不是主属性就是非主属性。 为什么不推荐使用外键和级联在高并发的情况下，外键可能会造成级联更新，级联更新是强阻塞，存 在数据库更新⻛暴的⻛险; 外键影响数据库的插⼊速度。 外键在一定程度上也会增加复杂性，同时也增加了额外工作，对分库分表不友好； 数据库范式第一范式通俗的来讲就是在一个表中的属性不可分割，即不可再分，1NF是所有关系型数据库的最基本要求。  第二范式2NF 在 1NF...</div></div></div></a><a class="pagination-related" href="/2025/03/03/75-23%20MySQL%E7%B4%A2%E5%BC%95/" title="75-23 MySQL索引"><img class="cover" src="/img/9.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-03</div><div class="info-item-2">75-23 MySQL索引</div></div><div class="info-2"><div class="info-item-1">75-23 MySQL索引前言索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。 其最主要的作用就是提供了一个数据结构让数据库可以快速的查询到目标数据。 MySQL8之后默认的存储引擎为InnoDB，但是无论是InnoDB还是MyISAM，其索引所选择的数据结构都是B+树。有个问题，为什么选择B+树作为其存储引擎的索引结构呢？ 优缺点认识一个新的事物，先来看看该事物有什么优点和缺点。 优点 第一点，不必多言，引入了索引之后，数据库在某些查询方面的效率大幅度提升，较少了IO次数（为什么）； 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。  缺点 如果我们将某些字段加入了索引，那么如果我对这个索引字段进行了修改，那么存储引擎也会同步的对索引进行更新，那么必然就会造成SQL执行效率降低； MySQL同时需要保存索引排序后的物理文件，这在一定程度上也会耗费一些空间（问题不大）；  但是总体来说，如果数据库的数据量比较大的情况下，引入索引好处是优于坏处的，索引查询绝大部分情况下是比全表查询要快的。 B 树&amp; B+树B 树也称...</div></div></div></a><a class="pagination-related" href="/2025/03/04/75-26%20MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" title="75-26 MVCC多版本并发控制"><img class="cover" src="/img/16.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-04</div><div class="info-item-2">75-26 MVCC多版本并发控制</div></div><div class="info-2"><div class="info-item-1">75-26 MVCC多版本并发控制前言MVCC ，也就是多版本并发控制，是为了在读取数据时不加锁来提高读取效率和并发性的一种手段。 数据库并发有以下几种场景：  读-读：不存在任何问题。 读-写：有线程安全问题，可能出现脏读、幻读、不可重复读。 写-写：有线程安全问题，可能存在更新丢失等。  MVCC 解决的就是读写时的线程安全问题，线程不用去争抢读写锁。 MVCC 允许多个事务并发执行，同时避免加锁带来的性能问题。其本质是通过维护数据的多个版本，让事务可以“看到”不同的历史数据版本，从而实现非阻塞读。 在 MySQL 的 InnoDB 存储引擎中，MVCC 主要用于 READ COMMITTED 和 REPEATABLE READ 两个隔离级别。 当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。  在 MySQL 的 InnoDB 存储引擎中，快照通过 Undo Log 来实现。每次数据更新时，InnoDB 会保存旧版本的数据，并通过指针来链式存储这些旧版本数据，从而形成数据的版本链。  Undo Log...</div></div></div></a><a class="pagination-related" href="/2025/03/04/75-25%20MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7/" title="75-25 MySQL事务隔离等级"><img class="cover" src="/img/24.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-04</div><div class="info-item-2">75-25 MySQL事务隔离等级</div></div><div class="info-2"><div class="info-item-1">75-25 MySQL事务隔离等级隔离级别 读未提交：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 读已提交：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 可重复读：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 可串行化：最高的隔离级别，完全服从 ACID...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">徐行</div><div class="author-info-description">道阻且长</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">118</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">84</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">33</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/fangyaohui"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#75-24-MySQL%E6%97%A5%E5%BF%97"><span class="toc-number">1.</span> <span class="toc-text">75-24 MySQL日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redo-Log"><span class="toc-number">1.2.</span> <span class="toc-text">Redo Log</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E7%9B%98%E6%97%B6%E6%9C%BA"><span class="toc-number">1.2.1.</span> <span class="toc-text">刷盘时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.2.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binlog"><span class="toc-number">1.3.</span> <span class="toc-text">binlog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%BA%E5%BA%8F%E5%86%99%EF%BC%9F"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 什么是顺序写？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%A1%BA%E5%BA%8F%E5%86%99%E7%9A%84%E5%8F%8D%E9%9D%A2%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 顺序写的反面是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">记录格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.4.</span> <span class="toc-text">写入机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">1.4.</span> <span class="toc-text">两阶段提交</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%A4%BA%E4%BE%8B%EF%BC%9AMySQL-%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">1. 示例：MySQL 事务执行过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Redo-Log-%E5%92%8C-Binlog-%E5%9C%A8%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%86%99%E5%85%A5%E6%97%B6%E6%9C%BA"><span class="toc-number">1.6.</span> <span class="toc-text">2. Redo Log 和 Binlog 在事务中的写入时机</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Step-1%E3%80%91%E5%BC%80%E5%A7%8B%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.6.1.</span> <span class="toc-text">【Step 1】开始事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Step-2%E3%80%91%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%B8%80%E4%B8%AA-UPDATE-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.6.2.</span> <span class="toc-text">【Step 2】执行第一个 UPDATE 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Step-3%E3%80%91%E6%89%A7%E8%A1%8C%E7%AC%AC%E4%BA%8C%E4%B8%AA-UPDATE-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.6.3.</span> <span class="toc-text">【Step 3】执行第二个 UPDATE 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%90Step-4%E3%80%91%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1%EF%BC%88COMMIT%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">【Step 4】提交事务（COMMIT）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88-Redo-Log-%E5%8F%AF%E4%BB%A5%E6%8F%90%E5%89%8D%E5%86%99%E5%85%A5%EF%BC%8C%E8%80%8C-Binlog-%E5%8F%AA%E8%83%BD%E5%9C%A8%E6%8F%90%E4%BA%A4%E6%97%B6%E5%86%99%EF%BC%9F"><span class="toc-number">1.7.</span> <span class="toc-text">3. 为什么 Redo Log 可以提前写入，而 Binlog 只能在提交时写？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%8E%B0%E5%AE%9E%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.8.</span> <span class="toc-text">4. 现实场景下的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF-1%EF%BC%9AMySQL-%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D"><span class="toc-number">1.8.1.</span> <span class="toc-text">✅ 场景 1：MySQL 崩溃恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%9C%85-%E5%9C%BA%E6%99%AF-2%EF%BC%9AMySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">1.8.2.</span> <span class="toc-text">✅ 场景 2：MySQL 主从复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undo-log"><span class="toc-number">1.9.</span> <span class="toc-text">undo log</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL-%E4%BA%8B%E5%8A%A1%E4%B8%AD-Undo-Log%E3%80%81Redo-Log-%E5%92%8C-Binlog-%E7%9A%84%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.9.1.</span> <span class="toc-text">MySQL 事务中 Undo Log、Redo Log 和 Binlog 的协同工作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B9-1-%E4%BA%8B%E5%8A%A1%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.10.</span> <span class="toc-text">🔹 1. 事务示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B9-2-Undo-Log%E3%80%81Redo-Log-%E5%92%8C-Binlog-%E5%9C%A8%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.11.</span> <span class="toc-text">🔹 2. Undo Log、Redo Log 和 Binlog 在事务中的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9A%80-Step-1%EF%BC%9A%E4%BA%8B%E5%8A%A1%E5%BC%80%E5%A7%8B%EF%BC%88BEGIN%EF%BC%89"><span class="toc-number">1.11.1.</span> <span class="toc-text">🚀 Step 1：事务开始（BEGIN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%9A%80-Step-2%EF%BC%9A%E6%89%A7%E8%A1%8C-UPDATE-%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.11.2.</span> <span class="toc-text">🚀 Step 2：执行 UPDATE 语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Undo-Log-%E8%AE%B0%E5%BD%95%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%A7%E5%80%BC"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">(1) Undo Log 记录数据的旧值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Redo-Log-%E8%AE%B0%E5%BD%95%E6%95%B0%E6%8D%AE%E5%8F%98%E6%9B%B4"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">(2) Redo Log 记录数据变更</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Binlog-%E8%AE%B0%E5%BD%95%E5%AE%8C%E6%95%B4%E7%9A%84-SQL-%E6%93%8D%E4%BD%9C"><span class="toc-number">1.11.2.3.</span> <span class="toc-text">(1) Binlog 记录完整的 SQL 操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-Redo-Log-%E6%A0%87%E8%AE%B0%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4"><span class="toc-number">1.11.2.4.</span> <span class="toc-text">(2) Redo Log 标记事务提交</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Undo-Log-%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.11.2.5.</span> <span class="toc-text">(3) Undo Log 的处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B9-3-%E6%80%BB%E7%BB%93%EF%BC%9A%E4%B8%89%E7%A7%8D%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.12.</span> <span class="toc-text">🔹 3. 总结：三种日志的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B9-4-%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%EF%BC%88ROLLBACK%EF%BC%89"><span class="toc-number">1.13.</span> <span class="toc-text">🔹 4. 事务回滚（ROLLBACK）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B9-5-%E4%BA%8B%E5%8A%A1%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D"><span class="toc-number">1.14.</span> <span class="toc-text">🔹 5. 事务崩溃恢复</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B9-6-%E6%80%BB%E7%BB%93"><span class="toc-number">1.15.</span> <span class="toc-text">🔹 6. 总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/04/07/75-50%20ElasticSearch/" title="75-50 Elasticsearch"><img src="/img/6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="75-50 Elasticsearch"/></a><div class="content"><a class="title" href="/2025/04/07/75-50%20ElasticSearch/" title="75-50 Elasticsearch">75-50 Elasticsearch</a><time datetime="2025-04-07T13:46:17.000Z" title="发表于 2025-04-07 21:46:17">2025-04-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/05/75-49%20Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="75-49 Go语言学习"><img src="/img/4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="75-49 Go语言学习"/></a><div class="content"><a class="title" href="/2025/04/05/75-49%20Go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" title="75-49 Go语言学习">75-49 Go语言学习</a><time datetime="2025-04-05T09:46:17.000Z" title="发表于 2025-04-05 17:46:17">2025-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/05/80-07%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%96%B9%E5%90%91/" title="80-07 时间序列大模型方向"><img src="/img/10.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="80-07 时间序列大模型方向"/></a><div class="content"><a class="title" href="/2025/04/05/80-07%20%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%96%B9%E5%90%91/" title="80-07 时间序列大模型方向">80-07 时间序列大模型方向</a><time datetime="2025-04-04T16:56:17.000Z" title="发表于 2025-04-05 00:56:17">2025-04-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/04/01/75-48%20RabbitMQ/" title="75-48 RabbitMQ"><img src="/img/13.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="75-48 RabbitMQ"/></a><div class="content"><a class="title" href="/2025/04/01/75-48%20RabbitMQ/" title="75-48 RabbitMQ">75-48 RabbitMQ</a><time datetime="2025-04-01T09:46:17.000Z" title="发表于 2025-04-01 17:46:17">2025-04-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/31/79-05%20%E6%99%BA%E5%8D%B7%E4%BA%91%E9%97%AE%E9%A2%98%E5%8F%91%E7%8E%B0&amp;%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="79-05 智卷云问题发现&amp;解决方案"><img src="/img/23.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="79-05 智卷云问题发现&amp;解决方案"/></a><div class="content"><a class="title" href="/2025/03/31/79-05%20%E6%99%BA%E5%8D%B7%E4%BA%91%E9%97%AE%E9%A2%98%E5%8F%91%E7%8E%B0&amp;%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="79-05 智卷云问题发现&amp;解决方案">79-05 智卷云问题发现&amp;解决方案</a><time datetime="2025-03-31T07:58:17.000Z" title="发表于 2025-03-31 15:58:17">2025-03-31</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/index_img.png);"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">道阻且长</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>