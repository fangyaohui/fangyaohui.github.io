<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>58 MySQL | 孤岛</title><meta name="author" content="徐行"><meta name="copyright" content="徐行"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="58 MySQLMySQL基础基础概念元组：关系是⼀张表，表中的每⾏（即数据库中的 每条记录）就是⼀个元组，每列就是⼀个属性。 在⼆维表⾥，元组也称为**⾏**； 码：码指的是能够唯一标识&#x2F;区分元组（行）的一个或者一组属性； 候选码：在一个数据表中码可能存在很多组，而在这些码中存在其任何子集都不能唯一标识该元组的码我们称之为候选码； 主码：一个表存在多个候选码，从候选码中选出一个，我们把">
<meta property="og:type" content="article">
<meta property="og:title" content="58 MySQL">
<meta property="og:url" content="http://example.com/2025/02/26/58%20MySQL/index.html">
<meta property="og:site_name" content="孤岛">
<meta property="og:description" content="58 MySQLMySQL基础基础概念元组：关系是⼀张表，表中的每⾏（即数据库中的 每条记录）就是⼀个元组，每列就是⼀个属性。 在⼆维表⾥，元组也称为**⾏**； 码：码指的是能够唯一标识&#x2F;区分元组（行）的一个或者一组属性； 候选码：在一个数据表中码可能存在很多组，而在这些码中存在其任何子集都不能唯一标识该元组的码我们称之为候选码； 主码：一个表存在多个候选码，从候选码中选出一个，我们把">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/14.png">
<meta property="article:published_time" content="2025-02-26T10:58:17.000Z">
<meta property="article:modified_time" content="2025-03-12T08:14:17.006Z">
<meta property="article:author" content="徐行">
<meta property="article:tag" content="数据库">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/14.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "58 MySQL",
  "url": "http://example.com/2025/02/26/58%20MySQL/",
  "image": "http://example.com/img/14.png",
  "datePublished": "2025-02-26T10:58:17.000Z",
  "dateModified": "2025-03-12T08:14:17.006Z",
  "author": [
    {
      "@type": "Person",
      "name": "徐行",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/02/26/58%20MySQL/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '58 MySQL',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/14.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">孤岛</span></a><a class="nav-page-title" href="/"><span class="site-name">58 MySQL</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">58 MySQL</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-26T10:58:17.000Z" title="发表于 2025-02-26 18:58:17">2025-02-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-12T08:14:17.006Z" title="更新于 2025-03-12 16:14:17">2025-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">18.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="58-MySQL"><a href="#58-MySQL" class="headerlink" title="58 MySQL"></a>58 MySQL</h1><h2 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><p>元组：关系是⼀张表，表中的每⾏（即数据库中的 每条记录）就是⼀个元组，每列就是⼀个属性。 在⼆维表⾥，元组也称为**⾏**；</p>
<p>码：码指的是能够唯一标识&#x2F;区分元组（行）的一个或者一组属性；</p>
<p>候选码：在一个数据表中码可能存在很多组，而在这些码中存在<strong>其任何子集都不能唯一标识该元组的码</strong>我们称之为候选码；</p>
<p>主码：一个表存在多个候选码，从候选码中选出一个，我们把这个候选码称之为主码，一个表只能存在一个主码，我们也称主码为主键；</p>
<p>外码：我们类比一下，外码就是非本表的主码；</p>
<p>主属性：出现在候选码中的属性都称为主属性；</p>
<p>非主属性：在这个表中的所有属性中，只要不是主属性就是非主属性。</p>
<h4 id="为什么不推荐使用外键和级联"><a href="#为什么不推荐使用外键和级联" class="headerlink" title="为什么不推荐使用外键和级联"></a>为什么不推荐使用外键和级联</h4><p>在高并发的情况下，外键可能会造成级联更新，级联更新是强阻塞，存 在数据库更新⻛暴的⻛险; 外键影响数据库的插⼊速度。</p>
<p>外键在一定程度上也会增加复杂性，同时也增加了额外工作，对分库分表不友好；</p>
<h4 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h4><h5 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h5><p>通俗的来讲就是在一个表中的属性不可分割，即不可再分，1NF是所有关系型数据库的最基本要求。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262006719.png" alt="image-20240906144004121"></p>
<h5 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h5><p><strong>2NF 在 1NF 的基础之上，消除了⾮主属性对于码的部分函数依赖。</strong></p>
<p><strong>第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262006551.png" alt="image-20240906144228145"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262006981.png" alt="image-20240906145007347"></p>
<h5 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h5><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262006282.png" alt="image-20240906144716968"></p>
<p>**3NF 在 2NF 的基础之上，消除了⾮主属性对于码的传递函数依赖 。**符合 3NF 要求的数据库设计， 基本上解决了数据冗余过⼤，插⼊异常，修改异常，删除异常的问题。</p>
<p><strong>在2NF基础上，任何非主属性(opens new window)不依赖于其它非主属性（在2NF基础上消除传递依赖）。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262006137.png" alt="image-20240906144832578"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262006634.png" alt="image-20240906145143433"></p>
<h4 id="drop、delete-与-truncate-区别？"><a href="#drop、delete-与-truncate-区别？" class="headerlink" title="drop、delete 与 truncate 区别？"></a>drop、delete 与 truncate 区别？</h4><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262006417.png" alt="image-20240906162330746"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262006693.png" alt="image-20240906162517712"></p>
<h4 id="常见关系型数据库"><a href="#常见关系型数据库" class="headerlink" title="常见关系型数据库"></a>常见关系型数据库</h4><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262006292.png" alt="image-20240906163157862"></p>
<h4 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h4><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262006522.png" alt="image-20240909190029815"></p>
<p>MySQL查询缓存在MySQL8.0之后被移除，因为其的实用性并不是很好。</p>
<h4 id="何时选择SQL又什么时候选择NoSQL呢"><a href="#何时选择SQL又什么时候选择NoSQL呢" class="headerlink" title="何时选择SQL又什么时候选择NoSQL呢"></a>何时选择SQL又什么时候选择NoSQL呢</h4><p>回答这个问题，主要针对于SQL满足四大特性，即ACID，而NoSQL满足BASD。这分别什么意思呢？</p>
<p>SQL：原子性、持久性、隔离性保证了强一致性，而NoSQL只保证最终一致性，所以在具体的业务场景中如果对数据要求强一致性的话考虑SQL数据库。</p>
<p>但是NoSQL可扩展性很好，且数据直接是无关系的。NoSQL数据之间无关系，这样就非常容易扩展，也无形之间，在架构的层面上带来了可扩展的能力。比如 redis 自带主从复制模式、哨兵模式、切片集群模式。 相反关系型数据库的数据之间存在关联性，水平扩展较难 ，需要解决跨服务器 JOIN，分布式事务等问题。</p>
<h4 id="MySQL如何进行联表查询"><a href="#MySQL如何进行联表查询" class="headerlink" title="MySQL如何进行联表查询"></a>MySQL如何进行联表查询</h4><h5 id="内连接（INNER-JOIN"><a href="#内连接（INNER-JOIN" class="headerlink" title="内连接（INNER JOIN)"></a>内连接（INNER JOIN)</h5><p>一句话：<strong>内连接</strong>会返回两个表中<strong>满足连接条件</strong>的匹配记录，过滤掉不匹配的记录。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名</span><br><span class="line"><span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> 表<span class="number">1.</span>关联列 <span class="operator">=</span> 表<span class="number">2.</span>关联列;</span><br></pre></td></tr></table></figure>

<h5 id="左外连接-LEFT-JOIN"><a href="#左外连接-LEFT-JOIN" class="headerlink" title="左外连接 (LEFT JOIN)"></a>左外连接 (LEFT JOIN)</h5><p>一句话：返回左表（主表）的所有记录，即使右表没有匹配。 若右表无匹配，右表字段显示为 NULL。 核心逻辑：“左表为主，右表补充”。</p>
<h5 id="右外连接-RIGHT-JOIN"><a href="#右外连接-RIGHT-JOIN" class="headerlink" title="右外连接 (RIGHT JOIN)"></a>右外连接 (RIGHT JOIN)</h5><p>一句话：返回右表（主表）的所有记录，即使左表没有匹配。 若左表无匹配，左表字段显示为 NULL。 核心逻辑：“右表为主，左表补充”。</p>
<h5 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h5><p>一句话：都要，为Null都要。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503121411192.png" alt="image-20250312141103084"></p>
<h4 id="Group-By-聚合函数"><a href="#Group-By-聚合函数" class="headerlink" title="Group By 聚合函数"></a>Group By 聚合函数</h4><p><a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0&spm=1001.2101.3001.7020">聚合函数</a>对一组值进行计算并返回单一的值，通常聚合函数会与SELECT语句的GROUP BY子句一同使用，在与GROUP BY子句使用时，聚合函数会为每一个组产生一个单一值，而不会为整个表产生一个单一值.</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503121434191.png" alt="image-20250312143404138"></p>
<h4 id="SQL查询语句的执行顺序是怎么样的？"><a href="#SQL查询语句的执行顺序是怎么样的？" class="headerlink" title="SQL查询语句的执行顺序是怎么样的？"></a>SQL查询语句的执行顺序是怎么样的？</h4><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503121446316.png" alt="image-20250312144616250"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(9) SELECT </span><br><span class="line">(10) DISTINCT &lt;column&gt;,</span><br><span class="line">(6) AGG_FUNC &lt;column&gt; or &lt;expression&gt;, ...</span><br><span class="line">(1) FROM &lt;left_table&gt; </span><br><span class="line">    (3) &lt;join_type&gt;JOIN&lt;right_table&gt;</span><br><span class="line">    (2) ON&lt;join_condition&gt;</span><br><span class="line">(4) WHERE &lt;where_condition&gt;</span><br><span class="line">(5) GROUP BY &lt;group_by_list&gt;</span><br><span class="line">(7) WITH &#123;CUBE|ROLLUP&#125;</span><br><span class="line">(8) HAVING &lt;having_condtion&gt;</span><br><span class="line">(11) ORDER BY &lt;order_by_list&gt;</span><br><span class="line">(12) LIMIT &lt;limit_number&gt;;</span><br></pre></td></tr></table></figure>





<h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>SQL（Structured Query Language）是“结构化查询语言”，它是对关系型数据库的操作语言。它可以应用到所有关系型数据库中，例如：MySQL、Oracle、SQL Server 等。SQL 标准（ANSI&#x2F;ISO）有：</p>
<p>SQL-92：1992 年发布的 SQL 语言标准；</p>
<p>SQL:1999：1999 年发布的 SQL 语言标签；</p>
<p>SQL:2003：2003 年发布的 SQL 语言标签；</p>
<p>这些标准就与 JDK 的版本一样，在新的版本中总要有一些语法的变化。不同时期的数据库对不同标准做了实现。</p>
<p>虽然 SQL 可以用在所有关系型数据库中，但很多数据库还都有标准之后的一些语法，我们可以称之为“方言”。例如 MySQL 中的 LIMIT 语句就是 MySQL 独有的方言，其它数据库都不支持！当然，Oracle 或 SQL Server 都有自己的方言。</p>
<ul>
<li>SQL 语句可以单行或多行书写，以分号结尾；</li>
<li>可以用空格和缩进来来增强语句的可读性；</li>
<li>关键字不区别大小写，建议使用大写；</li>
</ul>
<h4 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h4><ol>
<li><p>DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等；</p>
</li>
<li><p>DML（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）；</p>
</li>
<li><p>DCL（Data Control Language）：数据控制语言，用来定义访问权限和安全级别；</p>
</li>
<li><p>DQL（Data Query Language）：数据查询语言，用来查询记录（数据）</p>
</li>
</ol>
<h4 id="DDL（Data-Definition-Language）：数据定义语言"><a href="#DDL（Data-Definition-Language）：数据定义语言" class="headerlink" title="DDL（Data Definition Language）：数据定义语言"></a>DDL（Data Definition Language）：数据定义语言</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases; <span class="operator">/</span><span class="operator">/</span> 查看当前建立的所有数据库</span><br><span class="line">use mysqldb; <span class="operator">/</span><span class="operator">/</span> 切换到指定数据库</span><br><span class="line"><span class="keyword">create</span> database [if <span class="keyword">not</span> <span class="keyword">exists</span>] mydb1; <span class="operator">/</span><span class="operator">/</span> 创建数据库 如果没有存在的话</span><br><span class="line"><span class="keyword">drop</span> database [if <span class="keyword">exists</span>] mydb1; <span class="operator">/</span><span class="operator">/</span> 删除指定数据库</span><br><span class="line"><span class="keyword">alter</span> database mydb1 <span class="keyword">character set</span> utf8; <span class="operator">/</span><span class="operator">/</span> 修改数据库编码</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 创建表</span><br><span class="line"><span class="keyword">CREATE TABLE</span> stu(</span><br><span class="line">	sid <span class="type">CHAR</span>(<span class="number">6</span>), </span><br><span class="line">	sname <span class="type">VARCHAR</span>(<span class="number">20</span>), </span><br><span class="line">	age <span class="type">INT</span>, </span><br><span class="line">	gender <span class="type">VARCHAR</span>(<span class="number">10</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">DESC</span> 表名； <span class="operator">/</span><span class="operator">/</span> 查看表的结构</span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> 表名； <span class="operator">/</span><span class="operator">/</span> 删除表</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 修改表</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 添加列：给 stu 表添加 classname 列</span><br><span class="line"><span class="keyword">ALTER TABLE</span> stu <span class="keyword">ADD</span> (classname <span class="type">varchar</span>(<span class="number">100</span>));</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 修改列的数据类型：修改 stu 表的 gender 列类型为 <span class="type">CHAR</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">ALTER TABLE</span> stu MODIFY gender <span class="type">CHAR</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 修改列名：修改 stu 表的 gender 列名为 sex</span><br><span class="line"><span class="keyword">ALTER TABLE</span> stu change gender sex <span class="type">CHAR</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 删除列：删除 stu 表的 classname 列</span><br><span class="line"><span class="keyword">ALTER TABLE</span> stu <span class="keyword">DROP</span> classname;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 修改表名称：修改 stu 表名称为 student</span><br><span class="line"><span class="keyword">ALTER TABLE</span> stu RENAME <span class="keyword">TO</span> student;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>数据类型：</p>
<ul>
<li>int：整型</li>
<li>double：浮点型，例如 double(5,2)表示最多 5 位，其中必须有 2 位小数，即最大值为 999.99；</li>
<li>decimal：泛型型，在表单线方面使用该类型，因为不会出现精度缺失问题；</li>
<li>char：固定长度字符串类型；(当输入的字符不够长度时会补空格)</li>
<li>varchar：固定长度字符串类型；</li>
<li>text：字符串类型；</li>
<li>blob：字节类型；</li>
<li>date：日期类型，格式为：yyyy-MM-dd；</li>
<li>time：时间类型，格式为：hh:mm:ss</li>
<li>timestamp：时间戳类型；</li>
</ul>
<h4 id="DML（Data-Manipulation-Language）：数据操作语言"><a href="#DML（Data-Manipulation-Language）：数据操作语言" class="headerlink" title="DML（Data Manipulation Language）：数据操作语言"></a>DML（Data Manipulation Language）：数据操作语言</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 插入数据</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 语法<span class="number">1</span></span><br><span class="line"><span class="keyword">INSERT INTO</span> stu(sid, sname) <span class="keyword">VALUES</span>(<span class="string">&#x27;s_1001&#x27;</span>, <span class="string">&#x27;zhangSan&#x27;</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 语法 <span class="number">2</span> </span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 因为没有指定要插入的列，表示按创建表时列的顺序插入所有列的值：</span><br><span class="line"><span class="keyword">INSERT INTO</span> stu <span class="keyword">VALUES</span>(<span class="string">&#x27;s_1002&#x27;</span>, <span class="string">&#x27;liSi&#x27;</span>, <span class="number">32</span>, <span class="string">&#x27;female&#x27;</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 注意：所有字符串数据必须使用单引用！</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 修改数据</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">UPDATE</span> 表名 <span class="keyword">SET</span> 列名 <span class="number">1</span><span class="operator">=</span>值 <span class="number">1</span>, … 列名 n<span class="operator">=</span>值 n [<span class="keyword">WHERE</span> 条件];</span><br><span class="line"><span class="keyword">UPDATE</span> stu <span class="keyword">SET</span> sname<span class="operator">=</span>’zhangSanSan’, age<span class="operator">=</span>’<span class="number">32</span>’, gender<span class="operator">=</span>’female’ <span class="keyword">WHERE</span> sid<span class="operator">=</span>’s_1001’;</span><br><span class="line"><span class="keyword">UPDATE</span> stu <span class="keyword">SET</span> sname<span class="operator">=</span>’liSi’, age<span class="operator">=</span>’<span class="number">20</span>’<span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">50</span> <span class="keyword">AND</span> gender<span class="operator">=</span>’male’;</span><br><span class="line"><span class="keyword">UPDATE</span> stu <span class="keyword">SET</span> sname<span class="operator">=</span>’wangWu’, age<span class="operator">=</span>’<span class="number">30</span>’<span class="keyword">WHERE</span> age<span class="operator">&gt;</span><span class="number">60</span> <span class="keyword">OR</span> gender<span class="operator">=</span>’female’;</span><br><span class="line"><span class="keyword">UPDATE</span> stu <span class="keyword">SET</span> gender<span class="operator">=</span>’female’<span class="keyword">WHERE</span> gender <span class="keyword">IS</span> <span class="keyword">NULL</span></span><br><span class="line"><span class="keyword">UPDATE</span> stu <span class="keyword">SET</span> age<span class="operator">=</span>age<span class="operator">+</span><span class="number">1</span> <span class="keyword">WHERE</span> sname<span class="operator">=</span>’zhaoLiu’;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 删除数据</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">DELETE</span> <span class="keyword">FROM</span> 表名 [<span class="keyword">WHERE</span> 条件];</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> sid<span class="operator">=</span>’s_1001’<span class="number">003</span>B;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stu <span class="keyword">WHERE</span> sname<span class="operator">=</span>’chenQi’ <span class="keyword">OR</span> age <span class="operator">&gt;</span> <span class="number">30</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> stu;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 语法 <span class="number">2</span>：<span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> 表名;</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> stu;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 两者之间的区别：虽然 <span class="keyword">TRUNCATE</span> 和 <span class="keyword">DELETE</span> 都可以删除表的所有记录，但有原理不同。<span class="keyword">DELETE</span>的效率没有 <span class="keyword">TRUNCATE</span> 高！<span class="keyword">TRUNCATE</span> 其实属性 DDL 语句，因为它是先 <span class="keyword">DROP</span> <span class="keyword">TABLE</span>，再 <span class="keyword">CREATE TABLE</span>。而且<span class="keyword">TRUNCATE</span>删除的记录是无法回滚的，但<span class="keyword">DELETE</span>删除的记录是可以回滚的（回滚是事务的知识！）。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="DCL（Data-Control-Language）：数据控制语言"><a href="#DCL（Data-Control-Language）：数据控制语言" class="headerlink" title="DCL（Data Control Language）：数据控制语言"></a>DCL（Data Control Language）：数据控制语言</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 创建用户</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 语法：<span class="keyword">CREATE</span> <span class="keyword">USER</span> ‘用户名’@地址 IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;密码&#x27;</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> ‘user1’<span class="variable">@localhost</span> IDENTIFIED <span class="keyword">BY</span> ‘<span class="number">123</span>’;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> ‘user2’@’<span class="operator">%</span>’ IDENTIFIED <span class="keyword">BY</span> ‘<span class="number">123</span>’;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 给用户授权</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 语法：<span class="keyword">GRANT</span> 权限 <span class="number">1</span>, … , 权限 n <span class="keyword">ON</span> 数据库.<span class="operator">*</span> <span class="keyword">TO</span> ‘用户名’@地址;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">CREATE</span>,<span class="keyword">ALTER</span>,<span class="keyword">DROP</span>,<span class="keyword">INSERT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span>,<span class="keyword">SELECT</span> <span class="keyword">ON</span> mydb1.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;user1&#x27;</span><span class="variable">@localhost</span>;</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> mydb1.<span class="operator">*</span> <span class="keyword">TO</span> user2<span class="variable">@localhost</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 撤销授权</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 语法：<span class="keyword">REVOKE</span> 权限 <span class="number">1</span>, … , 权限 n <span class="keyword">ON</span> 数据库.<span class="operator">*</span> <span class="keyword">FROM</span> ‘用户名’@地址;</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">CREATE</span>,<span class="keyword">ALTER</span>,<span class="keyword">DROP</span> <span class="keyword">ON</span> mydb1.<span class="operator">*</span> <span class="keyword">FROM</span> <span class="string">&#x27;user1&#x27;</span><span class="variable">@localhost</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 查看用户权限</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 语法：<span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> ‘用户名’@地址;</span><br><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> <span class="string">&#x27;user1&#x27;</span><span class="variable">@localhost</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 删除用户</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 语法：<span class="keyword">DROP</span> <span class="keyword">USER</span> ‘用户名’@地址;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> ‘user1’<span class="variable">@localhost</span>;</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 修改用户密码（以root身份）</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 语法 ：use mysql;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="string">&#x27;用户名&#x27;</span><span class="variable">@localhost</span> identified <span class="keyword">by</span> <span class="string">&#x27;新密码&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="DQL（Data-Query-Language）：数据查询语言"><a href="#DQL（Data-Query-Language）：数据查询语言" class="headerlink" title="DQL（Data Query Language）：数据查询语言"></a>DQL（Data Query Language）：数据查询语言</h4><p>语法：</p>
<ul>
<li>select 列名 —-&gt; 要查询的列名称</li>
<li>from 表名 —-&gt; 要查询的表名称</li>
<li>where 条件 —-&gt; 行条件</li>
<li>group by 分组列 —-&gt; 对结果分组</li>
<li>having 分组条件 —-&gt; 分组后的行条件</li>
<li>order by 排序列 —-&gt; 对结果分组</li>
<li>limit 起始行, 行数 —-&gt; 结果限定</li>
</ul>
<h5 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h5><p>条件查询介绍<br>条件查询就是在查询时给出 WHERE 子句，在 WHERE 子句中可以使用如下运算符及关键字：</p>
<ul>
<li>&#x3D;、!&#x3D;、&lt;&gt;、&lt;、&lt;&#x3D;、&gt;、&gt;&#x3D;；</li>
<li>BETWEEN…AND；</li>
<li>IN(set)；</li>
<li>IS NULL；</li>
<li>AND；</li>
<li>OR；</li>
<li>NOT；</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262006155.png" alt="image-20240904110449093"></p>
<h5 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h5><p>SELECT 字段 FROM 表 WHERE 某字段 Like 条件<br>其中关于条件，SQL 提供了两种匹配模式：</p>
<p>% ：表示任意 0 个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。</p>
<p>_ ： 表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字 符长度语句。</p>
<h5 id="字段控制查询"><a href="#字段控制查询" class="headerlink" title="字段控制查询"></a>字段控制查询</h5><p>去掉重复记录</p>
<p>去除重复记录（两行或两行以上记录中系列的上的数据都相同），例如 emp 表中 sal 字段就存在相同的记录。当只查询 emp 表的 sal 字段时，那么会出现重复记录，那么想去除重复记录，需要使用 <strong>DISTINCT</strong>：</p>
<p>SELECT DISTINCT sal FROM emp;</p>
<p>查看雇员的月薪与佣金之和</p>
<p>因为 sal 和 comm 两列的类型都是数值类型，所以可以做加运算。如果 sal 或 comm 中有一个字段不是数值类型，那么会出错。</p>
<p>SELECT *,<br>sal+comm FROM emp;</p>
<p>comm 列有很多记录的值为 NULL，因为任何东西与 NULL 相加结果还是 NULL，所以结算结果可能会出现 NULL。下面使用了把 NULL 转换成数值 0 的函数 IFNULL：</p>
<p>SELECT *, sal+IFNULL(comm,0) FROM emp;</p>
<p>给列名添加别名</p>
<p>在上面查询中出现列名为 sal+IFNULL(comm,0)，这很不美观，现在我们给这一列给出一个别名，为 total：</p>
<p>SELECT *, sal+IFNULL(comm,0) AS total FROM emp;<br>给列起别名时，是可以省略 AS 关键字的：</p>
<p>SELECT *, sal+IFNULL(comm,0) total FROM emp;</p>
<h4 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h4><p>参考资料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/92654574?source_id=1005">通俗易懂的学会：SQL窗口函数</a></li>
</ol>
<h5 id="窗口函数应用场景"><a href="#窗口函数应用场景" class="headerlink" title="窗口函数应用场景"></a>窗口函数应用场景</h5><p>在日常工作中，经常会遇到需要<strong>在每组内排名</strong>，比如下面的业务需求：</p>
<blockquote>
<p><strong>排名问题：<strong>每个部门按业绩来排名</strong><br>       <strong>topN问题</strong>：找出每个部门排名前N的员工进行奖励</strong></p>
</blockquote>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>窗口函数<span class="operator">&gt;</span> <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> <span class="operator">&lt;</span>用于分组的列名<span class="operator">&gt;</span></span><br><span class="line">                <span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>用于排序的列名<span class="operator">&gt;</span>)</span><br><span class="line">                </span><br></pre></td></tr></table></figure>

<blockquote>
<p>&lt;窗口函数&gt;的位置，可以放以下两种函数：</p>
<p>1） 专用窗口函数，包括后面要讲到的rank, dense_rank, row_number等专用窗口函数。</p>
<p>2） 聚合函数，如sum. avg, count, max, min等</p>
<p>因为窗口函数是对where或者group by子句处理后的结果进行操作，所以窗口函数原则上只能写在select子句中。</p>
</blockquote>
<p><strong>窗口函数有以下功能：</strong></p>
<p>1）同时具有分组（partition by）和排序（order by）的功能</p>
<p>2）不减少原表的行数，所以经常用来在每组内排名</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262006373.png" alt="image-20240905221424939"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262006254.png" alt="image-20240905221437164"></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span>,</span><br><span class="line">   <span class="built_in">rank</span>() <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> 班级</span><br><span class="line">                 <span class="keyword">order</span> <span class="keyword">by</span> 成绩 <span class="keyword">desc</span>) <span class="keyword">as</span> ranking</span><br><span class="line"><span class="keyword">from</span> 班级表</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262009309.png" alt="image-20240905222107861"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262007776.png" alt="image-20240905222135175"></p>
<p><strong>简单来说，窗口函数有以下功能：</strong></p>
<p>1）同时具有分组和排序的功能</p>
<p>2）不减少原表的行数</p>
<p>3）语法如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">&lt;</span>窗口函数<span class="operator">&gt;</span> <span class="keyword">over</span> (<span class="keyword">partition</span> <span class="keyword">by</span> <span class="operator">&lt;</span>用于分组的列名<span class="operator">&gt;</span></span><br><span class="line">                <span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>用于排序的列名<span class="operator">&gt;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262007609.png" alt="image-20240905222441114"></p>
<h5 id="聚合函数作为窗口函数"><a href="#聚合函数作为窗口函数" class="headerlink" title="聚合函数作为窗口函数"></a>聚合函数作为窗口函数</h5><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262007320.png" alt="image-20240905222532998"></p>
<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>MySQL5.5版本之前使用的默认存储引擎是MyISAM，后续使用的是InnoDB，他们直接的区别就是：</p>
<ul>
<li>MyISAM不支持行级锁，该存储引擎一锁就锁住了整个表；</li>
<li>且不支持事务；</li>
<li>且不支持外键，尽管外键对于维护数据库中的一致性有非常好的作用，但是其性能的损耗太大，所以一般在实际的开发环境中是不建议使用外键的；</li>
<li>且不支持数据库崩溃后安全恢复，InnoDB是支持的，这都是基于redo log而完成的；</li>
<li>不支持MVCC（多版本并发控制）；</li>
<li>索引实现不一样，尽管他们两个都使用B+Tree作为其索引结构，</li>
</ul>
<p>存储引擎是插件式的，它可以为一个数据库中的不同的表指定不同的存储引擎，即存储引擎是基于表的</p>
<h3 id="一条SQL请求的执行顺序是什么？"><a href="#一条SQL请求的执行顺序是什么？" class="headerlink" title="一条SQL请求的执行顺序是什么？"></a>一条SQL请求的执行顺序是什么？</h3><p>前面了解了一个SQL查询语句的执行顺序，那么这里一个SQ请求的执行顺序是什么样的呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503121453148.png" alt="image-20250312145326067"></p>
<h3 id="InnoDB于MyISAM存储引擎有哪些区别"><a href="#InnoDB于MyISAM存储引擎有哪些区别" class="headerlink" title="InnoDB于MyISAM存储引擎有哪些区别"></a>InnoDB于MyISAM存储引擎有哪些区别</h3><ul>
<li>事务：InnoDB 支持事务，MyISAM 不支持事务，这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一。 </li>
<li>索引结构：InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚簇索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>锁粒度：InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。 </li>
<li>count 的效率：InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="请你介绍一下什么是索引"><a href="#请你介绍一下什么是索引" class="headerlink" title="请你介绍一下什么是索引"></a>请你介绍一下什么是索引</h3><p>索引类似于书籍的目录，可以减少扫描的数据量，提高查询效率。 </p>
<ul>
<li>如果查询的时候，没有用到索引就会全表扫描，这时候查询的时间复杂度是On</li>
<li>如果用到了索引，那么查询的时候，可以基于二分查找算法，通过索引快速定位到目标数据， mysql 索引的数据结构一般是 b+树，其搜索复杂度为O(logdN)，其中 d 表示节点允许的最大子节点个数为 d 个。</li>
</ul>
<h3 id="请你介绍一下索引的分类"><a href="#请你介绍一下索引的分类" class="headerlink" title="请你介绍一下索引的分类"></a>请你介绍一下索引的分类</h3><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503121514919.png" alt="image-20250312151403870"></p>
<h3 id="请你介绍一下为什么选择B-Tree作为其索引数据结构呢"><a href="#请你介绍一下为什么选择B-Tree作为其索引数据结构呢" class="headerlink" title="请你介绍一下为什么选择B+Tree作为其索引数据结构呢"></a>请你介绍一下为什么选择B+Tree作为其索引数据结构呢</h3><p>首先针对于B+树的特性来进行介绍，B+树相对于B树，其非叶子结点不存储数据，那么该非叶子节点就有大量的空间保存其下行节点（键值对），即可以降低树的高度且减少硬盘的读取次数。</p>
<p>且叶子节点之间有指针互相连接，那么其天然的支持范围查询，其范围查询的效率会高很多。</p>
<p>B+树节点大小通常设置为磁盘块大小（如16KB），最大化单次I&#x2F;O读取的数据量。</p>
<h3 id="B-树是如何构建的"><a href="#B-树是如何构建的" class="headerlink" title="B+树是如何构建的"></a>B+树是如何构建的</h3><blockquote>
<h3 id="B-树插入与删除操作详解（以阶数m-3为例）"><a href="#B-树插入与删除操作详解（以阶数m-3为例）" class="headerlink" title="B+树插入与删除操作详解（以阶数m&#x3D;3为例）"></a>B+树插入与删除操作详解（以阶数m&#x3D;3为例）</h3><hr>
<h4 id="1-初始B-树结构"><a href="#1-初始B-树结构" class="headerlink" title="1. 初始B+树结构"></a><strong>1. 初始B+树结构</strong></h4><p>假设阶数m&#x3D;3（每个节点最多存储3个键，超过则分裂），初始树为空。<br><strong>插入顺序</strong>：依次插入键值 <code>5, 10, 15, 20, 25, 30, 35, 40</code>，观察分裂过程。</p>
<hr>
<h4 id="2-插入操作与节点分裂"><a href="#2-插入操作与节点分裂" class="headerlink" title="2. 插入操作与节点分裂"></a><strong>2. 插入操作与节点分裂</strong></h4><h5 id="2-1-插入5、10、15"><a href="#2-1-插入5、10、15" class="headerlink" title="2.1 插入5、10、15"></a><strong>2.1 插入5、10、15</strong></h5><p>• <strong>操作</strong>：依次插入 <code>5 → 10 → 15</code>。<br>• <strong>结果</strong>：单个叶子节点存储全部键值（未超过容量）。<br>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[叶子节点]</span><br><span class="line">┌────┬────┬────┐</span><br><span class="line">│ 5  │ 10 │ 15 │</span><br><span class="line">└────┴────┴────┘</span><br></pre></td></tr></table></figure></p>
<h5 id="2-2-插入20（触发分裂）"><a href="#2-2-插入20（触发分裂）" class="headerlink" title="2.2 插入20（触发分裂）"></a><strong>2.2 插入20（触发分裂）</strong></h5><p>• <strong>插入20</strong>：叶子节点键数超过3（4个键），需分裂。<br>• <strong>分裂规则</strong>：</p>
<ol>
<li>将中间键（第2个键，<code>15</code>）提升到父节点（此时父节点不存在，创建根节点）。</li>
<li>左子节点保留 <code>5, 10</code>，右子节点保留 <code>15, 20</code>。<br>• <strong>结构变化</strong>：</li>
</ol>
  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">          [根节点（非叶子）]</span><br><span class="line">                │</span><br><span class="line">                ▼</span><br><span class="line">          ┌───────┐</span><br><span class="line">          │  15   │</span><br><span class="line">          └───┬───┘</span><br><span class="line">              ├───────────┐</span><br><span class="line">              ▼           ▼</span><br><span class="line">[叶子节点1]          [叶子节点2]</span><br><span class="line">┌────┬────┐      ┌────┬────┐</span><br><span class="line">│ 5  │ 10 │      │ 15 │ 20 │</span><br><span class="line">└────┴────┘      └────┴────┘</span><br></pre></td></tr></table></figure>

<h5 id="2-3-插入25、30"><a href="#2-3-插入25、30" class="headerlink" title="2.3 插入25、30"></a><strong>2.3 插入25、30</strong></h5><p>• <strong>插入25 → 30</strong>：插入到叶子节点2，当前键数为 <code>15, 20, 25, 30</code>，触发分裂。<br>• <strong>分裂规则</strong>：</p>
<ol>
<li>中间键 <code>25</code> 提升到父节点。</li>
<li>左子节点保留 <code>15, 20</code>，右子节点保留 <code>25, 30</code>。<br>• <strong>结构变化</strong>：</li>
</ol>
  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          [根节点（非叶子）]</span><br><span class="line">          ┌───────┬───────┐</span><br><span class="line">          │  15   │  25   │</span><br><span class="line">          └───┬───┴───┬───┘</span><br><span class="line">              ▼       ▼       ▼</span><br><span class="line">[叶子1]   [叶子2]   [叶子3]</span><br><span class="line">┌──┬──┐  ┌──┬──┐  ┌──┬──┐</span><br><span class="line">│5 │10│  │15│20│  │25│30│</span><br><span class="line">└──┴──┘  └──┴──┘  └──┴──┘</span><br></pre></td></tr></table></figure>

<h5 id="2-4-插入35、40"><a href="#2-4-插入35、40" class="headerlink" title="2.4 插入35、40"></a><strong>2.4 插入35、40</strong></h5><p>• <strong>插入35 → 40</strong>：插入到叶子节点3，键数为 <code>25, 30, 35, 40</code>，触发分裂。<br>• <strong>分裂规则</strong>：</p>
<ol>
<li>中间键 <code>35</code> 提升到父节点。</li>
<li>左子节点保留 <code>25, 30</code>，右子节点保留 <code>35, 40</code>。<br>• <strong>结构变化</strong>：</li>
</ol>
  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          [根节点（非叶子）]</span><br><span class="line">      ┌───────┬───────┬───────┐</span><br><span class="line">      │  15   │  25   │  35   │</span><br><span class="line">      └───┬───┴───┬───┴───┬───┘</span><br><span class="line">          ▼       ▼       ▼       ▼</span><br><span class="line">[叶子1] [叶子2] [叶子3] [叶子4]</span><br><span class="line">┌──┬──┐┌──┬──┐┌──┬──┐┌──┬──┐</span><br><span class="line">│5│10││15│20││25│30││35│40│</span><br><span class="line">└──┴──┘└──┴──┘└──┴──┘└──┴──┘</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="3-删除操作与节点合并-重新分配"><a href="#3-删除操作与节点合并-重新分配" class="headerlink" title="3. 删除操作与节点合并&#x2F;重新分配"></a><strong>3. 删除操作与节点合并&#x2F;重新分配</strong></h4><h5 id="3-1-删除15（直接删除）"><a href="#3-1-删除15（直接删除）" class="headerlink" title="3.1 删除15（直接删除）"></a><strong>3.1 删除15（直接删除）</strong></h5><p>• <strong>操作</strong>：删除叶子节点2中的键 <code>15</code>，剩余键为 <code>20</code>（未低于最小值 ⌈m&#x2F;2⌉-1&#x3D;1）。<br>• <strong>结果</strong>：无需合并，直接删除。<br>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[叶子2]</span><br><span class="line">┌────┐</span><br><span class="line">│ 20 │</span><br><span class="line">└────┘</span><br></pre></td></tr></table></figure></p>
<h5 id="3-2-删除25（触发重新分配）"><a href="#3-2-删除25（触发重新分配）" class="headerlink" title="3.2 删除25（触发重新分配）"></a><strong>3.2 删除25（触发重新分配）</strong></h5><p>• <strong>操作</strong>：删除叶子节点3中的键 <code>25</code>，剩余键为 <code>30</code>（不足1个键）。<br>• <strong>重新分配规则</strong>：  </p>
<ol>
<li>向兄弟节点（叶子4）借一个键 <code>35</code>，并更新父节点键为 <code>35</code> → <code>30</code>。  </li>
<li>叶子3和叶子4合并为 <code>30, 35, 40</code>（需调整父节点）。<br>• <strong>结构变化</strong>：</li>
</ol>
  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">          [根节点（非叶子）]</span><br><span class="line">      ┌───────┬───────┐</span><br><span class="line">      │  15   │  30   │</span><br><span class="line">      └───┬───┴───┬───┘</span><br><span class="line">          ▼       ▼       ▼</span><br><span class="line">[叶子1] [叶子2] [叶子3-4合并]</span><br><span class="line">┌──┬──┐┌──┐┌──┬──┬──┐</span><br><span class="line">│5│10││20││30│35│40│</span><br><span class="line">└──┴──┘└──┘└──┴──┴──┘</span><br></pre></td></tr></table></figure>

<h5 id="3-3-删除5（触发合并）"><a href="#3-3-删除5（触发合并）" class="headerlink" title="3.3 删除5（触发合并）"></a><strong>3.3 删除5（触发合并）</strong></h5><p>• <strong>操作</strong>：删除叶子1中的键 <code>5</code>，剩余键为 <code>10</code>（仍满足最小值）。<br>• <strong>无需操作</strong>，直接删除：<br>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[叶子1]</span><br><span class="line">┌────┐</span><br><span class="line">│ 10 │</span><br><span class="line">└────┘</span><br></pre></td></tr></table></figure></p>
<h5 id="3-4-删除10（触发节点合并）"><a href="#3-4-删除10（触发节点合并）" class="headerlink" title="3.4 删除10（触发节点合并）"></a><strong>3.4 删除10（触发节点合并）</strong></h5><p>• <strong>操作</strong>：删除叶子1中的键 <code>10</code>，此时叶子1为空。<br>• <strong>合并规则</strong>：</p>
<ol>
<li>将相邻叶子节点（叶子2）的键 <code>20</code> 移动到父节点。  </li>
<li>合并叶子1和叶子2，删除父节点中的键 <code>15</code>。<br>• <strong>最终结构</strong>：</li>
</ol>
  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    [根节点（非叶子）]</span><br><span class="line">          │</span><br><span class="line">          ▼</span><br><span class="line">    ┌───────┐</span><br><span class="line">    │  30   │</span><br><span class="line">    └───┬───┘</span><br><span class="line">        ▼</span><br><span class="line">[合并后的叶子节点]</span><br><span class="line">┌──┬──┬──┬──┐</span><br><span class="line">│20│30│35│40│</span><br><span class="line">└──┴──┴──┴──┘</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="4-关键机制总结"><a href="#4-关键机制总结" class="headerlink" title="4. 关键机制总结"></a><strong>4. 关键机制总结</strong></h4><table>
<thead>
<tr>
<th><strong>操作</strong></th>
<th><strong>触发条件</strong></th>
<th><strong>处理方式</strong></th>
</tr>
</thead>
<tbody><tr>
<td>插入</td>
<td>节点键数 &gt; m-1</td>
<td>分裂为两个节点，中间键提升到父节点</td>
</tr>
<tr>
<td>删除</td>
<td>节点键数 &lt; ⌈m&#x2F;2⌉-1</td>
<td>若兄弟节点可借键，则重新分配；否则合并节点</td>
</tr>
<tr>
<td>重新分配</td>
<td>兄弟节点有富余键（≥⌈m&#x2F;2⌉）</td>
<td>借一个键并更新父节点</td>
</tr>
<tr>
<td>合并</td>
<td>兄弟节点无富余键</td>
<td>合并两个节点，父节点删除对应键</td>
</tr>
</tbody></table>
<hr>
<h4 id="5-B-树操作对性能的影响"><a href="#5-B-树操作对性能的影响" class="headerlink" title="5. B+树操作对性能的影响"></a><strong>5. B+树操作对性能的影响</strong></h4><p>• <strong>插入分裂</strong>：<br>  可能导致父节点递归分裂，最坏情况树高增加，但概率极低（阶数通常较大）。<br>• <strong>删除合并</strong>：<br>  频繁合并可能增加碎片，但InnoDB通过填充因子（<code>innodb_fill_factor</code>）预留空间减少合并。<br>• <strong>平衡性</strong>：<br>  所有操作保证树高平衡，查询效率稳定在 ( O(\log_m n) )。</p>
<hr>
<p>通过以上示例，可以清晰理解B+树如何通过分裂和合并保持平衡，从而高效支持数据库的增删查改操作。</p>
</blockquote>
<hr>
<h2 id="MySQL进阶"><a href="#MySQL进阶" class="headerlink" title="MySQL进阶"></a>MySQL进阶</h2><h3 id="MySQL架构"><a href="#MySQL架构" class="headerlink" title="MySQL架构"></a>MySQL架构</h3><p>参考资料：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/QevKTIIadpguyWxm7od6SQ">美团二面拷打：MySQL中 SELECT 语句执行流程？</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262007401.png" alt="image-20241008114828024"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262009368.png" alt="image-20241008114849197"></p>
<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在2024年9月24日面试中，面试官对MySQL事务进行了提问，但是我忘记了。为什么会忘记呢？首先对于MySQL事务的理解并不深，仅仅知识停留在了了解的层面上，对于其内在存在的逻辑，丝毫不明。所以就会出现今天看完好似懂了，但是明天再问就全都回答不上来了。所以接下来我要对这部分内容到达理解的地步。</p>
<h5 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h5><p>首先我们需要明白什么是事务？事务是一种概念，它可以存在MySQL中，也可以存在后端代码中，甚至是Redis中。事务就是一组操作，这组操作是严密相关的。一句话它们同生死，要么都成功要么都失败。</p>
<h5 id="为什么需要事务"><a href="#为什么需要事务" class="headerlink" title="为什么需要事务"></a>为什么需要事务</h5><p>我们都知道事务是一组操作的状态一致，那么这种状态一致是为了解决存在的什么问题呢？</p>
<p>举个栗子，转账是最经典的事务问题。A给B转账，A账户需要扣钱，B账户需要加钱，这就是一组操作，如果其中一个成功了就会导致数据库中的数据不一致！这就会出现很大的问题。</p>
<p>这就是事务存在的意义。</p>
<h5 id="事务有什么特点呢"><a href="#事务有什么特点呢" class="headerlink" title="事务有什么特点呢"></a>事务有什么特点呢</h5><p>通过事务的概念来看，要么都成功、要么都失败。很显然这组操作是不可分割的，我们称为<strong>原子性</strong>。</p>
<p>很好，这只是单线程的情况下，现在我们前往多线程。我们都知道事务是不可分割的，要么都成功要么都失败，那么在多线程情况下，线程A访问数据data，线程B也访问数据，他们的访问顺序不定，这就是高并发环境下的不确定。</p>
<p>我们也举个栗子，A读取了数据100，然后减去了50，但是A还没有保存到数据库中，线程B就开始执行。它也去读取了这个数据，因为A还没有提交，所以B读取的数据还是100.如果这时候B继续执行，并对这个数据进行操作和保存，那么如果A最终失败回滚，但是这数据已经错误，因为B已经基于错误的数据做了决策。这就是事务里面最困难的一点<strong>隔离性</strong>。</p>
<p>我们上面降到，如果事务中某一个出错了，需要回滚，那么它是怎么回滚的呢？那肯定就是读取之前保存的数据来覆盖就行了呀。所以这就需要一个特点<strong>持久性</strong>。</p>
<p>上面所有的操作都是为了保证最后一个特点，那么就是数据<strong>一致性</strong>。我们所有做的一切都是为了保证MySQL中的数据一致，不会出现错误。</p>
<p>我们通过分析得到了事务的四个特点，我们需要特别注意事务的隔离性。在接下来的面试中还是具体开发中，事务这一个概念涉及到最多的就是<strong>隔离性</strong>。</p>
<h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5><p>在上面我们简单的介绍了一下事务的特点中的隔离性，但是这远远不够。我们假设现在是高并发的情况下，多个线程事务之间访问相同的数据，并对这个数据做读写操作，请问这会造成什么问题？</p>
<p>从上面简单的来看，很显然一个明显的特点就是，读取到了其它事务还没有提交的数据，就是这个数据被别的事务读取了甚至操作了，但是目前还不知道这个事务是否可以全部执行成功，。那么如果现在你去读取这个数据，那么就是读取到了可能会存在问题的数据，这就叫读取到了未提交的数据！这个也被称为<strong>脏读</strong>！</p>
<p>那么请问我该如何避免脏读呢？</p>
<p>解决办法，MySQL已经给出了。MySQL针对每一张表都可以设置这张表的隔离等级，不同的隔离等级可以解决不同程度下高并发带来的隔离性问题。</p>
<p>MySQL有四个隔离等级，分别是：读取未提交、读取已提交、可重复读和可串行化。这四个隔离等级是逐步升高。可能现在还记不住它，那么下面我们将逐步去介绍这些概念。</p>
<p>前面不是说到了脏读吗？脏读造成的主要原因不就是线程读取到了未提交的数据吗，所以我们只需要将事务等级改成读取已提交就可以避免线程去读取未提交的数据。</p>
<p>那这样的话，还需要下面可重复读和可串行两个事务等级做什么用呢？！很显然，在具体的开发中，读取已提交的数据还是会出现问题，但是会出现什么问题呢？</p>
<p>我实在无法真正理解不可重复读和幻读在实际场景中出现的问题，如果后续有理解了会更新。</p>
<p>按照概念来讲，<strong>不可重复读</strong>是高并发情况下会出现的问题。就是一个事务两个查询同一个数据不一致，这就叫做不可重复读。为什么叫不可重复读呢？因为两次读的不一样嘛，所以不让你重复读嘛。</p>
<p>那么什么是<strong>幻读</strong>呢？幻读其实也是一个事务中两次读取的数据不一致，但是跟不可重复读不一样的在于幻读变化的主要在新增情况下的变化，不可重复读主要在数据更改上。</p>
<p>将事务等级提高在可重复读就可以解决不可重复读问题，把事务等级提高到可串行化可以解决幻读问题，但是这样并发效果会降低。</p>
<p>那么为什么需要区别不可重复读和幻读之间的区别呢？这是因为MySQL事务在处理它们的方案不一样。</p>
<p>解决不可重复读就是直接对记录加锁，但是新增的话这样就锁不住了，这就造成了幻读咯。那么怎么解决新增加锁问题呢，方案是对ID加锁，叫做Next-Key Lock(Recoed Lock + Gap Lock)。具体是如何实现不太了解。</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>事务简单的来说是数据库中的一组操作，这组操作具有一定的特殊性，所以技术人员将具有这组特殊性的操作称为事务。那么这特殊性特殊在哪里呢？即这组操作要么全部成功要么都失败，即这组操作是极度耦合。</p>
<p>一旦这组操作中的某个操作失败了，数据库就会回滚到这组操作之前的状态，即不会保留这组操作中某些正常执行的结果。</p>
<p>MySQL InnoDB 存储引擎的默认⽀持的隔离级别是 REPEATABLE-READ（可重读）</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>通过上面对事务概念的介绍，相信也能猜到事务的一些特点。</p>
<h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>首先就是原子性啦，这组操作要么都成功，要么都失败，即这组操作是不可分割的，那么我们借用原子这个名词来描述这一特性，就称为原子性；</p>
<h5 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h5><p>拿转账的例子来解释，A给B转了钱，那么A的账户就必须扣钱，B的账户必须加钱，这个状态必须一致；从这里可以看到原子性是一致性的前提，一致性是原子性的保障；</p>
<h5 id="隔离性-1"><a href="#隔离性-1" class="headerlink" title="隔离性"></a>隔离性</h5><p>隔离性是指在并发的环境下，不同的事务之间进行隔离，从而避免各种并发问题。</p>
<p>1. </p>
<h6 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h6><p>在这种级别下，一个事务可以读取其它事务未提交的数据，这种级别的事务等级会造成<strong>脏读</strong>。这个级别的并发性最高，但数据一致性最差。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>事务A开始，读取账户1的余额为100元。</li>
<li>事务B开始，修改账户1的余额为200元，但未提交。</li>
<li>事务A再次读取账户1的余额，会看到200元，即使事务B还没有提交。这就是<strong>脏读</strong>。</li>
</ul>
<h6 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h6><p>在这种隔离级别下，一个事务只能读取到其他事务已经提交的数据。这解决了脏读的问题，但可能会产生不可重复读的问题。</p>
<p><strong>可能造成的问题：</strong></p>
<ul>
<li><p><strong>性能影响：</strong> 由于隔离级别非常严格，事务之间几乎不允许并发执行，这可能导致系统性能降低。</p>
</li>
<li><p><strong>例子：</strong></p>
<ol>
<li>事务A读取某个数据项的值为100。</li>
<li>事务B修改该数据项的值并提交，新的值为200。</li>
<li>事务A再次读取该数据项时，得到的是200，而不是最初读取的100。</li>
</ol>
<p><strong>示例：</strong> 假设事务A查询一个商品的库存量，得到的是50。此时事务B修改并提交库存量为30。当事务A再次查询库存量时，得到的是30，而不是最初读取的50，这就是不可重复读问题。</p>
</li>
</ul>
<h6 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h6><p>这<strong>是MySQL默认的隔离级别</strong>。在这种隔离级别下，一个事务在开始后，其读取的数据不会被其他事务的更新所影响，直到该事务结束。 <strong>保证一个事务在其生命周期内多次读取到的数据是一致的</strong>，<strong>但仍可能会有幻读问题</strong>。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>事务A开始，读取账户1的余额为100元。</li>
<li>事务B开始，修改账户1的余额为200元，然后提交。</li>
<li>事务A再次读取账户1的余额，仍然会看到100元，因为它在事务开始时创建了一个数据的快照，即使其他事务提交了更新。</li>
</ul>
<h6 id="串行化"><a href="#串行化" class="headerlink" title="串行化"></a>串行化</h6><p>这是最高的隔离级别，它通过锁定涉及的数据行来避免并发问题，实际上是将事务串行执行。</p>
<p><strong>例子</strong>：</p>
<ul>
<li>事务A开始，读取账户1的余额为100元，并锁定该行。</li>
<li>事务B尝试读取或修改账户1的余额，会被阻塞，直到事务A结束并释放锁。</li>
<li>事务A结束，事务B才能继续执行。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262007817.png" alt="image-20240909110054353"></p>
<h5 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h5><p>⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据 库发⽣故障也不应该对其有任何影响。</p>
<p>只有保证了事务的持久性、原⼦性、隔离性之后，⼀致性才能得到保障。 也就是说 A、I、D 是⼿段，C 是⽬的！</p>
<h4 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h4><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262007138.png" alt="image-20240909103442559"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262007592.png" alt="image-20240909104643321"></p>
<h5 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h5><p>出现幻读的原因是事务读取到了未提交的数据，依据这个原因，我们就得出了我们第一种方案。</p>
<p>方案一：设置数据库事务隔离级别为read committed，即只能读取已提交的数据；</p>
<h5 id="不可重复读-Non-Repeatable-read"><a href="#不可重复读-Non-Repeatable-read" class="headerlink" title="不可重复读(Non-Repeatable read)"></a>不可重复读(Non-Repeatable read)</h5><p>不可重复读简单的来说就是一个事务多次读取同一数据，发现该数据前后不一致而出现的问题。</p>
<p>把数据库事务隔离级别设置为可重复读Repeatable read。</p>
<h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><p>幻读：同意事务前后读取数据的总量不一致。</p>
<p>我们把数据库事务隔离级别设置成最高级：串行化来解决这个问题：serializable 。</p>
<p>但是这样就会导致数据库就变成了单线程访问的数据库，导致性能降低很多。</p>
<p>Isolation 属性一共支持五种事务设置，具体介绍如下：</p>
<p>DEFAULT： 使用数据库设置的隔离级别 ( 默认 ) ，由 DBA 默认的设置来决定隔离级别 .</p>
<p>READ_UNCOMMITTED： 会读到未提交的数据， 出现脏读、不可重复读、幻读 ( 隔离级别最低，并发性能高 )。</p>
<p>READ_COMMITTED： 不会读到未提交的数据，会出现不可重复读、幻读问题（锁定正在读取的行）</p>
<p>REPEATABLE_READ ：会出幻读（锁定所读取的所有行）</p>
<p>SERIALIZABLE ：保证所有的情况不会发生（锁表）。</p>
<h4 id="MySQL-的隔离级别是基于锁实现的吗"><a href="#MySQL-的隔离级别是基于锁实现的吗" class="headerlink" title="MySQL 的隔离级别是基于锁实现的吗"></a>MySQL 的隔离级别是基于锁实现的吗</h4><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262007610.png" alt="image-20240909110559001"></p>
<p><strong>MVCC</strong></p>
<blockquote>
<p>MVCC（Multi-Version Concurrency Control，多版本并发控制）是一种数据库的并发控制机制，允许多个事务并发执行，同时避免了锁机制带来的性能瓶颈和死锁问题。通过维护数据的多个版本，MVCC 可以使读操作不阻塞写操作，写操作也不阻塞读操作，从而提高并发性能。</p>
</blockquote>
<blockquote>
<h3 id="MVCC-的核心思想："><a href="#MVCC-的核心思想：" class="headerlink" title="MVCC 的核心思想："></a>MVCC 的核心思想：</h3><p>MVCC 机制在数据库中维护了每一行数据的多个版本，通常每行数据都会存储以下几个额外的信息：</p>
<ol>
<li><strong>版本号</strong>或<strong>事务ID</strong>：每次数据修改（INSERT、UPDATE、DELETE）时，数据库都会分配一个事务ID，作为该版本的标识。</li>
<li><strong>删除标记</strong>：标识该数据行是否被删除。</li>
<li><strong>开始版本号和结束版本号</strong>：记录该数据行何时被创建和何时失效（在被更新或删除时）。</li>
</ol>
<p>当一个事务查询数据时，它只会看到在当前事务开始时可见的版本，这样就保证了事务之间的隔离性。</p>
</blockquote>
<h4 id="MySQL锁"><a href="#MySQL锁" class="headerlink" title="MySQL锁"></a>MySQL锁</h4><p>在MySQL5.5版本之前默认使用存储引擎是MyISAM，之后MySQL默认的存储引擎是InnoDB。</p>
<p>MyISAM仅仅支持表级锁，顾名思义就是一锁就锁住整个表，很显然这样会导致并发性能很差，这也就是为什么在5.5版本之后舍弃该存储引擎换成InnoDB。</p>
<p>InnoDB支持行级锁，显然也支持表级锁，默认使用行级锁。⾏ 级锁的粒度更⼩，仅对相关的记录上锁即可（对⼀⾏或者多⾏记录加锁），所以对于并发写⼊操作来 说， InnoDB 的性能更⾼。</p>
<p><strong>行级锁</strong>：</p>
<ul>
<li>优点: 并发度高；</li>
<li>缺点：加锁开销大，可能会出现死锁；</li>
</ul>
<p>行级锁是基于表的索引进行加锁的，所以如果对于那些SQL没有命中索引或者索引失效的情况，就会锁住整个表</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262007121.png" alt="image-20240909193523534"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262007856.png" alt="image-20240909195036859"></p>
<h4 id="MySQL数据库的事务实现原理"><a href="#MySQL数据库的事务实现原理" class="headerlink" title="MySQL数据库的事务实现原理"></a>MySQL数据库的事务实现原理</h4><p>以MySQL 的InnoDB （InnoDB 是 MySQL 的⼀个存储引擎）为例，介绍⼀ 下单⼀数据库的事务实现原理。 InnoDB 是通过 ⽇志和锁 来保证的事务的 ACID特性，具体如下： </p>
<ul>
<li>（1）通过数据库锁的机制，保障事务的隔离性； </li>
<li>（2）通过 Redo Log（重做⽇志）来，保障事务的持久性； </li>
<li>（3）通过 Undo Log （撤销⽇志）来，保障事务的原⼦性； </li>
<li>（4）通过 Undo Log （撤销⽇志）来，保障事务的⼀致性；</li>
</ul>
<p><strong>Undo Log 如何保障事务的原⼦性呢？</strong> 具体的⽅式为：在操作任何数据之前，⾸先将数据备份到⼀个地⽅（这个 存储数据备份的地⽅称为 Undo Log），然后进⾏数据的修改。如果出现了 错误或者⽤户执⾏了 Rollback 语句，系统可以利⽤ Undo Log 中的备份将 数据恢复到事务开始之前的状态。 </p>
<p><strong>Redo Log如何保障事务的持久性呢？</strong> 具体的⽅式为：Redo Log 记录的是新数据的备份（和 Undo Log 相反）。 在事务提交前，只要将 Redo Log 持久化即可，不需要将数据持久化。当 系统崩溃时，虽然数据没有持久化，但是 Redo Log 已经持久化。系统可 以根据 Redo Log 的内容，将所有数据恢复到崩溃之前的状态。</p>
<p><strong>redo log（重做日志）</strong>：用于记录事务操作的日志，确保即使在数据库崩溃时，通过重做日志也能恢复数据。</p>
<p><strong>undo log（回滚日志）</strong>：用于记录撤销操作，以支持事务的回滚。undo log帮助在事务失败或显式回滚时，撤销已执行的操作，保持数据的一致性。</p>
<p><strong>锁机制</strong>：InnoDB实现了两种类型的锁机制：<strong>行级锁</strong>和<strong>表级锁</strong>。行级锁保证了高并发性能，而表级锁适用于大批量操作。</p>
<p><strong>MVCC（多版本并发控制）</strong>：InnoDB通过MVCC实现行级并发控制。它的关键机制是通过保存数据的多个版本来允许多个事务同时执行，避免锁定冲突，特别是在较低的隔离级别（如READ COMMITTED、REPEATABLE READ）下。</p>
<p>怎么说呢？MySQL事务的保证是基于MVCC来实现的，其中MVCC为多版本并发控制，其是如何具体来实现这个事务的呢？这就涉及到undo log和redo log两个非常重要的日志，通过这个日志和锁来保证其事务。</p>
<p>就那MySQL默认的可重复读这个默认的事务等级来说，在一个线程来修改这个数据时，其会将其老数据生成一个快照保存到undo log中，一方面为了其它线程可以读取老数据，这样就能够保证高并发。同时也是为了如果这个事务执行失败了，可以通过undo log来进行回滚。在事务执行成功后，其会采用两阶段提交提交的方式来持久化，首先会把这个事务结果写入redo log，然后再提交这个事务，这样这个数据才是真正的被写入了数据库中。通过上面的描述相信对MySQL中的事务有了更深层次的了解。</p>
<h3 id="索引-1"><a href="#索引-1" class="headerlink" title="索引"></a>索引</h3><p>2024年9月24日，面试，问了索引失效，很幸运，之前看了，很不幸，忘记了，无语ing。</p>
<p>主要原因还是没有真正的去理解索引这一个概念，所以今天晚上也就今天问的几个概念去真正的去理解一下。</p>
<p>要理解索引，首先就得知道什么是索引吧，那么什么是索引呢？</p>
<h4 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h4><p>索引就是一种数据结构，我们可以看成一本书的目录，这个目录记录着这个数据库中你创建索引下标的值，并且查询很快。</p>
<p>官方介绍索引是帮助MySQL<strong>高效获取数据</strong>的<strong>数据结构</strong>。更通俗的说，数据库索引好比是一本书前面的目录，能<strong>加快数据库的查询速度</strong>。</p>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><p>根据设定索引列上的类型进行划分，比如索引列上的值是否可以为空、是否可以重复，这样就分为：主键索引（不重复、不为空）、唯一索引（不重复、可以为空）、普通索引（无要求）、全文索引（文本类型，字段较长）、空间索引（几何数据）和前缀索引。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262009128.png" alt="image-20241014192208575"></p>
<p>MySQL 中的索引数据结构至关重要，影响查询性能。最常用的索引结构是 <strong>B+树</strong>，此外还有 <strong>哈希索引</strong>、<strong>全文索引</strong> 和 <strong>空间数据索引 (R-Tree)</strong>。</p>
<h4 id="索引的优势和劣势"><a href="#索引的优势和劣势" class="headerlink" title="索引的优势和劣势"></a>索引的优势和劣势</h4><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><p>很显然，加快数据库访问速度。</p>
<h5 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h5><p>占空间，但是如果更新索引中的数据的话，更新速度就很慢。</p>
<h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><p>参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46224056/article/details/137597431#:~:text=%E4%BB%8A%E5%A4%A9%E5%B0%B1%E8%B7%9F%E5%A4%A7%E5%AE%B6">索引失效的10种场景，你知道几个呢？（面试必刷!）</a></p>
<h5 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h5><p>最左匹配原则指的就是你在查询时的条件必须要从最左边的字段开始，否则就不会走索引。就是说如果直接查询B或者C还有其它都不会走索引。</p>
<p>不满足最左匹配原则的都会导致索引失效。</p>
<p>即在SQL语句中一定要有索引最左边的那个字段，没有也可以，Select 选用所有的索引字段也会走索引。</p>
<h5 id="使用了select"><a href="#使用了select" class="headerlink" title="使用了select *"></a>使用了select *</h5><p>使用了Select * 如果不符合最左匹配原则，显然索引也是一定会失效的。但是在一定的情况下可能会成功，就是明确查询得到的字段都是索引字段，那么这也是可以走索引查询的，查询条件就是具有索引中的字段。</p>
<h5 id="索引上有计算"><a href="#索引上有计算" class="headerlink" title="索引上有计算"></a>索引上有计算</h5><p>如果满足最左匹配原则，但是索引上有计算也会失效。这是因为索引建立的结构没有你运算之后的结果，它也就无法根据结果来直接查询到这个在哪里了。</p>
<h5 id="索引上有函数"><a href="#索引上有函数" class="headerlink" title="索引上有函数"></a>索引上有函数</h5><p>很显然，函数也是计算，索引失效</p>
<h5 id="字段类型不同"><a href="#字段类型不同" class="headerlink" title="字段类型不同"></a>字段类型不同</h5><p>如果索引中的类型是字符串类型，但是你在where中选择的类型是其它类型，就会导致索引无法适配，导致它认为你找的不是这个索引，就不会走索引了。</p>
<h5 id="like左边包含"><a href="#like左边包含" class="headerlink" title="like左边包含%"></a>like左边包含%</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> code <span class="keyword">like</span> <span class="string">&#x27;%1%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>索引就会失效，查询范围太大，无效。</p>
<p>其实很好理解，索引就像字典中的目录。一般目录是按字母或者拼音从小到大，从左到右排序，是有顺序的。</p>
<p>我们在查目录时，通常会先从左边第一个字母进行匹对，如果相同，再匹对左边第二个字母，如果再相同匹对其他的字母，以此类推。</p>
<p>通过这种方式我们能快速锁定一个具体的目录，或者缩小目录的范围。</p>
<h5 id="列对比"><a href="#列对比" class="headerlink" title="列对比"></a>列对比</h5><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262007667.png" alt="image-20240924223117186"></p>
<h5 id="使用OR关键词"><a href="#使用OR关键词" class="headerlink" title="使用OR关键词"></a>使用OR关键词</h5><p>OR中如果存在一个不在索引内的字段，都会导致索引失效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT del_flag FROM `mysql_table` WHERE NAME = &#x27;Siu Tin Wing&#x27; or  age = 1;</span><br></pre></td></tr></table></figure>

<p>这两个字段都建立了索引，但是最后却没有走索引：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262007267.png" alt="image-20241014195345355"></p>
<p>如果 <code>NAME</code> 字段的唯一性较差（即重复值较多），或者 <code>age</code> 字段有大量相同值，MySQL 优化器可能会判断索引的使用效率不高。</p>
<h5 id="not-in和not-exists"><a href="#not-in和not-exists" class="headerlink" title="not in和not exists"></a>not in和not exists</h5><p>普通索引字段走not in会失效，但是主键索引走not in依旧有效</p>
<p>同样使用not exists索引也会失效</p>
<h5 id="使用-ORDER-BY-或-GROUP-BY-时的索引失效"><a href="#使用-ORDER-BY-或-GROUP-BY-时的索引失效" class="headerlink" title="使用 ORDER BY  或 GROUP BY 时的索引失效"></a>使用 <code>ORDER BY</code>  或 GROUP BY 时的索引失效</h5><p><code>ORDER BY</code> 对索引的要求比较严格，如果 <code>ORDER BY</code> 字段不是索引的最左前缀或包含了非索引字段，索引会失效。</p>
<ul>
<li><p><strong>示例</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制代码SELECT * FROM users WHERE id = 1 ORDER BY name; -- 索引生效</span><br><span class="line">SELECT * FROM users ORDER BY name; -- 索引失效</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>原因</strong>：<code>ORDER BY</code> 字段必须与 <code>WHERE</code> 中使用的索引字段一致，MySQL才能高效使用索引，否则会进行文件排序（file sort）。</p>
</li>
<li><p><strong>解决方法</strong>：尽量保证 <code>ORDER BY</code> 中的字段与 <code>WHERE</code> 中的索引字段匹配，或者在 <code>ORDER BY</code> 字段上创建独立的索引。</p>
</li>
</ul>
<p>与 <code>ORDER BY</code> 类似，<code>GROUP BY</code> 也要求索引字段符合最左前缀匹配规则，否则会导致索引失效。</p>
<h4 id="查看是否使用了索引"><a href="#查看是否使用了索引" class="headerlink" title="查看是否使用了索引"></a>查看是否使用了索引</h4><p>24年9月25日上午面试，又问了索引，但是没有问索引失效的情况，而是问了如何查看是否使用了索引。很不幸，昨天刚刚看了对explain有点影响，但是不确定，没打出来。</p>
<p>答案就是使用EXPLAIN关键字：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> A, B, C <span class="keyword">FROM</span> <span class="keyword">table</span> <span class="keyword">WHERE</span> B<span class="operator">=</span><span class="number">1</span> <span class="keyword">AND</span> A<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>面试已经不止一次问过了，但是每一次的问题都千奇百怪，实在不能忍了。现在这里结合一个实战来看看这个索引是什么？它怎么会出现问题，以及有什么问题。</p>
<p>现在我们有一个表，字段有id，name，phone，del_flag，age，url，其中有10万条数据。</p>
<p>现在我们先不建立索引，来执行一下这条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT * FROM `mysql_table` WHERE age = 10;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262007749.png" alt="image-20241014190806851"></p>
<p>其中看到type字段显示该SQL走的是全局查找，没有走索引。<strong>数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）</strong>。</p>
<h3 id="慢SQL"><a href="#慢SQL" class="headerlink" title="慢SQL"></a>慢SQL</h3><h4 id="慢SQL定位"><a href="#慢SQL定位" class="headerlink" title="慢SQL定位"></a>慢SQL定位</h4><p>参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/laodanqiu/article/details/131423834">【MySQL高级】MySQL找出执行慢的SQL【慢查询日志使用与分析】</a></p>
<p>在众多的对数据库查询的语句中我们得先要知道我们的敌人是谁把，所以我们需要定位到哪些SQL对于我们来说是慢的。慢SQL没有绝对只有相对，我们称某些SQL执行的时间超过了我们设定的阈值时，我们就称该SQL为慢SQL。那么现在的问题就是如何定位到慢SQL呢？答案就是日志。</p>
<p>我们需要打开数据库的慢查询日志，MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阈值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。</p>
<ul>
<li>long_query_time的默认值为10，意思是运行10秒以上的语句</li>
<li>由慢查询日志来查看哪些SQL超出了我们的最大忍耐时间值，比如一条SQL执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒钟的SQL，结合之前explain进行全面分析</li>
</ul>
<h4 id="慢SQL优化"><a href="#慢SQL优化" class="headerlink" title="慢SQL优化"></a>慢SQL优化</h4><p>针对慢查询，我们可以从以下几个方面进行优化：</p>
<ul>
<li><strong>SQL语句优化：检查SQL语句是否可以通过修改查询条件、连接顺序、子查询等方式进行优化。</strong></li>
<li><strong>索引优化：确保查询中涉及的字段都已经被正确索引，并考虑使用复合索引、全文索引等高级索引特性。</strong></li>
<li><strong>表结构优化：考虑是否可以通过拆分表、合并表、修改数据类型等方式优化表结构。</strong></li>
<li>查询缓存：利用MySQL的查询缓存功能，缓存经常执行的查询结果，减少数据库访问次数。</li>
<li>硬件和配置优化：考虑增加内存、使用更快的磁盘、调整MySQL配置参数等方式提高数据库性能。</li>
</ul>
<p>一般来说问题都会集中在第一到第三条，所以我们重点对前面三条问题进行分析和解决。</p>
<h5 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h5><p>我们首先从业务侧来分析一下，业务侧书写的SQL是否存在一定的问题。</p>
<p>我们需要的是优质的SQL，如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262007842.png" alt="image-20241008105111414"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262007392.png" alt="image-20241008105134406"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262010284.png" alt="image-20241008105155886"></p>
<h4 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h4><h5 id="1-分析查询：EXPLAIN-诊断查询计划"><a href="#1-分析查询：EXPLAIN-诊断查询计划" class="headerlink" title="1. 分析查询：EXPLAIN 诊断查询计划"></a>1. <strong>分析查询：EXPLAIN 诊断查询计划</strong></h5><p>首先，使用 <code>EXPLAIN</code> 查看查询的执行计划，了解 MySQL 优化器如何执行查询：</p>
<p><strong>type: range</strong>：查询根据 <code>order_date</code> 和 <code>status</code> 扫描范围。</p>
<p><strong>key: user_id</strong>：使用了 <code>user_id</code> 的索引。</p>
<p><strong>rows: 100,000</strong>：扫描大量数据，可能需要优化。</p>
<h5 id="2-优化索引：组合索引"><a href="#2-优化索引：组合索引" class="headerlink" title="2.优化索引：组合索引"></a>2.<strong>优化索引：组合索引</strong></h5><p>当前查询中，<code>user_id</code>、<code>status</code> 和 <code>order_date</code> 是过滤条件，但这些条件使用了多个独立的索引，可能导致性能下降。我们可以为这些字段创建一个<strong>组合索引</strong>来加速查询。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制代码</span><br><span class="line">CREATE INDEX idx_user_status_date ON orders (user_id, status, order_date);</span><br></pre></td></tr></table></figure>

<p>组合索引可以让 MySQL 一次性过滤掉大部分数据，而不是分别利用多个索引。</p>
<h5 id="3-覆盖索引"><a href="#3-覆盖索引" class="headerlink" title="3.覆盖索引"></a><strong>3.覆盖索引</strong></h5><p>如果在查询中使用的所有字段都能通过索引获取，那么 MySQL 可以直接从索引中返回数据，无需访问数据行。这就是<strong>覆盖索引</strong>的概念。</p>
<h5 id="4-WHERE-条件优化"><a href="#4-WHERE-条件优化" class="headerlink" title="4.WHERE 条件优化"></a><strong>4.WHERE 条件优化</strong></h5><ul>
<li><strong>范围查询 (<code>BETWEEN</code>)</strong>：MySQL在处理<code>BETWEEN</code>或其他范围查询时，会限制索引的有效性。确保范围查询字段在索引的最后一列，避免影响其他条件的索引使用顺序。</li>
<li><strong>避免函数操作</strong>：不要对索引列使用函数或表达式，否则会导致索引失效。例如：</li>
</ul>
<h5 id="5-ORDER-BY-优化"><a href="#5-ORDER-BY-优化" class="headerlink" title="5.ORDER BY 优化"></a><strong>5.ORDER BY 优化</strong></h5><ul>
<li><strong>索引支持排序</strong>：查询中的 <code>ORDER BY total_price DESC</code> 需要确保在索引的最后一列是排序列。如果查询的 <code>WHERE</code> 条件和 <code>ORDER BY</code> 可以同时由同一个索引支持，MySQL 可以避免额外的排序操作。</li>
</ul>
<h5 id="6-LIMIT-优化"><a href="#6-LIMIT-优化" class="headerlink" title="6.LIMIT 优化"></a><strong>6.LIMIT 优化</strong></h5><p>在查询返回大数据量时，<code>LIMIT</code> 是非常有用的优化手段。假设你只需要查看前 100 条记录，可以添加 <code>LIMIT</code> 来减少 MySQL 返回的行数：</p>
<h5 id="7-减少-SELECT-的使用"><a href="#7-减少-SELECT-的使用" class="headerlink" title="7.减少 SELECT * 的使用"></a><strong>7.减少 SELECT * 的使用</strong></h5><p>避免使用 <code>SELECT *</code>，只选择查询需要的字段。这不仅减少了网络传输量，也使得 MySQL 可以更快处理查询。在此案例中，我们仅查询 <code>order_id</code>、<code>user_id</code>、<code>total_price</code> 和 <code>order_date</code>，而不是返回所有列。</p>
<h3 id="MySQL执行顺序"><a href="#MySQL执行顺序" class="headerlink" title="MySQL执行顺序"></a>MySQL执行顺序</h3><ol>
<li><strong>FROM</strong>：首先确定要查询的表或视图，并从这些表中读取数据。如果有 <code>JOIN</code>，这个阶段也会处理表连接。</li>
<li><strong>ON</strong>：如果存在连接条件，在 <code>JOIN</code> 的过程中，先基于 <code>ON</code> 条件进行表之间的连接操作。</li>
<li><strong>JOIN</strong>：根据表的连接类型（如 INNER JOIN、LEFT JOIN）进行数据的连接。</li>
<li><strong>WHERE</strong>：对已经连接的数据进行过滤，只保留满足 <code>WHERE</code> 条件的记录。</li>
<li><strong>GROUP BY</strong>：对 <code>WHERE</code> 过滤后的数据进行分组。</li>
<li><strong>HAVING</strong>：对分组后的结果进行过滤，类似于 <code>WHERE</code>，但它作用于分组后的结果。</li>
<li><strong>SELECT</strong>：确定要返回的列和计算的表达式。执行时此步骤也会对列进行投影。</li>
<li><strong>DISTINCT</strong>：在 <code>SELECT</code> 的基础上进行去重操作。</li>
<li><strong>ORDER BY</strong>：对最终的结果集进行排序。</li>
<li><strong>LIMIT &#x2F; OFFSET</strong>：限制返回的行数或从特定行开始返回数据。</li>
</ol>
<h3 id="为什么说MySQL行数超过了2000W行后效率就不好了呢"><a href="#为什么说MySQL行数超过了2000W行后效率就不好了呢" class="headerlink" title="为什么说MySQL行数超过了2000W行后效率就不好了呢"></a>为什么说MySQL行数超过了2000W行后效率就不好了呢</h3><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502262008409.png" alt="image-20241014211833033"></p>
<h2 id="MySQL面试题"><a href="#MySQL面试题" class="headerlink" title="MySQL面试题"></a>MySQL面试题</h2><h3 id="第一次面试"><a href="#第一次面试" class="headerlink" title="第一次面试"></a>第一次面试</h3><h4 id="资料来源"><a href="#资料来源" class="headerlink" title="资料来源"></a>资料来源</h4><ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/twotwo22222/article/details/129115194?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522DCFAC641-E438-4EE3-ACC8-12BE1118731A%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=DCFAC641-E438-4EE3-ACC8-12BE1118731A&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129115194-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=MySQL%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187">MySQL常见面试题(2024年最新)</a></li>
</ul>
<h4 id="Promote"><a href="#Promote" class="headerlink" title="Promote"></a>Promote</h4><blockquote>
<p>现在假设你是一个经验丰富的Java后端面试官，现在请问我对于下面的这个回答正确吗？请你特别注意题目是什么？因为我回答的可能完全不对！请你为我打分（10分制），并且给出这个面试题的正确补充。</p>
</blockquote>
<h4 id="1-char和varchar的区别"><a href="#1-char和varchar的区别" class="headerlink" title="1.char和varchar的区别"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/twotwo22222/article/details/129115194?ops_request_misc=%7B%22request_id%22:%22DCFAC641-E438-4EE3-ACC8-12BE1118731A%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=DCFAC641-E438-4EE3-ACC8-12BE1118731A&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129115194-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=MySQL%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187#1charvarchar_3">1.char和varchar的区别</a></h4><blockquote>
<p>我：</p>
<p>char在MySQL数据中表示固定长度的字符串，即只能保存指定长度的字符串，如果没有达到指定长度，会进行自动填充，如果超过会自动截断超过部分；</p>
<p>varchar表示不定长度的字符串，但是varchar会设定一个最大长度，数据库中保存的最长字符串不能超过这个最大长度，如果超过会自动截断超过部分的字符。</p>
</blockquote>
<blockquote>
<p>补充：</p>
<p>整体上正确。</p>
<p><strong>存储方式</strong>：</p>
<ul>
<li><strong><code>CHAR</code></strong>：<code>CHAR</code> 是定长字符串，MySQL 会自动将存储的数据填充到指定长度，比如你定义 <code>CHAR(10)</code>，无论你存储的是 <code>5</code> 个字符还是 <code>8</code> 个字符，MySQL 都会填充空格，使其总长度达到 <code>10</code>。这些空格在检索数据时会被自动删除。</li>
<li><strong><code>VARCHAR</code></strong>：<code>VARCHAR</code> 是变长字符串，存储的数据长度是实际的字符数加上用于记录长度的额外字节数。对于 <code>VARCHAR</code>，MySQL 不会进行填充，因此数据占用的存储空间较为紧凑。</li>
</ul>
<p><strong>空间效率</strong>：</p>
<ul>
<li><strong><code>CHAR</code></strong>：由于是定长，即使存储的数据较短，依然会占用完整的定义空间。因此，对于较短的字符串或长度固定的数据使用 <code>CHAR</code> 可能会浪费空间。</li>
<li><strong><code>VARCHAR</code></strong>：<code>VARCHAR</code> 是变长的，它仅根据实际存储的数据分配空间，更加节省存储空间。</li>
</ul>
<p><strong>性能</strong>：</p>
<ul>
<li><strong><code>CHAR</code></strong>：由于是固定长度，数据的检索和比较速度会比 <code>VARCHAR</code> 稍快一些，特别是对于经常变化的短数据，比如状态码、固定长度的标识符等，<code>CHAR</code> 的表现会更好。</li>
<li><strong><code>VARCHAR</code></strong>：因为是变长字符串，每次处理数据时，MySQL 需要计算字符串的长度，这可能会影响性能。对于较长的文本，<code>VARCHAR</code> 更灵活，但在性能上可能不如 <code>CHAR</code>。</li>
</ul>
<p><strong>最大长度限制</strong>：</p>
<ul>
<li><strong><code>CHAR</code></strong>：最大长度为 255 字节。</li>
<li><strong><code>VARCHAR</code></strong>：根据字符集的不同，<code>VARCHAR</code> 最多可以存储 65,535 字节的数据。不过，最大长度还受限于行的最大长度（65535 字节），并且 <code>VARCHAR</code> 还会占用 1 或 2 字节来存储字符串的长度。</li>
</ul>
</blockquote>
<h4 id="2-数据库的三大范式"><a href="#2-数据库的三大范式" class="headerlink" title="2.数据库的三大范式"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/twotwo22222/article/details/129115194?ops_request_misc=%7B%22request_id%22:%22DCFAC641-E438-4EE3-ACC8-12BE1118731A%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=DCFAC641-E438-4EE3-ACC8-12BE1118731A&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129115194-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=MySQL%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187#2_8">2.数据库的三大范式</a></h4><blockquote>
<p>分别为第一范式、第二范式和第三范式；</p>
<p>第一范式指的是表中的每一列都是不可再分的；</p>
<p>第二范式指的是在第一范式的基础上消除了非主属性对码的部分依赖；</p>
<p>第三范式在第二范式的基础上消除了非主属性对码的传递函数依赖；</p>
</blockquote>
<blockquote>
<h3 id="评分：7-10"><a href="#评分：7-10" class="headerlink" title="评分：7&#x2F;10"></a>评分：7&#x2F;10</h3><h3 id="需要补充的内容："><a href="#需要补充的内容：" class="headerlink" title="需要补充的内容："></a>需要补充的内容：</h3><ol>
<li><strong>第一范式（1NF）</strong>：<ul>
<li>你提到“每一列都是不可再分的”，这是正确的，但可以更详细说明。例如，表中每个字段应包含原子值（不可分割的最小单位），确保没有重复组或多值列。</li>
<li>示例：一个电话字段不能同时包含多个电话号码。</li>
</ul>
</li>
<li><strong>第二范式（2NF）</strong>：<ul>
<li>你提到的“消除非主属性对码的部分依赖”是准确的，但可以解释“码”是什么意思，并具体说明“部分依赖”。</li>
<li>进一步解释：如果一个表有复合主键，那么所有非主属性必须完全依赖于整个主键，而不能仅依赖于主键的一部分。</li>
<li>示例：如果一个学生选课表用“学生ID”和“课程ID”作为复合主键，课程名称不能仅依赖于“课程ID”，否则就违反了第二范式。</li>
</ul>
</li>
<li><strong>第三范式（3NF）</strong>：<ul>
<li>你提到的“消除非主属性对码的传递函数依赖”是正确的。建议补充说明传递依赖的概念，即如果属性 A 依赖于属性 B，属性 B 又依赖于主键，那么 A 应该直接依赖于主键而非通过 B。</li>
<li>示例：学生表中，如果“班级ID”依赖于“学生ID”，而“班级名称”依赖于“班级ID”，这就构成了传递依赖，应将班级信息拆分到单独的表中。</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="3-你了解sql的执行顺序吗？"><a href="#3-你了解sql的执行顺序吗？" class="headerlink" title="3.你了解sql的执行顺序吗？"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/twotwo22222/article/details/129115194?ops_request_misc=%7B%22request_id%22:%22DCFAC641-E438-4EE3-ACC8-12BE1118731A%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=DCFAC641-E438-4EE3-ACC8-12BE1118731A&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129115194-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=MySQL%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187#3sql_13">3.你了解sql的执行顺序吗？</a></h4><blockquote>
<p>是的，比较了解。</p>
<p>就比如一个查询语句来说，它会先根据from来找到对应的表，然后根据where得到对应查询到的数据，如果存在group by，则会根据具体的内容进行分组，然后如果存在having，则会根据having的要求得到分组之后的结果；</p>
<p>之后就是根据limit来截取得到的结果范围，然后根据select来返回其需要查询对应的列的值。</p>
</blockquote>
<blockquote>
<h3 id="评分：6-10"><a href="#评分：6-10" class="headerlink" title="评分：6&#x2F;10"></a>评分：6&#x2F;10</h3><h3 id="问题与改进建议："><a href="#问题与改进建议：" class="headerlink" title="问题与改进建议："></a>问题与改进建议：</h3><ol>
<li><strong>执行顺序不准确</strong>：<ul>
<li>你的回答提到了执行步骤中的 <code>FROM</code>、<code>WHERE</code>、<code>GROUP BY</code>、<code>HAVING</code>、<code>LIMIT</code> 和 <code>SELECT</code>，但实际的SQL执行顺序与写法的顺序是不同的。</li>
<li>你提到 <code>LIMIT</code> 出现在 <code>HAVING</code> 之后，这是不对的，<code>LIMIT</code> 是在 <code>ORDER BY</code> 后执行。</li>
</ul>
</li>
<li><strong>漏掉了 <code>JOIN</code> 和 <code>ORDER BY</code></strong>：<ul>
<li>你的回答没有提及 <code>JOIN</code> 和 <code>ORDER BY</code>，这些步骤在SQL查询中也非常重要，特别是在复杂查询中。</li>
</ul>
</li>
</ol>
<h3 id="补充正确的SQL执行顺序："><a href="#补充正确的SQL执行顺序：" class="headerlink" title="补充正确的SQL执行顺序："></a>补充正确的SQL执行顺序：</h3><p>SQL 查询的执行顺序如下（与编写顺序不同）：</p>
<ol>
<li><strong>FROM</strong>：首先确定要查询的表或视图，并从这些表中读取数据。如果有 <code>JOIN</code>，这个阶段也会处理表连接。</li>
<li><strong>ON</strong>：如果存在连接条件，在 <code>JOIN</code> 的过程中，先基于 <code>ON</code> 条件进行表之间的连接操作。</li>
<li><strong>JOIN</strong>：根据表的连接类型（如 INNER JOIN、LEFT JOIN）进行数据的连接。</li>
<li><strong>WHERE</strong>：对已经连接的数据进行过滤，只保留满足 <code>WHERE</code> 条件的记录。</li>
<li><strong>GROUP BY</strong>：对 <code>WHERE</code> 过滤后的数据进行分组。</li>
<li><strong>HAVING</strong>：对分组后的结果进行过滤，类似于 <code>WHERE</code>，但它作用于分组后的结果。</li>
<li><strong>SELECT</strong>：确定要返回的列和计算的表达式。执行时此步骤也会对列进行投影。</li>
<li><strong>DISTINCT</strong>：在 <code>SELECT</code> 的基础上进行去重操作。</li>
<li><strong>ORDER BY</strong>：对最终的结果集进行排序。</li>
<li><strong>LIMIT &#x2F; OFFSET</strong>：限制返回的行数或从特定行开始返回数据。</li>
</ol>
<h3 id="正确的例子："><a href="#正确的例子：" class="headerlink" title="正确的例子："></a>正确的例子：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sql复制代码SELECT DISTINCT name, AVG(salary)</span><br><span class="line">FROM employees</span><br><span class="line">WHERE department = &#x27;IT&#x27;</span><br><span class="line">GROUP BY name</span><br><span class="line">HAVING AVG(salary) &gt; 5000</span><br><span class="line">ORDER BY AVG(salary) DESC</span><br><span class="line">LIMIT 10;</span><br></pre></td></tr></table></figure>

<p>执行顺序：</p>
<ol>
<li><code>FROM employees</code></li>
<li><code>WHERE department = &#39;IT&#39;</code></li>
<li><code>GROUP BY name</code></li>
<li><code>HAVING AVG(salary) &gt; 5000</code></li>
<li><code>SELECT DISTINCT name, AVG(salary)</code></li>
<li><code>ORDER BY AVG(salary) DESC</code></li>
<li><code>LIMIT 10</code></li>
</ol>
</blockquote>
<h4 id="4-索引是什么"><a href="#4-索引是什么" class="headerlink" title="4.索引是什么"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/twotwo22222/article/details/129115194?ops_request_misc=%7B%22request_id%22:%22DCFAC641-E438-4EE3-ACC8-12BE1118731A%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=DCFAC641-E438-4EE3-ACC8-12BE1118731A&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129115194-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=MySQL%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187#4_33">4.索引是什么</a></h4><blockquote>
<p>我不太清楚什么是索引，我大概想索引在MySQL数据中根据其索引值可以快速的进行检索，索引应该为整型，如果该字段是个索引，数据库则会为索引进行处理，后续如果进行查询该字段，会更快。</p>
</blockquote>
<blockquote>
<h3 id="评分：4-10"><a href="#评分：4-10" class="headerlink" title="评分：4&#x2F;10"></a>评分：4&#x2F;10</h3><h3 id="问题与改进建议：-1"><a href="#问题与改进建议：-1" class="headerlink" title="问题与改进建议："></a>问题与改进建议：</h3><ol>
<li><strong>索引不局限于整型</strong>：<ul>
<li>你提到“索引应该为整型”，这是不对的。索引可以建立在不同的数据类型上，不仅限于整型，还包括字符串、日期等类型。</li>
</ul>
</li>
<li><strong>索引的实现与数据结构</strong>：<ul>
<li>索引的本质是为提高查询效率，数据库内部通常通过特定的数据结构（如 B+树 或 哈希表）来实现索引。</li>
<li>MySQL 的 <code>InnoDB</code> 存储引擎主要使用 B+树作为默认的索引结构，你可以在回答中提及这一点，以展示更深的理解。</li>
</ul>
</li>
<li><strong>索引并不是总会提高性能</strong>：<ul>
<li>虽然索引可以加速查询，但它也有代价，例如插入、更新和删除操作时，索引也会带来额外的维护开销。过多或不合理的索引可能会影响性能。</li>
</ul>
</li>
</ol>
<h3 id="补充正确的答案："><a href="#补充正确的答案：" class="headerlink" title="补充正确的答案："></a>补充正确的答案：</h3><h4 id="什么是索引？"><a href="#什么是索引？" class="headerlink" title="什么是索引？"></a>什么是索引？</h4><p>索引是数据库中一种用于<strong>提高数据查询效率的机制</strong>。它可以类比为书本中的目录，通过索引，你可以快速定位到数据的位置，而不用遍历整张表。常见的索引类型有：</p>
<ol>
<li><strong>①普通索引：</strong> 基本索引类型，允许定义索引的字段为空值和重复值。</li>
<li><strong>②唯一索引：</strong> 索引的值必须唯一，允许定义索引的字段为空值。</li>
<li><strong>③主键索引：</strong> 索引的值必须唯一，不可以为空。</li>
<li><strong>④复合索引：</strong> 多个字段加索引，遵守最左匹配规则。</li>
<li><strong>⑤全局索引：</strong> 只有在 MyISAM 引擎上才能使用。</li>
</ol>
<h3 id="索引的优点："><a href="#索引的优点：" class="headerlink" title="索引的优点："></a>索引的优点：</h3><ul>
<li>提高 <code>SELECT</code> 查询的性能，尤其是在涉及到 <code>WHERE</code>、<code>ORDER BY</code> 和 <code>JOIN</code> 操作时。</li>
</ul>
<h3 id="索引的缺点："><a href="#索引的缺点：" class="headerlink" title="索引的缺点："></a>索引的缺点：</h3><ul>
<li>会增加数据插入、更新、删除的时间开销，因为索引需要在这些操作时进行维护和更新。</li>
<li>占用额外的存储空间。</li>
<li>索引也是一个文件，所以会占用空间。</li>
<li>降低更新的速度，因为不光要更新数据，还要更新索引。</li>
</ul>
</blockquote>
<h4 id="7-索引怎么设计-优化"><a href="#7-索引怎么设计-优化" class="headerlink" title="7.索引怎么设计(优化)"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/twotwo22222/article/details/129115194?ops_request_misc=%7B%22request_id%22:%22DCFAC641-E438-4EE3-ACC8-12BE1118731A%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=DCFAC641-E438-4EE3-ACC8-12BE1118731A&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129115194-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=MySQL%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187#7_51">7.索引怎么设计(优化)</a></h4><blockquote>
<p>对于表中某些经常需要修改的字段来说不应设置索引，因为经常的更新会导致其数据库效率降低；</p>
<p>索引应该设置在那些读操作很多的表中的不常更新的字段上。</p>
</blockquote>
<blockquote>
<ol>
<li><ul>
<li><p>你的回答提到了索引设计中的一些基本原则，尤其是关于读写操作频繁程度对索引的影响，这部分是正确的，但内容略显简单。下面我会为你打分并给出进一步的补充建议。</p>
<h3 id="评分：7-10-1"><a href="#评分：7-10-1" class="headerlink" title="评分：7&#x2F;10"></a>评分：7&#x2F;10</h3><h3 id="改进建议："><a href="#改进建议：" class="headerlink" title="改进建议："></a>改进建议：</h3><ol>
<li><p><strong>索引的创建不仅取决于读写频率</strong>：</p>
<ul>
<li>虽然你提到频繁更新的字段不应该创建索引是正确的，但索引的设计还需要考虑查询模式、表的大小、索引类型等因素。</li>
</ul>
</li>
<li><p><strong>多列索引与单列索引的选择</strong>：</p>
<ul>
<li>在索引设计中，经常需要考虑是否使用多列组合索引，尤其是在涉及多个查询条件时，合理设计多列索引可以避免全表扫描，提高性能。</li>
</ul>
</li>
<li><p><strong>覆盖索引（Covering Index）</strong>：</p>
<ul>
<li>当查询中的所有字段都被包含在索引中时，MySQL 可以只通过扫描索引来完成查询，而不需要访问数据表。这个概念在索引优化中非常重要。</li>
</ul>
</li>
<li><p><strong>索引前缀（Prefix Index）</strong>：</p>
<ul>
<li>对于长文本或字符串字段，可以只对前几位进行索引，这样既可以节省空间又能够提高查询效率。</li>
</ul>
</li>
</ol>
<h3 id="正确的补充回答："><a href="#正确的补充回答：" class="headerlink" title="正确的补充回答："></a>正确的补充回答：</h3><h4 id="索引设计的原则："><a href="#索引设计的原则：" class="headerlink" title="索引设计的原则："></a>索引设计的原则：</h4><ol>
<li><p><strong>选择性高的列上创建索引</strong>：</p>
<ul>
<li>索引应该创建在选择性高的列上，所谓选择性是指列中唯一值的比例。选择性越高，索引的效率越高，因为它能更快缩小查询范围。</li>
<li>例如，对某个唯一性高的字段（如用户ID）创建索引能够大幅提高查询效率。</li>
</ul>
</li>
<li><p><strong>避免对频繁更新的字段创建索引</strong>：</p>
<ul>
<li>你的回答正确地指出，频繁更新的字段不应创建索引，因为每次更新都需要维护索引，影响写操作的效率。</li>
</ul>
</li>
<li><p><strong>使用复合索引（Multi-column Index）</strong>：</p>
<ul>
<li>对多个查询条件经常一起使用的情况，可以创建复合索引，而不是多个单列索引。比如对查询 <code>WHERE name = &#39;John&#39; AND age = 30</code>，可以创建 <code>(name, age)</code> 的复合索引。</li>
<li>注意索引的顺序，MySQL 使用最左前缀匹配原则，意味着索引顺序很重要，应该将查询中使用最频繁的列放在索引的最前面。</li>
</ul>
</li>
<li><p><strong>覆盖索引</strong>：</p>
<ul>
<li>尽量设计“覆盖索引”，即查询所需的所有字段都在索引中，MySQL 就不需要去查询数据表，从而提升查询效率。</li>
<li>示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_name_age_salary <span class="keyword">ON</span> employees(name, age, salary);</span><br></pre></td></tr></table></figure>
如果你的查询是 <code>SELECT name, age, salary FROM employees WHERE name = &#39;John&#39;</code>, MySQL 可以只通过索引查询，不需要访问原始数据表。</li>
</ul>
</li>
<li><p><strong>前缀索引</strong>：</p>
<ul>
<li>对于较长的文本字段，可以使用前缀索引来节省空间。例如：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX idx_email <span class="keyword">ON</span> users(email(<span class="number">10</span>));</span><br></pre></td></tr></table></figure>
这种做法可以在只查询电子邮件前10个字符时仍然保持较好的性能。</li>
</ul>
</li>
<li><p><strong>避免对低选择性字段创建索引</strong>：</p>
<ul>
<li>像 <code>gender</code> 这种低选择性的字段，选择只有几个值（如’男’和’女’）的列，不适合创建索引，因为它无法有效过滤大量记录。</li>
</ul>
</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>你的回答包含了基础原则，但可以通过更深的索引设计策略来优化回答，特别是复合索引、覆盖索引等高级概念。</li>
</ul>
</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<ol>
<li>①选择唯一性索引：值是唯一的，查询的更快。</li>
<li>②经常作为查询条件的字段加索引。</li>
<li>③为经常需要排序、分组和联合操作的字段建立索引：order by、group by、union(联合)、distinct(去重)等。</li>
<li>④限制索引个数：索引数量多，需要的磁盘空间就越多，更新表时，对索引的重构和更新就很费劲。</li>
<li>⑤表数据少的不建议使用索引(百万级以内)：数据过少，有可能查询的速度，比遍历索引的速度都快。</li>
<li>⑥删除不常用和不再使用的索引。</li>
<li>⑦用类型小的类型做索引：比如：int和BIGINT能用int就使用int。因为类型小，查询速度快和索引占用的空间更少。</li>
<li>⑧使用前缀索引，要是字符串越长，那么索引占的空间越大，并且比较起来就时间就越长。</li>
</ol>
</blockquote>
<h4 id="8-怎么避免索引失效-也属于sql优化的一种"><a href="#8-怎么避免索引失效-也属于sql优化的一种" class="headerlink" title="8.怎么避免索引失效(也属于sql优化的一种)"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/twotwo22222/article/details/129115194?ops_request_misc=%7B%22request_id%22:%22DCFAC641-E438-4EE3-ACC8-12BE1118731A%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=DCFAC641-E438-4EE3-ACC8-12BE1118731A&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129115194-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=MySQL%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187#8sql_62">8.怎么避免索引失效(也属于sql优化的一种)</a></h4><blockquote>
<p>没了解过</p>
</blockquote>
<blockquote>
<p>你的回答没有展现出对索引失效的理解，这在技术面试中是个减分项，特别是如果你已经有一定的工作经验。避免索引失效是SQL优化的一个关键点，深入理解这个问题并提供清晰的解释会展现出你对数据库优化的掌握程度。接下来，我会为你打分并给出正确的答案补充。</p>
<h3 id="评分：3-10"><a href="#评分：3-10" class="headerlink" title="评分：3&#x2F;10"></a>评分：3&#x2F;10</h3><h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><ol>
<li><p><strong>回答过于简单</strong>：</p>
<ul>
<li>直接回答“没了解过”虽然诚实，但也会给面试官留下你缺乏基础知识的印象，尤其是在数据库优化方面。</li>
</ul>
</li>
<li><p><strong>缺乏探索性思维</strong>：</p>
<ul>
<li>在面试中，即使你不完全掌握某个问题，展示出对这个领域的理解和思考过程会给你加分。</li>
</ul>
</li>
</ol>
<h3 id="补充的正确回答："><a href="#补充的正确回答：" class="headerlink" title="补充的正确回答："></a>补充的正确回答：</h3><h4 id="如何避免索引失效？"><a href="#如何避免索引失效？" class="headerlink" title="如何避免索引失效？"></a>如何避免索引失效？</h4><p>索引失效意味着数据库在查询时没有使用可用的索引，从而导致全表扫描，降低查询效率。避免索引失效是SQL优化的一个重要部分，以下是几种常见的避免索引失效的方法：</p>
<ol>
<li><p><strong>避免在 <code>WHERE</code> 子句中的索引列进行函数或表达式操作</strong>：</p>
<ul>
<li>当你对索引列进行函数操作（例如 <code>WHERE UPPER(name) = &#39;JOHN&#39;</code>），索引会失效，因为MySQL不能直接使用索引来过滤数据。</li>
<li>正确做法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>避免在 <code>WHERE</code> 子句中使用隐式类型转换</strong>：</p>
<ul>
<li>如果索引列是字符串类型，但你在查询时使用了整数或其他数据类型，MySQL 会进行隐式类型转换，导致索引失效。</li>
<li>错误示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> phone_number <span class="operator">=</span> <span class="number">1234567890</span>;  <span class="comment">-- phone_number 是字符串类型</span></span><br></pre></td></tr></table></figure></li>
<li>正确做法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> phone_number <span class="operator">=</span> <span class="string">&#x27;1234567890&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong><code>LIKE</code> 查询时避免以 <code>%</code> 开头</strong>：</p>
<ul>
<li>在使用 <code>LIKE</code> 查询时，如果通配符 <code>%</code> 出现在开头，索引会失效，因为MySQL无法确定匹配的起始位置。</li>
<li>错误示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;%John&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li>正确做法：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;John%&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>使用复合索引时遵循最左前缀法则</strong>：</p>
<ul>
<li>如果你在复合索引中查询时没有从第一个索引列开始使用，索引会失效。</li>
<li>假设你有 <code>(name, age)</code> 的复合索引，以下查询会失效：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> age <span class="operator">=</span> <span class="number">30</span>;  <span class="comment">-- 索引失效</span></span><br></pre></td></tr></table></figure></li>
<li>正确的使用方式是：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">30</span>;  <span class="comment">-- 索引有效</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>避免使用 <code>OR</code> 导致索引失效</strong>：</p>
<ul>
<li>使用 <code>OR</code> 时，除非 <code>OR</code> 两边的条件字段都有索引，否则会导致索引失效。</li>
<li>错误示例：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span> <span class="keyword">OR</span> age <span class="operator">=</span> <span class="number">30</span>;  <span class="comment">-- 索引失效</span></span><br></pre></td></tr></table></figure></li>
<li>正确做法是：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> (name <span class="operator">=</span> <span class="string">&#x27;John&#x27;</span> <span class="keyword">AND</span> age <span class="operator">=</span> <span class="number">30</span>);  <span class="comment">-- 使用索引</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>避免使用过多的索引</strong>：</p>
<ul>
<li>索引虽然能提高查询效率，但维护索引也会增加写操作的开销。如果一个表的更新频率很高，索引太多反而会拖慢写入速度。因此，需要合理权衡索引的数量。</li>
</ul>
</li>
</ol>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>为了避免索引失效，应该避免对索引列做不必要的操作，并且要遵循索引的设计规则（如最左前缀法则）。掌握这些技巧不仅能提升查询效率，还能帮助你在数据库优化方面展示出更高的水平。</p>
</blockquote>
<blockquote>
<ol>
<li>①某列使用范围查询(&gt;、&lt;、like、between and)时, 右边的所有列索引也会失效。</li>
<li>②不要对索引字段进行运算。</li>
<li>③在where子句中不要使用 OR、!&#x3D;、&lt;&gt;和对值null的判断。</li>
<li>④避免使用’%’开头的like的模糊查询。</li>
<li>⑤字符串不加单引号，造成索引失效。</li>
</ol>
</blockquote>
<h4 id="9-索引的数据类型"><a href="#9-索引的数据类型" class="headerlink" title="9.索引的数据类型"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/twotwo22222/article/details/129115194?ops_request_misc=%7B%22request_id%22:%22DCFAC641-E438-4EE3-ACC8-12BE1118731A%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=DCFAC641-E438-4EE3-ACC8-12BE1118731A&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-2-129115194-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=MySQL%E9%9D%A2%E8%AF%95%E9%A2%98&spm=1018.2226.3001.4187#9_69">9.索引的数据类型</a></h4><blockquote>
<p>索引的数据类型有：整型、字符串类型、日期类型、布尔型。</p>
</blockquote>
<blockquote>
<p>你的回答虽然提到了一些常见的字段类型，但实际问题是关于“索引的数据类型”，而不是“索引所使用的字段类型”。在MySQL中，索引本身并没有“数据类型”，而是基于字段的类型来创建的。因此，你的回答并未准确回答问题。以下是对你回答的评分和正确的解释。</p>
<h3 id="评分：4-10-1"><a href="#评分：4-10-1" class="headerlink" title="评分：4&#x2F;10"></a>评分：4&#x2F;10</h3><h3 id="评分说明："><a href="#评分说明：" class="headerlink" title="评分说明："></a>评分说明：</h3><ol>
<li><strong>正确性</strong>：你提到的字段类型（整型、字符串类型、日期类型、布尔型）确实是常见的字段类型，可以用于索引。但是，索引的“数据类型”这一问题没有被正确回答。</li>
<li><strong>相关性</strong>：虽然提到的字段类型和索引相关，但并不直接回答索引的类型或如何根据字段类型设计索引。</li>
</ol>
<h3 id="正确答案补充："><a href="#正确答案补充：" class="headerlink" title="正确答案补充："></a>正确答案补充：</h3><h4 id="MySQL中索引的类型："><a href="#MySQL中索引的类型：" class="headerlink" title="MySQL中索引的类型："></a>MySQL中索引的类型：</h4><p>在MySQL中，索引没有“数据类型”，而是根据字段的数据类型来创建的。不过，MySQL支持以下几种主要的索引类型：</p>
<ol>
<li><p><strong>B-Tree 索引</strong>：</p>
<ul>
<li><strong>描述</strong>：这是最常见的索引类型，适用于大多数类型的查询，特别是范围查询。</li>
<li><strong>适用数据类型</strong>：整型、字符串类型、日期类型等。</li>
<li><strong>实现</strong>：通过B-Tree（平衡树）结构来存储索引。</li>
</ul>
</li>
<li><p><strong>哈希索引</strong>：</p>
<ul>
<li><strong>描述</strong>：哈希索引适用于精确匹配查询（&#x3D;），但不支持范围查询。</li>
<li><strong>适用数据类型</strong>：整型、字符串类型等。</li>
<li><strong>实现</strong>：使用哈希表来存储索引。</li>
<li><strong>注意</strong>：InnoDB存储引擎在某些情况下（如Memory引擎的表）支持哈希索引。</li>
</ul>
</li>
<li><p><strong>全文索引（Full-Text Index）</strong>：</p>
<ul>
<li><strong>描述</strong>：用于全文搜索，适用于文本数据。</li>
<li><strong>适用数据类型</strong>：通常为字符串类型（如 <code>TEXT</code>、<code>VARCHAR</code>）。</li>
<li><strong>实现</strong>：通过倒排索引来加速全文搜索查询。</li>
</ul>
</li>
<li><p><strong>空间索引（Spatial Index）</strong>：</p>
<ul>
<li><strong>描述</strong>：用于空间数据（如地理信息系统中的地理数据）。</li>
<li><strong>适用数据类型</strong>：空间数据类型（如 <code>GEOMETRY</code>、<code>POINT</code>）。</li>
<li><strong>实现</strong>：使用R-Tree（矩形树）来存储索引。</li>
</ul>
</li>
<li><p><strong>前缀索引</strong>：</p>
<ul>
<li><strong>描述</strong>：对于长字符串类型的数据，可以索引字符串的一部分（前缀），从而减少索引的大小。</li>
<li><strong>适用数据类型</strong>：字符串类型（如 <code>VARCHAR</code>）。</li>
<li><strong>实现</strong>：仅对字段的前几个字符建立索引。</li>
</ul>
</li>
</ol>
<h4 id="其他注意事项："><a href="#其他注意事项：" class="headerlink" title="其他注意事项："></a>其他注意事项：</h4><ul>
<li><strong>唯一索引（Unique Index）</strong>：确保索引列的值唯一。</li>
<li><strong>复合索引（Composite Index）</strong>：索引多个列，优化多个列联合查询的性能。</li>
</ul>
<h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>理解索引的类型和如何根据字段的数据类型选择合适的索引类型，是数据库设计和优化的重要部分。确保回答中明确区分索引的类型与字段的类型，以便在面试中提供准确和相关的信息。</p>
</blockquote>
<blockquote>
<ul>
<li><strong>Hash：</strong> 查询时调用Hash函数获得地址，回表查询实际数据。(InnoDB和MylSAM不支持，Memory支持)。</li>
<li><strong>B+树：</strong> 每次从根节点出发去查询，然后得到地址，回表查询实际数据。</li>
</ul>
</blockquote>
<h4 id="10-索引为什么使用树结构"><a href="#10-索引为什么使用树结构" class="headerlink" title="10.索引为什么使用树结构"></a>10.索引为什么使用树结构</h4><blockquote>
<p>因为树的结构可以快速的把问题分解，可以非常有效的加快数据的查询速度。</p>
<p>树的结构可以把一个大问题分而治之，极大的降低了复杂度。</p>
</blockquote>
<blockquote>
<p>你的回答对“为什么索引使用树结构”这一问题给出了一些基本的理由，但没有深入说明树结构的具体优势以及为何它特别适用于数据库索引。以下是对你回答的评分及详细补充。</p>
<h3 id="评分：5-10"><a href="#评分：5-10" class="headerlink" title="评分：5&#x2F;10"></a>评分：5&#x2F;10</h3><h3 id="评分说明：-1"><a href="#评分说明：-1" class="headerlink" title="评分说明："></a>评分说明：</h3><ol>
<li><strong>正确性</strong>：你的回答在某种程度上是正确的，因为树结构确实有助于提高查询效率，但回答过于笼统，未能详细阐述树结构的具体优势。</li>
<li><strong>详细程度</strong>：未涉及树结构的具体类型（如B-Tree）的细节和它们如何改善索引性能。</li>
</ol>
<h3 id="正确答案补充：-1"><a href="#正确答案补充：-1" class="headerlink" title="正确答案补充："></a>正确答案补充：</h3><h4 id="为什么索引使用树结构"><a href="#为什么索引使用树结构" class="headerlink" title="为什么索引使用树结构"></a>为什么索引使用树结构</h4><ol>
<li><p><strong>高效的查找性能</strong>：</p>
<ul>
<li><strong>B-Tree（平衡树）</strong>：在MySQL中，最常用的索引结构是B-Tree（平衡树）。B-Tree能够保持数据的有序性，并且每个节点有多个子节点，使得查找操作的复杂度保持在对数级别O(log N)。这种结构支持高效的范围查询和排序操作。</li>
<li><strong>R-Tree（矩形树）</strong>：用于空间数据（如地理信息系统中的数据）。R-Tree支持高效的多维范围查询，非常适合处理空间数据。</li>
</ul>
</li>
<li><p><strong>分层结构</strong>：</p>
<ul>
<li>树结构的分层特性使得查询能够通过逐层访问来减少需要检查的数据量。例如，在B-Tree中，每一层都将数据分割成更小的子集，从而快速缩小搜索范围。</li>
</ul>
</li>
<li><p><strong>动态平衡</strong>：</p>
<ul>
<li><strong>自平衡</strong>：B-Tree是一种自平衡的树结构，确保所有叶子节点都在同一深度，从而使得查找操作的时间复杂度保持在O(log N)。</li>
<li><strong>插入和删除</strong>：树结构支持高效的插入和删除操作，同时保持树的平衡，从而不会显著降低查询性能。</li>
</ul>
</li>
<li><p><strong>减少磁盘I&#x2F;O</strong>：</p>
<ul>
<li><strong>索引页和节点</strong>：树结构的索引通常分为多个页或节点，这样可以将大量数据分布在多个页中，而不是在一个大块中存储。这种设计减少了磁盘I&#x2F;O，因为查询时只需要访问少量的页或节点。</li>
<li><strong>缓存效率</strong>：树结构能利用缓存，减少磁盘访问次数，从而提高查询速度。</li>
</ul>
</li>
<li><p><strong>支持多种操作</strong>：</p>
<ul>
<li><strong>范围查询</strong>：树结构特别适合范围查询（如找出介于两个值之间的所有记录），因为它能够快速定位到起始值和结束值之间的数据。</li>
<li><strong>排序和聚合</strong>：树结构支持高效的排序操作，因为数据已经按顺序存储。</li>
</ul>
</li>
</ol>
<h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><p>树结构（尤其是B-Tree）因其高效的查找、插入、删除和范围查询操作，成为数据库索引的主要选择。树的层级结构和自平衡特性能够有效提高数据访问的效率，同时减少磁盘I&#x2F;O，提高整体性能。理解这些细节可以帮助你在面试中提供更深入的回答。</p>
</blockquote>
<blockquote>
<p>因为可以加快查询效率，而且可以保持有序。</p>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post-share"><div class="social-share" data-image="/img/14.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/02/26/74-01%20Python/" title="74-01 Python"><img class="cover" src="/img/11.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">74-01 Python</div></div><div class="info-2"><div class="info-item-1">74-01 Python结合你对Java的熟悉程度，我会详细介绍Python中的面向对象编程（OOP）语法，并与Java进行对比。Python和Java的OOP概念相似，但语法和一些实现细节有所不同。 面向对象1. 类与对象Java：1234567891011121314151617181920class Person &#123;    String name;    int age;    Person(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    void greet() &#123;        System.out.println(&quot;Hello, my name is &quot; + name);    &#125;&#125;public class Main &#123;    public static void main(String[] args) &#123;        Person person =...</div></div></div></a><a class="pagination-related" href="/2025/02/26/75-01%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="75-01 数据结构"><img class="cover" src="/img/13.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">75-01 数据结构</div></div><div class="info-2"><div class="info-item-1">75-01 数据结构参考资料 树形 DP    树二叉查找树二叉树具有以下性质：左子树的键值小于根的键值，右子树的键值大于根的键值。  如果根节点选的不好会导致二叉树过深。 平衡二叉树平衡二叉树（AVL树）在符合二叉查找树的条件下，还满足任何节点的两个子树的高度最大差为1。下面的两张图片，左边是AVL树，它的任何节点的两个子树的高度差&lt;&#x3D;1；右边的不是AVL树，其根节点的左子树高度为3，而右子树高度为1；  那么这里就会涉及到一些复杂的问题，如果我对这个树进行增删改查之后，导致了这个树不平衡了该怎么办？ ...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/02/26/34-01%20%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%BE%BE%E6%A2%A6%E6%95%B0%E6%8D%AE%E5%BA%93/" title="34-01 数据库-达梦数据库"><img class="cover" src="/img/23.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-26</div><div class="info-item-2">34-01 数据库-达梦数据库</div></div><div class="info-2"><div class="info-item-1">34-01 数据库-达梦数据库简介在信息安全日益重要的今天，国内很多部门都要求使用国产化的数据库来替代原先国外的数据库，在这里介绍一款国内较知名的数据库——达梦。 达梦数据库管理系统是达梦公司推出的具有完全自主知识产权的高性能数据库管理系统，简称DM。达梦数据库管理系统7.0版本，简称DM7。 达梦数据库安装这里介绍的是在Windows环境下安装DM数据库。 参考教程：Windows环境安装达梦数据库 按照过程一步一步的进行即可。 默认用户名：SYSDBA 默认密码：SYSDBA Ubuntu环境下安装达梦数据库参考资料：Linux安装达梦数据库&#x2F;DM8（附带客户端工具安装完整版） 创建安装与运行的Linux用户1234567891011121314151617# 1.创建安装用户组 dmsys[root@laizhenghua /]# groupadd dmsys# 2.创建安装用户 dmdba[root@laizhenghua /]# sudo useradd -g dmsys -m -d...</div></div></div></a><a class="pagination-related" href="/2025/02/26/34-02%20TongSearch%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/" title="34-02 TongSearch安装教程"><img class="cover" src="/img/26.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-26</div><div class="info-item-2">34-02 TongSearch安装教程</div></div><div class="info-2"><div class="info-item-1">34-02 TongSearch安装教程Ubuntu环境下TongSearch安装下载安装包到任意目录  解压至当前目录 1unzip TongSearch.zip   开放端口9200和9300 12sudo ufw allow 9200/tcpsudo ufw allow 9300/tcp  JDK配置，确保本地配置了JDK如下配置： 12345export JAVA_HOME=/opt/java/jdk-11.0.19export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib:$CLASSPATHexport JAVA_PATH=$&#123;JAVA_HOME&#125;/bin:$&#123;JRE_HOME&#125;/binexport PATH=$PATH:$&#123;JAVA_PATH&#125;  系统配置 1sudo sysctl -w...</div></div></div></a><a class="pagination-related" href="/2025/03/03/75-23%20MySQL%E7%B4%A2%E5%BC%95/" title="75-23 MySQL索引"><img class="cover" src="/img/26.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-03</div><div class="info-item-2">75-23 MySQL索引</div></div><div class="info-2"><div class="info-item-1">75-23 MySQL索引前言索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。 其最主要的作用就是提供了一个数据结构让数据库可以快速的查询到目标数据。 MySQL8之后默认的存储引擎为InnoDB，但是无论是InnoDB还是MyISAM，其索引所选择的数据结构都是B+树。有个问题，为什么选择B+树作为其存储引擎的索引结构呢？ 优缺点认识一个新的事物，先来看看该事物有什么优点和缺点。 优点 第一点，不必多言，引入了索引之后，数据库在某些查询方面的效率大幅度提升，较少了IO次数（为什么）； 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。  缺点 如果我们将某些字段加入了索引，那么如果我对这个索引字段进行了修改，那么存储引擎也会同步的对索引进行更新，那么必然就会造成SQL执行效率降低； MySQL同时需要保存索引排序后的物理文件，这在一定程度上也会耗费一些空间（问题不大）；  但是总体来说，如果数据库的数据量比较大的情况下，引入索引好处是优于坏处的，索引查询绝大部分情况下是比全表查询要快的。 B 树&amp; B+树B 树也称...</div></div></div></a><a class="pagination-related" href="/2025/03/04/75-25%20MySQL%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%AD%89%E7%BA%A7/" title="75-25 MySQL事务隔离等级"><img class="cover" src="/img/1.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-04</div><div class="info-item-2">75-25 MySQL事务隔离等级</div></div><div class="info-2"><div class="info-item-1">75-25 MySQL事务隔离等级隔离级别 读未提交：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 读已提交：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 可重复读：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 可串行化：最高的隔离级别，完全服从 ACID...</div></div></div></a><a class="pagination-related" href="/2025/03/03/75-24%20MySQL%E6%97%A5%E5%BF%97/" title="75-24 MySQL日志"><img class="cover" src="/img/7.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-03</div><div class="info-item-2">75-24 MySQL日志</div></div><div class="info-2"><div class="info-item-1">75-24 MySQL日志前言MySQL中的日志主要用于数据恢复、性能优化、问题排查等。它们分为几类，每种日志都有不同的作用。主要包括：  错误日志（Error Log） 通用查询日志（General Query Log） 慢查询日志（Slow Query Log） 二进制日志（Binary Log, Binlog） 事务日志（Redo Log &amp; Undo Log） 中继日志（Relay Log）  其中比较重要的日志有：二进制日志、事务日志（Redo Log &amp; Undo Log）。 对于MySQL中的日志，其日志的主要作用牢牢抓住数据恢复、性能优化和问题排查。  Redo Logredo log（重做日志）是 InnoDB 存储引擎独有的，它让 MySQL 拥有了崩溃恢复能力。 比如 MySQL 实例挂了或宕机了，重启时，InnoDB 存储引擎会使用 redo log 恢复数据，保证数据的持久性与完整性。  MySQL中的数据是以页为基本单位进行操作的，如果在执行一条SQL语句时，MySQL会先将符合的那一页加载到Buffer...</div></div></div></a><a class="pagination-related" href="/2025/03/04/75-26%20MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" title="75-26 MVCC多版本并发控制"><img class="cover" src="/img/23.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-04</div><div class="info-item-2">75-26 MVCC多版本并发控制</div></div><div class="info-2"><div class="info-item-1">75-26 MVCC多版本并发控制前言MVCC ，也就是多版本并发控制，是为了在读取数据时不加锁来提高读取效率和并发性的一种手段。 数据库并发有以下几种场景：  读-读：不存在任何问题。 读-写：有线程安全问题，可能出现脏读、幻读、不可重复读。 写-写：有线程安全问题，可能存在更新丢失等。  MVCC 解决的就是读写时的线程安全问题，线程不用去争抢读写锁。 MVCC 允许多个事务并发执行，同时避免加锁带来的性能问题。其本质是通过维护数据的多个版本，让事务可以“看到”不同的历史数据版本，从而实现非阻塞读。 在 MySQL 的 InnoDB 存储引擎中，MVCC 主要用于 READ COMMITTED 和 REPEATABLE READ 两个隔离级别。 当一个事务要对数据库中的数据进行修改时，MVCC 会为该事务创建一个数据快照，而不是直接修改实际的数据行。  在 MySQL 的 InnoDB 存储引擎中，快照通过 Undo Log 来实现。每次数据更新时，InnoDB 会保存旧版本的数据，并通过指针来链式存储这些旧版本数据，从而形成数据的版本链。  Undo Log...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">徐行</div><div class="author-info-description">道阻且长</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">101</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">76</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">27</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/fangyaohui"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#58-MySQL"><span class="toc-number">1.</span> <span class="toc-text">58 MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E5%9F%BA%E7%A1%80"><span class="toc-number">1.1.</span> <span class="toc-text">MySQL基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%A4%96%E9%94%AE%E5%92%8C%E7%BA%A7%E8%81%94"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">为什么不推荐使用外键和级联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">数据库范式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E8%8C%83%E5%BC%8F"><span class="toc-number">1.1.1.2.1.</span> <span class="toc-text">第一范式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E8%8C%83%E5%BC%8F"><span class="toc-number">1.1.1.2.2.</span> <span class="toc-text">第二范式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">1.1.1.2.3.</span> <span class="toc-text">第三范式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#drop%E3%80%81delete-%E4%B8%8E-truncate-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">drop、delete 与 truncate 区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">常见关系型数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.1.5.</span> <span class="toc-text">MySQL基础架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E9%80%89%E6%8B%A9SQL%E5%8F%88%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%80%89%E6%8B%A9NoSQL%E5%91%A2"><span class="toc-number">1.1.1.6.</span> <span class="toc-text">何时选择SQL又什么时候选择NoSQL呢</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E8%81%94%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.1.1.7.</span> <span class="toc-text">MySQL如何进行联表查询</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E8%BF%9E%E6%8E%A5%EF%BC%88INNER-JOIN"><span class="toc-number">1.1.1.7.1.</span> <span class="toc-text">内连接（INNER JOIN)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5-LEFT-JOIN"><span class="toc-number">1.1.1.7.2.</span> <span class="toc-text">左外连接 (LEFT JOIN)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%B3%E5%A4%96%E8%BF%9E%E6%8E%A5-RIGHT-JOIN"><span class="toc-number">1.1.1.7.3.</span> <span class="toc-text">右外连接 (RIGHT JOIN)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%A8%E5%A4%96%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.1.1.7.4.</span> <span class="toc-text">全外连接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Group-By-%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.1.8.</span> <span class="toc-text">Group By 聚合函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.1.1.9.</span> <span class="toc-text">SQL查询语句的执行顺序是怎么样的？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL"><span class="toc-number">1.1.2.</span> <span class="toc-text">SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SQL%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">SQL分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DDL%EF%BC%88Data-Definition-Language%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">DDL（Data Definition Language）：数据定义语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DML%EF%BC%88Data-Manipulation-Language%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.2.4.</span> <span class="toc-text">DML（Data Manipulation Language）：数据操作语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DCL%EF%BC%88Data-Control-Language%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.2.5.</span> <span class="toc-text">DCL（Data Control Language）：数据控制语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DQL%EF%BC%88Data-Query-Language%EF%BC%89%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80"><span class="toc-number">1.1.2.6.</span> <span class="toc-text">DQL（Data Query Language）：数据查询语言</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.1.2.6.1.</span> <span class="toc-text">条件查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.1.2.6.2.</span> <span class="toc-text">模糊查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E6%8E%A7%E5%88%B6%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.1.2.6.3.</span> <span class="toc-text">字段控制查询</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.7.</span> <span class="toc-text">窗口函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.2.7.1.</span> <span class="toc-text">窗口函数应用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95"><span class="toc-number">1.1.2.7.2.</span> <span class="toc-text">语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.2.7.3.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.7.4.</span> <span class="toc-text">聚合函数作为窗口函数</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">1.2.</span> <span class="toc-text">存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1SQL%E8%AF%B7%E6%B1%82%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">一条SQL请求的执行顺序是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#InnoDB%E4%BA%8EMyISAM%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.2.</span> <span class="toc-text">InnoDB于MyISAM存储引擎有哪些区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E4%BD%A0%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="toc-number">1.3.1.</span> <span class="toc-text">请你介绍一下什么是索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E4%BD%A0%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.2.</span> <span class="toc-text">请你介绍一下索引的分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E4%BD%A0%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9B-Tree%E4%BD%9C%E4%B8%BA%E5%85%B6%E7%B4%A2%E5%BC%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%91%A2"><span class="toc-number">1.3.3.</span> <span class="toc-text">请你介绍一下为什么选择B+Tree作为其索引数据结构呢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E6%98%AF%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E7%9A%84"><span class="toc-number">1.3.4.</span> <span class="toc-text">B+树是如何构建的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%A0%91%E6%8F%92%E5%85%A5%E4%B8%8E%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3%EF%BC%88%E4%BB%A5%E9%98%B6%E6%95%B0m-3%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">B+树插入与删除操作详解（以阶数m&#x3D;3为例）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%9D%E5%A7%8BB-%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.5.1.</span> <span class="toc-text">1. 初始B+树结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%8A%82%E7%82%B9%E5%88%86%E8%A3%82"><span class="toc-number">1.3.5.2.</span> <span class="toc-text">2. 插入操作与节点分裂</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E6%8F%92%E5%85%A55%E3%80%8110%E3%80%8115"><span class="toc-number">1.3.5.2.1.</span> <span class="toc-text">2.1 插入5、10、15</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E6%8F%92%E5%85%A520%EF%BC%88%E8%A7%A6%E5%8F%91%E5%88%86%E8%A3%82%EF%BC%89"><span class="toc-number">1.3.5.2.2.</span> <span class="toc-text">2.2 插入20（触发分裂）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-%E6%8F%92%E5%85%A525%E3%80%8130"><span class="toc-number">1.3.5.2.3.</span> <span class="toc-text">2.3 插入25、30</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-4-%E6%8F%92%E5%85%A535%E3%80%8140"><span class="toc-number">1.3.5.2.4.</span> <span class="toc-text">2.4 插入35、40</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C%E4%B8%8E%E8%8A%82%E7%82%B9%E5%90%88%E5%B9%B6-%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D"><span class="toc-number">1.3.5.3.</span> <span class="toc-text">3. 删除操作与节点合并&#x2F;重新分配</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-%E5%88%A0%E9%99%A415%EF%BC%88%E7%9B%B4%E6%8E%A5%E5%88%A0%E9%99%A4%EF%BC%89"><span class="toc-number">1.3.5.3.1.</span> <span class="toc-text">3.1 删除15（直接删除）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-2-%E5%88%A0%E9%99%A425%EF%BC%88%E8%A7%A6%E5%8F%91%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%EF%BC%89"><span class="toc-number">1.3.5.3.2.</span> <span class="toc-text">3.2 删除25（触发重新分配）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-%E5%88%A0%E9%99%A45%EF%BC%88%E8%A7%A6%E5%8F%91%E5%90%88%E5%B9%B6%EF%BC%89"><span class="toc-number">1.3.5.3.3.</span> <span class="toc-text">3.3 删除5（触发合并）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-%E5%88%A0%E9%99%A410%EF%BC%88%E8%A7%A6%E5%8F%91%E8%8A%82%E7%82%B9%E5%90%88%E5%B9%B6%EF%BC%89"><span class="toc-number">1.3.5.3.4.</span> <span class="toc-text">3.4 删除10（触发节点合并）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E6%9C%BA%E5%88%B6%E6%80%BB%E7%BB%93"><span class="toc-number">1.3.5.4.</span> <span class="toc-text">4. 关键机制总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-B-%E6%A0%91%E6%93%8D%E4%BD%9C%E5%AF%B9%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.3.5.5.</span> <span class="toc-text">5. B+树操作对性能的影响</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E8%BF%9B%E9%98%B6"><span class="toc-number">1.4.</span> <span class="toc-text">MySQL进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E6%9E%B6%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">MySQL架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.4.2.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.4.2.1.1.</span> <span class="toc-text">什么是事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.4.2.1.2.</span> <span class="toc-text">为什么需要事务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%E5%91%A2"><span class="toc-number">1.4.2.1.3.</span> <span class="toc-text">事务有什么特点呢</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7"><span class="toc-number">1.4.2.1.4.</span> <span class="toc-text">隔离性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">特点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.4.2.3.1.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.4.2.3.2.</span> <span class="toc-text">一致性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7-1"><span class="toc-number">1.4.2.3.3.</span> <span class="toc-text">隔离性</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4"><span class="toc-number">1.4.2.3.3.1.</span> <span class="toc-text">读未提交</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4"><span class="toc-number">1.4.2.3.3.2.</span> <span class="toc-text">读已提交</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="toc-number">1.4.2.3.3.3.</span> <span class="toc-text">可重复读</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%8C%96"><span class="toc-number">1.4.2.3.3.4.</span> <span class="toc-text">串行化</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">1.4.2.3.4.</span> <span class="toc-text">持久性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">并发事务带来的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%84%8F%E8%AF%BB"><span class="toc-number">1.4.2.4.1.</span> <span class="toc-text">脏读</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB-Non-Repeatable-read"><span class="toc-number">1.4.2.4.2.</span> <span class="toc-text">不可重复读(Non-Repeatable read)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%BB%E8%AF%BB"><span class="toc-number">1.4.2.4.3.</span> <span class="toc-text">幻读</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL-%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%98%AF%E5%9F%BA%E4%BA%8E%E9%94%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%90%97"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">MySQL 的隔离级别是基于锁实现的吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC-%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%EF%BC%9A"><span class="toc-number">1.4.3.</span> <span class="toc-text">MVCC 的核心思想：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E9%94%81"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">MySQL锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">MySQL数据库的事务实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95-1"><span class="toc-number">1.4.4.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">什么是索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">索引类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF%E5%92%8C%E5%8A%A3%E5%8A%BF"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">索引的优势和劣势</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">1.4.4.3.1.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A3%E5%8A%BF"><span class="toc-number">1.4.4.3.2.</span> <span class="toc-text">劣势</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">索引失效</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%8C%B9%E9%85%8D%E5%8E%9F%E5%88%99"><span class="toc-number">1.4.4.4.1.</span> <span class="toc-text">最左匹配原则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%86select"><span class="toc-number">1.4.4.4.2.</span> <span class="toc-text">使用了select *</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8A%E6%9C%89%E8%AE%A1%E7%AE%97"><span class="toc-number">1.4.4.4.3.</span> <span class="toc-text">索引上有计算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8A%E6%9C%89%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.4.4.4.</span> <span class="toc-text">索引上有函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E7%B1%BB%E5%9E%8B%E4%B8%8D%E5%90%8C"><span class="toc-number">1.4.4.4.5.</span> <span class="toc-text">字段类型不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#like%E5%B7%A6%E8%BE%B9%E5%8C%85%E5%90%AB"><span class="toc-number">1.4.4.4.6.</span> <span class="toc-text">like左边包含%</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%97%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.4.4.7.</span> <span class="toc-text">列对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8OR%E5%85%B3%E9%94%AE%E8%AF%8D"><span class="toc-number">1.4.4.4.8.</span> <span class="toc-text">使用OR关键词</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#not-in%E5%92%8Cnot-exists"><span class="toc-number">1.4.4.4.9.</span> <span class="toc-text">not in和not exists</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-ORDER-BY-%E6%88%96-GROUP-BY-%E6%97%B6%E7%9A%84%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">1.4.4.4.10.</span> <span class="toc-text">使用 ORDER BY  或 GROUP BY 时的索引失效</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8%E4%BA%86%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.4.5.</span> <span class="toc-text">查看是否使用了索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98"><span class="toc-number">1.4.4.6.</span> <span class="toc-text">实战</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2SQL"><span class="toc-number">1.4.5.</span> <span class="toc-text">慢SQL</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2SQL%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">慢SQL定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%85%A2SQL%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">慢SQL优化</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SQL%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.5.2.1.</span> <span class="toc-text">SQL优化</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">优化步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%86%E6%9E%90%E6%9F%A5%E8%AF%A2%EF%BC%9AEXPLAIN-%E8%AF%8A%E6%96%AD%E6%9F%A5%E8%AF%A2%E8%AE%A1%E5%88%92"><span class="toc-number">1.4.5.3.1.</span> <span class="toc-text">1. 分析查询：EXPLAIN 诊断查询计划</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BC%98%E5%8C%96%E7%B4%A2%E5%BC%95%EF%BC%9A%E7%BB%84%E5%90%88%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.5.3.2.</span> <span class="toc-text">2.优化索引：组合索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">1.4.5.3.3.</span> <span class="toc-text">3.覆盖索引</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-WHERE-%E6%9D%A1%E4%BB%B6%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.5.3.4.</span> <span class="toc-text">4.WHERE 条件优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-ORDER-BY-%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.5.3.5.</span> <span class="toc-text">5.ORDER BY 优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-LIMIT-%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.5.3.6.</span> <span class="toc-text">6.LIMIT 优化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%87%8F%E5%B0%91-SELECT-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.5.3.7.</span> <span class="toc-text">7.减少 SELECT * 的使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.4.6.</span> <span class="toc-text">MySQL执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%B4MySQL%E8%A1%8C%E6%95%B0%E8%B6%85%E8%BF%87%E4%BA%862000W%E8%A1%8C%E5%90%8E%E6%95%88%E7%8E%87%E5%B0%B1%E4%B8%8D%E5%A5%BD%E4%BA%86%E5%91%A2"><span class="toc-number">1.4.7.</span> <span class="toc-text">为什么说MySQL行数超过了2000W行后效率就不好了呢</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.5.</span> <span class="toc-text">MySQL面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95"><span class="toc-number">1.5.1.</span> <span class="toc-text">第一次面试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%96%99%E6%9D%A5%E6%BA%90"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">资料来源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promote"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">Promote</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-char%E5%92%8Cvarchar%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">1.char和varchar的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E5%A4%A7%E8%8C%83%E5%BC%8F"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">2.数据库的三大范式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E5%88%86%EF%BC%9A7-10"><span class="toc-number">1.5.2.</span> <span class="toc-text">评分：7&#x2F;10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E8%A1%A5%E5%85%85%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9A"><span class="toc-number">1.5.3.</span> <span class="toc-text">需要补充的内容：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BD%A0%E4%BA%86%E8%A7%A3sql%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%90%97%EF%BC%9F"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">3.你了解sql的执行顺序吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E5%88%86%EF%BC%9A6-10"><span class="toc-number">1.5.4.</span> <span class="toc-text">评分：6&#x2F;10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%8E%E6%94%B9%E8%BF%9B%E5%BB%BA%E8%AE%AE%EF%BC%9A"><span class="toc-number">1.5.5.</span> <span class="toc-text">问题与改进建议：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E6%AD%A3%E7%A1%AE%E7%9A%84SQL%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%EF%BC%9A"><span class="toc-number">1.5.6.</span> <span class="toc-text">补充正确的SQL执行顺序：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%9A"><span class="toc-number">1.5.7.</span> <span class="toc-text">正确的例子：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%B4%A2%E5%BC%95%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.5.7.1.</span> <span class="toc-text">4.索引是什么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E5%88%86%EF%BC%9A4-10"><span class="toc-number">1.5.8.</span> <span class="toc-text">评分：4&#x2F;10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E4%B8%8E%E6%94%B9%E8%BF%9B%E5%BB%BA%E8%AE%AE%EF%BC%9A-1"><span class="toc-number">1.5.9.</span> <span class="toc-text">问题与改进建议：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%AD%94%E6%A1%88%EF%BC%9A"><span class="toc-number">1.5.10.</span> <span class="toc-text">补充正确的答案：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">1.5.10.1.</span> <span class="toc-text">什么是索引？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">1.5.11.</span> <span class="toc-text">索引的优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.5.12.</span> <span class="toc-text">索引的缺点：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%B4%A2%E5%BC%95%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1-%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.12.1.</span> <span class="toc-text">7.索引怎么设计(优化)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E5%88%86%EF%BC%9A7-10-1"><span class="toc-number">1.5.13.</span> <span class="toc-text">评分：7&#x2F;10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E5%BB%BA%E8%AE%AE%EF%BC%9A"><span class="toc-number">1.5.14.</span> <span class="toc-text">改进建议：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%A1%A5%E5%85%85%E5%9B%9E%E7%AD%94%EF%BC%9A"><span class="toc-number">1.5.15.</span> <span class="toc-text">正确的补充回答：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%8E%9F%E5%88%99%EF%BC%9A"><span class="toc-number">1.5.15.1.</span> <span class="toc-text">索引设计的原则：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">1.5.16.</span> <span class="toc-text">总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88-%E4%B9%9F%E5%B1%9E%E4%BA%8Esql%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E7%A7%8D"><span class="toc-number">1.5.16.1.</span> <span class="toc-text">8.怎么避免索引失效(也属于sql优化的一种)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E5%88%86%EF%BC%9A3-10"><span class="toc-number">1.5.17.</span> <span class="toc-text">评分：3&#x2F;10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.5.18.</span> <span class="toc-text">问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%9B%9E%E7%AD%94%EF%BC%9A"><span class="toc-number">1.5.19.</span> <span class="toc-text">补充的正确回答：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">1.5.19.1.</span> <span class="toc-text">如何避免索引失效？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-number">1.5.20.</span> <span class="toc-text">总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.20.1.</span> <span class="toc-text">9.索引的数据类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E5%88%86%EF%BC%9A4-10-1"><span class="toc-number">1.5.21.</span> <span class="toc-text">评分：4&#x2F;10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E5%88%86%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">1.5.22.</span> <span class="toc-text">评分说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%AD%94%E6%A1%88%E8%A1%A5%E5%85%85%EF%BC%9A"><span class="toc-number">1.5.23.</span> <span class="toc-text">正确答案补充：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MySQL%E4%B8%AD%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B%EF%BC%9A"><span class="toc-number">1.5.23.1.</span> <span class="toc-text">MySQL中索引的类型：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">1.5.23.2.</span> <span class="toc-text">其他注意事项：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-2"><span class="toc-number">1.5.24.</span> <span class="toc-text">总结：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.24.1.</span> <span class="toc-text">10.索引为什么使用树结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E5%88%86%EF%BC%9A5-10"><span class="toc-number">1.5.25.</span> <span class="toc-text">评分：5&#x2F;10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E5%88%86%E8%AF%B4%E6%98%8E%EF%BC%9A-1"><span class="toc-number">1.5.26.</span> <span class="toc-text">评分说明：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%AD%94%E6%A1%88%E8%A1%A5%E5%85%85%EF%BC%9A-1"><span class="toc-number">1.5.27.</span> <span class="toc-text">正确答案补充：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%B4%A2%E5%BC%95%E4%BD%BF%E7%94%A8%E6%A0%91%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.27.1.</span> <span class="toc-text">为什么索引使用树结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-3"><span class="toc-number">1.5.28.</span> <span class="toc-text">总结：</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/25/75-41%20%E6%8B%9C%E5%8D%A0%E5%BA%AD&amp;%E9%9D%9E%E6%8B%9C%E5%8D%A0%E5%BA%AD/" title="75-41 拜占庭&amp;非拜占庭"><img src="/img/6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="75-41 拜占庭&amp;非拜占庭"/></a><div class="content"><a class="title" href="/2025/03/25/75-41%20%E6%8B%9C%E5%8D%A0%E5%BA%AD&amp;%E9%9D%9E%E6%8B%9C%E5%8D%A0%E5%BA%AD/" title="75-41 拜占庭&amp;非拜占庭">75-41 拜占庭&amp;非拜占庭</a><time datetime="2025-03-25T12:40:17.000Z" title="发表于 2025-03-25 20:40:17">2025-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/25/75-40%20Raft%E5%8D%8F%E8%AE%AE/" title="75-40 Raft协议"><img src="/img/1.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="75-40 Raft协议"/></a><div class="content"><a class="title" href="/2025/03/25/75-40%20Raft%E5%8D%8F%E8%AE%AE/" title="75-40 Raft协议">75-40 Raft协议</a><time datetime="2025-03-25T12:08:17.000Z" title="发表于 2025-03-25 20:08:17">2025-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/25/75-39%20Kafka/" title="75-39 Kafka"><img src="/img/18.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="75-39 Kafka"/></a><div class="content"><a class="title" href="/2025/03/25/75-39%20Kafka/" title="75-39 Kafka">75-39 Kafka</a><time datetime="2025-03-25T05:08:17.000Z" title="发表于 2025-03-25 13:08:17">2025-03-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/22/75-37%20%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/" title="75-37 虚拟线程"><img src="/img/29.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="75-37 虚拟线程"/></a><div class="content"><a class="title" href="/2025/03/22/75-37%20%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B/" title="75-37 虚拟线程">75-37 虚拟线程</a><time datetime="2025-03-22T05:13:18.000Z" title="发表于 2025-03-22 13:13:18">2025-03-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/22/75-36%20%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="75-36 适配器模式"><img src="/img/9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="75-36 适配器模式"/></a><div class="content"><a class="title" href="/2025/03/22/75-36%20%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" title="75-36 适配器模式">75-36 适配器模式</a><time datetime="2025-03-22T04:50:18.000Z" title="发表于 2025-03-22 12:50:18">2025-03-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/index_img.png);"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">道阻且长</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>