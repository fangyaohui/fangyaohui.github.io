<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>32 JVM | 孤岛</title><meta name="author" content="徐行"><meta name="copyright" content="徐行"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="32 JVM参考资料 一篇文章掌握整个JVM，JVM超详细解析！！！  JVM基础JDK VS JRE VS JVM 概述JVM（Java虚拟机），或称为JDK（Java开发工具包）的一部分，实际上是操作系统上的一个软件，充当着操作系统和Java程序之间的桥梁。JVM是JDK的重要组成部分——其核心模块。Java之所以能够具备跨平台运行的能力，主要得益于JVM。JVM为每一种操作系统都进行了特定的">
<meta property="og:type" content="article">
<meta property="og:title" content="32 JVM">
<meta property="og:url" content="http://example.com/2025/02/26/32%20JVM/index.html">
<meta property="og:site_name" content="孤岛">
<meta property="og:description" content="32 JVM参考资料 一篇文章掌握整个JVM，JVM超详细解析！！！  JVM基础JDK VS JRE VS JVM 概述JVM（Java虚拟机），或称为JDK（Java开发工具包）的一部分，实际上是操作系统上的一个软件，充当着操作系统和Java程序之间的桥梁。JVM是JDK的重要组成部分——其核心模块。Java之所以能够具备跨平台运行的能力，主要得益于JVM。JVM为每一种操作系统都进行了特定的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/18.png">
<meta property="article:published_time" content="2025-02-26T10:58:17.000Z">
<meta property="article:modified_time" content="2025-03-05T15:01:03.393Z">
<meta property="article:author" content="徐行">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/18.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "32 JVM",
  "url": "http://example.com/2025/02/26/32%20JVM/",
  "image": "http://example.com/img/18.png",
  "datePublished": "2025-02-26T10:58:17.000Z",
  "dateModified": "2025-03-05T15:01:03.393Z",
  "author": [
    {
      "@type": "Person",
      "name": "徐行",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/02/26/32%20JVM/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '32 JVM',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">114</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">81</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/18.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">孤岛</span></a><a class="nav-page-title" href="/"><span class="site-name">32 JVM</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">32 JVM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-26T10:58:17.000Z" title="发表于 2025-02-26 18:58:17">2025-02-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-05T15:01:03.393Z" title="更新于 2025-03-05 23:01:03">2025-03-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/JVM/">JVM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">9.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>28分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="32-JVM"><a href="#32-JVM" class="headerlink" title="32 JVM"></a>32 JVM</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43122090/article/details/105093777?ops_request_misc=%7B%22request_id%22:%22171774851216800185892837%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=171774851216800185892837&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-105093777-null-null.142%5Ev100%5Epc_search_result_base1&utm_term=JVM&spm=1018.2226.3001.4187">一篇文章掌握整个JVM，JVM超详细解析！！！</a></li>
</ol>
<h2 id="JVM基础"><a href="#JVM基础" class="headerlink" title="JVM基础"></a>JVM基础</h2><h3 id="JDK-VS-JRE-VS-JVM"><a href="#JDK-VS-JRE-VS-JVM" class="headerlink" title="JDK VS JRE VS JVM"></a>JDK VS JRE VS JVM</h3><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261943455.png" alt="img"></p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JVM（Java虚拟机），或称为JDK（Java开发工具包）的一部分，实际上是操作系统上的一个软件，充当着操作系统和Java程序之间的桥梁。JVM是JDK的重要组成部分——其核心模块。Java之所以能够具备跨平台运行的能力，主要得益于JVM。JVM为每一种操作系统都进行了特定的适配，负责将Java字节码转换为该操作系统所特定的二进制代码，从而实现跨平台运行。</p>
<p>接下来，我们主要探讨一下JVM所实现的功能。从上述内容可以看出，JVM的主要职责是处理字节码，将字节码转换为相应的机器码并执行。此外，它还负责运行Java程序，而程序运行离不开特定的运行机制。程序运行时也需要数据支持，因此需要对这些数据进行存储和管理。基于这些需求，JVM的功能可以分为三个重要模块：类加载器、执行引擎和运行时数据区。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261943404.png" alt="image-20240923114242866"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261943719.png" alt="image-20240923114402591"></p>
<p>整个JVM就是一个厨房，字节码就是食材，JVM需要把字节码加工运行成所需要的样子。谁来处理食材呢——类加载器，它负责处理字节码文件，并把该字节码文件加载到运行时数据区（存放在厨房内，准备做菜）。</p>
<p>接下来厨师上场——执行引擎，负责运行该字节码，但是因为每个厨房工具不一样，所以执行引擎会把字节码翻译成对应的机器码文件从而成功运行。</p>
<h2 id="JVM运行数据区"><a href="#JVM运行数据区" class="headerlink" title="JVM运行数据区"></a>JVM运行数据区</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>JVM会划定这个厨房的大小，所有数据都会存放在这个厨房内，也会有保洁阿姨（垃圾回收机制）来清理不需要用的食材（过期无用数据），如果这个厨房保存不了食材了，厨师都无法操作运行了，就会报（OutOfMemoryError 异常）很显然内存泄漏啦。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261943697.png" alt="image-20240923203754763"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261943596.png" alt="img"></p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202503052301817.png" alt="image-20250305230101760"></p>
<h3 id="2-1-方法区（Method-Area）"><a href="#2-1-方法区（Method-Area）" class="headerlink" title="2.1 方法区（Method Area）"></a>2.1 方法区（Method Area）</h3><p>方法区是所有线程共享的内存区域，它用于存储已被Java虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码等数据</strong>。</p>
<p>它有个别为叫Non-Heap（非堆）。当方法区无法满足内存分配需求时，抛出OutOfMemoryError异常。</p>
<h3 id="2-2-Java堆（Java-Heap）"><a href="#2-2-Java堆（Java-Heap）" class="headerlink" title="2.2 Java堆（Java Heap）"></a>2.2 Java堆（Java Heap）</h3><p>java堆是java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例。</strong></p>
<p>在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。</p>
<p>java堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”。</p>
<p>从内存回收角度来看java堆可分为：新生代和老生代。</p>
<p>从内存分配的角度看，线程共享的Java堆中可能划分出多个线程私有的分配缓冲区。</p>
<p>无论怎么划分，都与存放内容无关，无论哪个区域，存储的都是对象实例，进一步的划分都是为了更好的回收内存，或者更快的分配内存。</p>
<p>根据Java虚拟机规范的规定，java堆可以处于物理上不连续的内存空间中。当前主流的虚拟机都是可扩展的（通过 -Xmx 和 -Xms 控制）。如果堆中没有内存可以完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<h3 id="2-3-程序计数器（Program-Counter-Register）"><a href="#2-3-程序计数器（Program-Counter-Register）" class="headerlink" title="2.3 程序计数器（Program Counter Register）"></a>2.3 程序计数器（Program Counter Register）</h3><p>程序计数器是一块较小的内存空间，它可以看作是：<strong>保存当前线程所正在执行的字节码指令的地址(行号)</strong></p>
<p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，一个处理器都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储。称之为“线程私有”的内存。程序计数器内存区域是虚拟机中唯一没有规定OutOfMemoryError情况的区域。</p>
<h3 id="2-4-Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#2-4-Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="2.4 Java虚拟机栈（Java Virtual Machine Stacks）"></a>2.4 Java虚拟机栈（Java Virtual Machine Stacks）</h3><p>java虚拟机是线程私有的，它的生命周期和线程相同。</p>
<p>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p>
<p>解释：每虚拟机栈中是有单位的，单位就是栈帧，一个方法一个栈帧。一个栈帧中他又要存储，局部变量，操作数栈，动态链接，出口等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261943063.png" alt="img"></p>
<h3 id="2-5-本地方法栈（Native-Method-Stack）"><a href="#2-5-本地方法栈（Native-Method-Stack）" class="headerlink" title="2.5 本地方法栈（Native Method Stack）"></a>2.5 本地方法栈（Native Method Stack）</h3><p>本地方法栈很好理解，他很栈很像，只不过方法上带了 native 关键字的栈字</p>
<p>它是虚拟机栈为虚拟机执行Java方法（也就是字节码）的服务</p>
<p>native关键字的方法是看不到的，必须要去oracle官网去下载才可以看的到，而且native关键字修饰的大部分源码都是C和C++的代码。</p>
<p>同理可得，本地方法栈中就是C和C++的代码</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261943516.png" alt="img"></p>
<h2 id="类的加载过程详解"><a href="#类的加载过程详解" class="headerlink" title="类的加载过程详解"></a>类的加载过程详解</h2><h3 id="参考资料-1"><a href="#参考资料-1" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_42638946/article/details/113698017?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171946924916800182126457%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171946924916800182126457&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-113698017-null-null.142%5Ev100%5Epc_search_result_base1&utm_term=Java%E7%B1%BB%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F&spm=1018.2226.3001.4187">第20章 类的加载过程详解</a></li>
<li></li>
</ol>
<h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>从上面的概述中我们了解到，对于JVM虚拟机来说，字节码文件就是这个厨房所需要加工的各种食材以及加工说明书，JVM需要按照要求完成说明书上的内容后得到对应的菜品。</p>
<p>那么这里我们先来看看接收食材的这位负责人（类加载器）是如何把这些食材接收到厨房内的。</p>
<p>下面是该负责人的工作流程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261943059.png" alt="image-20240923190314725"></p>
<p>类加载器如上图所示：类被类加载器接收后，到成为无效数据被清理一共会经历类加载器的七个阶段，也是类的七个阶段：加载、验证、准备、解析、初始化、使用和卸载。其中验证、准备和解析被称为连接。</p>
<p>接下来我们跟随食材（类）和类加载器的视角来看看它们是如何工作的。</p>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>你可以把自己想象成一个包裹（类），其中包含了各种食材（数据）和食材操作说明（方法）。某一天，你被一个陌生人（应用）丢给了面前这个守门人（类加载器）。这个守门人负责管理进入这个神奇厨房（JVM）的所有包裹。</p>
<p>它打开了你，发现你内部的数据形式五花八门，有些是 <code>.class</code> 文件，有些是 <code>.jar</code> 包，甚至可能是通过网络获取的数据。然而，这些数据不能以原始的形式直接进入厨房。于是，它会将这些数据转换为统一的格式（即二进制字节流），以确保它们符合厨房的标准。</p>
<p>接着，类加载器允许你进入厨房，但它并没有就此离开，还会一直跟着你，因为你在进入厨房后需要进一步的处理和验证。</p>
<p>与此同时，你发现一个与你几乎一模一样的影子（<code>java.lang.Class</code> 对象）伴随着你出现。这个影子是为了后续的反射操作准备的，它会在厨房的工作过程中起到重要作用。</p>
<p>经过层层检查，你终于被允许进入厨房，实际上就是进入了操作系统分配给 JVM 的内存区域，等待着进一步的处理和执行。</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>接下来，你被分配到了厨房中的一个房间。你稍作等待，类加载器（JVM 的守门人）推门而入，开始对你进行详细检查。它仔细审视你的每一个包裹，核查其中被加工过的字节码文件是否符合厨房的规定，确保没有混乱无序的“食材”（数据）进入下一步操作。</p>
<p>接着，类加载器会检查你的操作说明书（方法）。首先，它会核对访问控制关键字，确保你只能访问你有权访问的字段和方法。然后，它会仔细检查你是否按规定操作，确保方法调用时参数的个数和类型正确无误。</p>
<p>类加载器还会进一步检查你在说明书中使用的“食材”（变量）是否存在，即是否已经正确初始化。此外，它会确保你使用的每一项食材都是正确的类型，保证变量被赋予了合适的值。</p>
<p>总的来说，类加载器会对你的数据和方法进行全面的验证，确保一切都符合规范，才能允许你进入厨房的下一阶段。</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>你刚刚送走了类加载器，接下来的日子里，房间里一片寂静，时间似乎停滞了一般，不分昼夜地流逝着。等待仿佛无止境。某一天，你实在忍不住困意，倒头便睡。突然，门被一脚踹开，震得墙壁嗡嗡作响，类加载器带着一群小弟（类加载器的内部机制）气势汹汹地挤进了你的房间。</p>
<p>他们二话不说就开始翻找你的包裹，像是在急切地寻找什么重要的食材（这里代表类中的静态变量）。你还没来得及反应，屋里已经热闹非凡，各种翻找声此起彼伏。突然，一个小弟大喊：“找到了！”你吓了一跳，睁眼一看，他手里正拿着一个标记了 <code>static</code> 的类变量。随后，陆陆续续其他小弟也纷纷找到了类似的标记。</p>
<p>类加载器谨慎地登记下这些变量，接着他打开了房间一角的冰箱（JVM 的方法区或内存区域），你看到他们把这些静态变量一一放了进去，并为它们分配了地址（此过程对应 JVM 中的静态变量内存分配）。不过，这些变量还都是未经处理的原材料，没有经过任何的加工和初始化（此时 <code>static</code> 变量只是分配了空间，未初始化）。</p>
<p>你望着冰箱，突然注意到，里面竟然已经有了一些食材，而且这些食材已经根据说明书（程序中的字节码）被提前加工好了。你非常好奇：这些食材是何时被处理的？</p>
<p>一边忙碌的小弟正好经过，你赶紧凑上去打听情况。他看了看你，轻声解释道：“那些已经加工好的食材，是被 <code>static final</code> 修饰的常量。在类加载时，它们就已经完成了加工（此过程是 <code>static final</code> 变量的初始化，在类加载的准备阶段完成），所以你现在看到的是它们的最终状态。而那些只是 <code>static</code> 的变量，刚才只是分配了空间，还需要在后续被初始化。”</p>
<p>你似懂非懂地点了点头，虽然不完全理解，但你知道这些食材确实很重要。类加载器和他的小弟们忙活了一阵子后，带着一丝匆忙离开了房间，显然他们要去处理下一个包裹了（这代表类加载器完成了一个类的加载，接下来处理其他类的加载）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261943407.png" alt="image-20240923194750824"></p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th>默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td>(byte)0</td>
</tr>
<tr>
<td align="center">short</td>
<td>(short)0</td>
</tr>
<tr>
<td align="center">int</td>
<td>0</td>
</tr>
<tr>
<td align="center">long</td>
<td>0L</td>
</tr>
<tr>
<td align="center">float</td>
<td>0.0f</td>
</tr>
<tr>
<td align="center">double</td>
<td>0.0</td>
</tr>
<tr>
<td align="center">char</td>
<td>\u0000</td>
</tr>
<tr>
<td align="center">boolean</td>
<td>false</td>
</tr>
<tr>
<td align="center">reference</td>
<td>null</td>
</tr>
</tbody></table>
<p>注意：</p>
<ol>
<li>这里不包含基本数据类型的字段用static final修饰的情况，因为final在编译的时候就会分配了，准备阶段会显式赋值。</li>
<li>注意这里不会为实例变量初始化，类变量会分配在方法区中，而实例变量会随着对象一起分配到Java堆中。</li>
<li>在这个阶段并不会像初始化阶段中那样会有初始化或者代码执行。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过程二：链接阶段（以下都是针对static修饰的变量）</span></span><br><span class="line"><span class="comment"> * 基本数据类型：非 final 修饰的变量，在准备环节进行默认初始化赋值。</span></span><br><span class="line"><span class="comment"> *             final修饰以后，在准备环节直接进行显示赋值。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 拓展：如果使用字面量的方式定义一个字符串的常量的话，也是在准备环节直接进行显示赋值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkingTest</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> id;  <span class="comment">// 默认初始化赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;  <span class="comment">// 显示赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">constStr</span> <span class="operator">=</span> <span class="string">&quot;CONST&quot;</span>;  <span class="comment">// 显示赋值</span></span><br><span class="line"><span class="comment">//    public static final String constStr1 = new String(&quot;CONST&quot;);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>在加载的过程中会将那些static final修饰的常量加载到常量池中，但是在类中表示的还是其直接的符号，没有对应到该常量对应的地址，所以这步需要将类中的那些常量把符号应用一律改成直接引用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261943225.png" alt="image-20240923201009650"></p>
<p>虚拟机常量池的符号引用替换为字节引用过程。</p>
<p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行大量的符号引用。但是在程序实际运行时，只有符号引用时不够的。比如当如下println()方法被调用时，系统需要明确知道该方法的位置。</p>
<blockquote>
<p>从准备阶段可以看出，类的静态变量在类加载、验证符合JVM规范后就会开始分配内存并设定变量初始值，这些值都会保存在方法区中。</p>
</blockquote>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>初始化就是要为那些在之前没有被初始化的static类变量进行初始化，什么时候会进行初始化呢：</p>
<p><strong>总结就是</strong>：初始化是为类的静态变量赋予正确的初始值。使用static + final修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类型或String类型的显式赋值，是在链接阶段的准备环节进行。对于类变量来说，如果加了 final，才有可能在链接的准备阶段 被显式赋值；但是如果没加final，一定不可能在链接的准备阶段 被显式赋值，而是在链接的准备阶段 默认赋值，然后在初始化阶段显式赋值。</p>
<p><strong>说明：</strong></p>
<p>在加载一个类之前，虚拟机总会试图加载该类的父类，因此父类的<clinit> 总是在子类 <clinit> 之前被调用。也就是说，父类的static块优先级高于子类。</p>
<p><strong>口诀：由父及子，静态先行</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InitializationTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        number = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;father static&#123;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubInitialization</span> <span class="keyword">extends</span> <span class="title class_">InitializationTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        number = <span class="number">4</span>;  <span class="comment">// number属性必须提前已经加载：一定会先加载父类。</span></span><br><span class="line">        System.out.println(<span class="string">&quot;son static&#123;&#125;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p><strong>作用</strong>：负责将.class文件（存储的物理文件）加载在到内存中。通过加载<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E5%AD%97%E8%8A%82%E7%A0%81&spm=1001.2101.3001.7020">字节码</a>数据放入内存转换成byte[]，接下来调用虚拟机底层方法将byte[]转换成方法区和堆中的数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261943658.png" alt="image-20240923202615805"></p>
<p>简单来说就是加载类的字节码文件到内存中，并转换成字节流。</p>
<p>类加载器分为下面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261943573.png" alt="image-20240923202728419"></p>
<h3 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h3><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261944161.png" alt="image-20240923203004469"></p>
<p>因为类加载器存在多个，所以一个类需要加载的时候，如何选择哪个类加载器进行加载呢？这里的策略就是双亲委派机制，就是子类不先自己加载，请子类的父类加载器进行加载，然后一直递归知道最上层，如果父类无法加载该类，则由子类自行加载。</p>
<p>那么为什么需要使用这种策略呢？如果直接让子类自己加载会出现什么问题呢？如果直接从子类进行加载，那么就会出现同一个类就可能会出现使用的不同的类加载器加载，这样就导致同一个类却不想等。但是双亲委派机制可以避免这个问题，无论你使用哪个类加载器，其最后都会优先向上层的类加载器加载，可以有效的避免这个问题。</p>
<h2 id="JVM的垃圾回收机制"><a href="#JVM的垃圾回收机制" class="headerlink" title="JVM的垃圾回收机制"></a>JVM的垃圾回收机制</h2><h3 id="参考资料-2"><a href="#参考资料-2" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_35246620/article/details/80522720?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171947954116800184145363%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=171947954116800184145363&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-80522720-null-null.142%5Ev100%5Epc_search_result_base1&utm_term=JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6&spm=1018.2226.3001.4187">深入理解 JVM 垃圾回收机制及其实现原理</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/ISIOd8bD0b3ZzpHGqXCe2g">【不做标题党】Java虚拟机何谓垃圾及垃圾回收算法</a></li>
<li></li>
</ol>
<h3 id="垃圾"><a href="#垃圾" class="headerlink" title="垃圾"></a>垃圾</h3><h4 id="什么是垃圾"><a href="#什么是垃圾" class="headerlink" title="什么是垃圾"></a>什么是垃圾</h4><p>在 JVM 进行垃圾回收之前，首先就是判断哪些对象是垃圾，也就是说，要判断哪些对象是可以被销毁的，其占有的空间是可以被回收的。根据 JVM 的架构划分，我们知道， 在 Java 世界中，几乎所有的对象实例都在堆中存放，所以垃圾回收也主要是针对堆来进行的。</p>
<p>在 JVM 的眼中，垃圾就是指那些在堆中存在的，已经“死亡”的对象。而对于“死亡”的定义，我们可以简单的将其理解为“<strong>不可能再被任何途径使用的对象</strong>”。那怎样才能确定一个对象是存活还是死亡呢？这就涉及到了垃圾判断算法，其主要包括引用计数法和可达性分析法。</p>
<h4 id="垃圾判断算法"><a href="#垃圾判断算法" class="headerlink" title="垃圾判断算法"></a>垃圾判断算法</h4><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>在这种算法中，假设堆中每个对象（不是引用）都有一个<strong>引用计数器</strong>。当一个对象被创建并且初始化赋值后，该对象的计数器的值就设置为 1，每当有一个地方引用它时，计数器的值就加 1，例如将对象 b 赋值给对象 a，那么 b 被引用，则将 b 引用对象的计数器累加 1。</p>
<p>反之，当引用失效时，例如一个对象的某个引用超过了生命周期（出作用域后）或者被设置为一个新值时，则之前被引用的对象的计数器的值就减 1。而那些引用计数为 0 的对象，就可以称之为垃圾，可以被收集。</p>
<p>特别地，当一个对象被当做垃圾收集时，它引用的任何对象的计数器的值都减 1。</p>
<ol>
<li>优点：引用计数法实现起来比较简单，对程序不被长时间打断的实时环境比较有利。</li>
<li>缺点：需要额外的空间来存储计数器，难以检测出对象之间的循环引用。</li>
</ol>
<h5 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h5><p>可达性分析法也被称之为根搜索法，可达性是指，<strong>如果一个对象会被至少一个在程序中的变量通过直接或间接的方式被其他可达的对象引用，则称该对象就是可达的</strong>。更准确的说，一个对象只有满足下述两个条件之一，就会被判断为可达的：</p>
<ul>
<li>对象是属于根集中的对象</li>
<li>对象被一个可达的对象引用</li>
</ul>
<p>在这里，我们引出了一个专有名词，即根集，其是指正在执行的 Java 程序可以访问的引用变量（注意，不是对象）的集合，程序可以使用引用变量访问对象的属性和调用对象的方法。<strong>在 JVM 中，会将以下对象标记为根集中的对象</strong>，具体包括：</p>
<ol>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中的常量引用的对象	</li>
<li>方法区中的类静态属性引用的对象</li>
<li>本地方法栈中 JNI（Native 方法）的引用对象</li>
<li>活跃线程（已启动且未停止的 Java 线程）</li>
</ol>
<p>根集中的对象称之为<code>GC Roots</code>，也就是根对象。可达性分析法的基本思路是：将一系列的根对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，如果一个对象到根对象没有任何引用链相连，那么这个对象就不是可达的，也称之为不可达对象。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261944033.png" alt="img"></p>
<p>开始进行标记前，需要先暂停应用线程，否则如果对象图一直在变化的话是无法真正去遍历它的。暂停应用线程以便 <strong>JVM 可以尽情地收拾家务的这种情况又被称之为安全点（Safe Point）</strong>，这会触发一次 Stop The World（STW）暂停。触发安全点的原因有许多，但最常见的应该就是垃圾回收了。</p>
<p>安全点的选定基本上是以程序“<strong>是否具有让程序长时间执行的特征</strong>”为标准进行选定的。“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生安全点。对于安全点，另一个需要考虑的问题就是如何在 GC 发生时让所有线程（这里不包括执行 JNI 调用的线程）都“跑”到最近的安全点上再停顿下来。两种解决方案：</p>
<ol>
<li>抢先式中断（Preemptive Suspension）：抢先式中断不需要线程的执行代码主动去配合，在 GC 发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机采用这种方式来暂停线程从而响应 GC 事件。</li>
<li><strong>主动式中断</strong>（Voluntary Suspension）：主动式中断的思想是当 GC 需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。<strong>轮询标志地地方和安全点是重合的，另外再加上创建对象需要分配内存的地方</strong>。</li>
</ol>
<p>**暂停时间的长短并不取决于堆内对象的多少也不是堆的大小，而是存活对象的多少。**因此，调高堆的大小并不会影响到标记阶段的时间长短。</p>
<p>在根搜索算法中，要真正宣告一个对象死亡，至少要经历两次标记过程：</p>
<ol>
<li><strong>如果对象在进行根搜索后发现没有与根对象相连接的引用链，那它会被第一次标记并且进行一次筛选</strong>。筛选的条件是此对象是否有必要执行 finalize()方法（可看作析构函数，类似于 OC 中的dealloc，Swift 中的deinit）。当对象没有覆盖finalize()方法，或finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。</li>
<li>**如果该对象被判定为有必要执行finalize()方法，那么这个对象将会被放置在一个名为F-Queue的队列中，并在稍后由一条由虚拟机自动建立的、低优先级的Finalizer线程去执行finalize()方法。**finalize()方法是对象逃脱死亡命运的最后一次机会（因为一个对象的finalize()方法最多只会被系统自动调用一次），稍后 GC 将对F-Queue中的对象进行第二次小规模的标记，如果要在finalize()方法中成功拯救自己，只要在finalize()方法中让该对象重新引用链上的任何一个对象建立关联即可。而如果对象这时还没有关联到任何链上的引用，那它就会被回收掉。</li>
</ol>
<p>GC 判断对象是否可达看的是强引用。</p>
<p>当标记阶段完成后，GC 开始进入下一阶段，删除不可达对象。当然，可达性分析法有优点也有缺点，</p>
<ul>
<li><strong>优点</strong>：可以解决循环引用的问题，不需要占用额外的空间</li>
<li><strong>缺点</strong>：多线程场景下，其他线程可能会更新已经访问过的对象的引用</li>
</ul>
<p>在上面的介绍中，我们多次提到了“引用”这个概念，在此我们不妨多了解一些引用的知识，在 Java 中有四种引用类型，分别为：</p>
<ol>
<li>强引用（Strong Reference）：如Object obj &#x3D; new Object()，这类引用是 Java 程序中最普遍的。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>软引用（Soft Reference）：它用来描述一些可能还有用，但并非必须的对象。在系统内存不够用时，这类引用关联的对象将被垃圾收集器回收。JDK1.2 之后提供了SoftReference类来实现软引用。</li>
<li>弱引用（Weak Reference）：它也是用来描述非必须对象的，但它的强度比软引用更弱些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 JDK1.2 之后，提供了WeakReference类来实现弱引用。</li>
<li>虚引用（Phantom Reference）：也称为幻引用，最弱的一种引用关系，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的是希望能在这个对象被收集器回收时收到一个系统通知。JDK1.2 之后提供了PhantomReference类来实现虚引用。</li>
</ol>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>主机的内存空间是有限的，如果不能及时的清理掉内存中无用的信息，那么内存很快就会爆满，导致服务出现严重的问题。对于其他的语言来说，例如C、C++等都需要程序员自己进行垃圾回收。Java使用JVM来替程序员来管理主机的内存空间，那么既然JVM已经替我们管理内存空间了，那为什么还需要去学习JVM是如何回收垃圾的呢？</p>
<blockquote>
<p>在我看来，这是因为我们在实际的业务开发中，可能会遇到JVM报内存不够的错误，当我们了解了JVM是如何进行垃圾回收时，对于我们去分析问题有很大的帮助，也能够让我们在实际的开发中快速排查和解决问题。</p>
<p>同时另一方面，去了解一款好的产品是如何设计的，中间使用的哪些算法，那些算法对于解决特定的问题有什么样的效果，对于程序员的我们来说，这些都是非常宝贵的学习机会。</p>
</blockquote>
<p>通过上面的介绍，我们已经知道了什么是垃圾以及如何判断一个对象是否是垃圾。那么接下来，我们就来了解如何回收垃圾，这就是垃圾回收算法和垃圾回收器需要做的事情了。</p>
<p>PS：如果我们把内存看成一块大的四边形区域，区域中画了很多大小相同的小方格，在每个小方格中会存放一些物品（数据），现在有一个管理员负责管理这片区域（管理员JVM）。那么如果你是这个管理员你会如何管理这片区域不至于被物品塞满呢？</p>
<p>这片区域随时都会有物品放进来，那么你作为管理员管理这片区域时就很困难去进行管理。这时候你向领导要求当你对这片区域清理时不允许任何物品放进来，这就是JVM中的安全点的概念。</p>
<h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>管理员想到了一种方法，他想如果我找到一个无用的物品就跑到很远的地方把这个丢了再回来中间的耗时太大了（在JVM中切换消耗较大），那么他就想如果我先把所有无效的物品标记出来，然后让车一把全部拉走且不快速。这就是标记-清楚算法，分为两步，先标记出无效的物品，然后统一清除。</p>
<p>标记-清除（Mark-Sweep）算法可以分为两个阶段：</p>
<ul>
<li>标记阶段：<strong>标记出所有可以回收的对象</strong>。</li>
<li>清除阶段：回收所有已被标记的对象，释放这部分空间。</li>
</ul>
<p>该算法存在如下不足：</p>
<ol>
<li><strong>内存碎片</strong>。由于Java虚拟机的堆中对象必须是连续分布的，因此可能出现总空闲内存足够，但是无法分配的极端情况。无法找到足够的连续内存，而不得不提前触发一次垃圾收集动作。</li>
<li><strong>分配效率较低</strong>。如果是一块连续的内存空间，那么我们可以通过指针加法（pointer bumping）来做分配。而对于空闲列表，Java虚拟机则需要逐个访问列表中的项，来查询能够放入新建对象的空闲内存。</li>
</ol>
<p>PS：因为在内存区域中每一个小方格的大小是固定的，如果现在有一个很大的物品，需要几十个小方格才能装下，而且我们不能把这个物品给分割（Java虚拟机的堆中对象必须是连续分布的），这时候我们没有十几个连续的小方格怎么办？</p>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决标记-清楚算法导致无较大的内存区域保存数据，即导致大量的内存碎片问题，你提出来一个新的算法——复制算法。你创造性的提出，把现在的区域再分成两个大的区域，任何时候只有一个区域工作，等你需要整理时，你会进入当前工作的那个区域，标记出当前有用的物品，复制到另外一个区域中，然后把当前区域所有物品全部清楚，让另外一个区域运行。注意你复制过去的数据会依次排放，所以不会造成内存碎片。</p>
<p>这样虽然解决了内存碎片问题，但很显然消耗也大，效率会降低。</p>
<ul>
<li>划分区域：将内存区域按比例划分为1个Eden区作为分配对象的“主战场”和2个幸存区（即Survivor空间，划分为2个等比例的from区和to区）。</li>
<li>复制：收集时，打扫“战场”，将Eden区中仍存活的对象复制到某一块幸存区中。</li>
<li>清除：由于上一阶段已确保仍存活的对象已被妥善安置，现在可以“清理战场”了，释放Eden区和另一块幸存区。</li>
<li>晋升：如在“复制”阶段，一块幸存区接纳不了所有的“幸存”对象。则直接晋升到老年代。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261944999.webp" alt="图片"></p>
<p><strong>该算法解决了内存碎片化问题，但堆空间的使用效率极其低下</strong>。在对象存活率较高时，需要进行较多的复制操作，效率会变得很低。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>为了解决内存碎片化和堆利用率低的问题，你又提出了一个新的算法，该算法在安全点时，你会标记所有的需要回收丢弃的物品，同时会让那些重要的物品去替代废弃物品的位置，目的是为了让存活的物品按顺序排放，这样内存碎片就会大幅度减少。但是由于内存变动频繁，你需要消耗的时间变多了，你需要把原位置的物品搬运到新的位置，中间的消耗的时间比复制算法还要多。</p>
<p>该算法分为两个阶段：</p>
<ul>
<li><strong>标记阶段</strong>：<strong>标记出所有可以回收的对象</strong>。</li>
<li><strong>压缩阶段</strong>：将标记阶段的对象移动到<strong>空间的一端</strong>，释放剩余的空间。</li>
</ul>
<p>该算法的标记过程与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><strong>解决了内存碎片的问题</strong>，<strong>也规避了复制算法只能利用一半内存区域的弊端</strong>。看起来很美好，<strong>但它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多</strong>。</p>
<p>标记-整理算法的示意图如下： </p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261944227.png" alt="图片"></p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>上面的几个算法存在一些让你无法接受的缺点，现在你想想一个好的办法解决这个问题。你认真的思考了前面的几种算法，复制算法导致堆的利用率降低，标记整理算法导致处理的效率降低，那么你想可不可以把这两个结合起来，形成一个新的算法来解决这个问题呢？所以你提出了分代收集算法。</p>
<p>想这种结合几个算法的优点形成一个新的算法的思想在计算机世界中很常用，在之后的学习以及实际工作中要学会使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261944507.webp" alt="图片"></p>
<p>分代收集算法通过把内存区域划分成几块大小不等的区域，我们称为新生代和老年代。</p>
<h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><p>新生代占整个内存区域的三分之一，在新生代中的对象来的快消失的也快，大量的对象创建然后死亡，很少有对象能够一直存活。</p>
<p>在这一片区域我们就可以选择复制算法来复制存活的对象，这样就有效的降低了复制消耗的时间，**但是复制不是会降低这片区域的使用率吗？**或者说这个损失在我们可接受的范围之内？</p>
<h5 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h5><p>如果对象在新生代区域中存活了几轮安全点，那么这个对象就会进入老年代，在老年代中大部分都是持久性对象，少部分对象会进入死亡。像这个需要清除对象较少的区域，我们就可以选择使用标记-清除算法或者标记-整理算法来对死亡对象进行回收。</p>
<h3 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h3><p><strong>Minor GC：</strong></p>
<ul>
<li>针对新生代。</li>
<li>指发生在新生代的垃圾收集动作，因为java对象大多都具备<strong>朝生夕死</strong>的特性，所以<strong>Minor GC非常频繁</strong>，一般回收速度也比较快。</li>
<li>触发条件：Eden空间满时。</li>
</ul>
<p><strong>Major GC：</strong></p>
<ul>
<li>针对老年代。</li>
<li>指发生在老年代的GC，出现了Major GC，<strong>经常会伴随至少一次的Minor GC</strong>（但非绝对的，在Parallel Scavenge 收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</li>
<li>触发条件：Minor GC 会将对象移到老年代中，如果此时老年代空间不够，那么触发 Major GC。</li>
</ul>
<p><strong>Full GC：</strong></p>
<ul>
<li>清理整个堆空间。一定意义上Full GC 可以说是 Minor GC 和 Major GC 的结合。</li>
<li>触发条件：调用System.gc()；老年代空间不足；空间分配担保失败。</li>
</ul>
<h2 id="ChatGPT面试题"><a href="#ChatGPT面试题" class="headerlink" title="ChatGPT面试题"></a>ChatGPT面试题</h2><h3 id="Java内存区域和内存溢出异常面试题"><a href="#Java内存区域和内存溢出异常面试题" class="headerlink" title="Java内存区域和内存溢出异常面试题"></a>Java内存区域和内存溢出异常面试题</h3><h3 id="Promote"><a href="#Promote" class="headerlink" title="Promote"></a>Promote</h3><blockquote>
<p>现在假设你是一个经验丰富的JVM面试官，现在你需要针对JVM中内存区域和与内存溢出异常这一主题出一套面试题目，请你不要涉及到其它主题部分，比如垃圾回收等其他现在不需要进行考察的部分，该面试题目难度正常，简单2道，中等5道，困难3道，请你直接给出这个面试题目，要求该这套面试题目可以很好的涵盖JVM这内存管理这一主题，并且符合Java程序员需要掌握的知识点，请你避免出无意义的题目，所有的题目都具有一定的考察价值。注意：请你直接给出面试题目，无需给出答案，我后面会进行回答。</p>
</blockquote>
<h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><blockquote>
<h3 id="简单题"><a href="#简单题" class="headerlink" title="简单题"></a>简单题</h3><ol>
<li>请简述 JVM 的内存区域划分，并说明每个区域的主要作用。  </li>
<li>什么是堆内存和栈内存？两者在使用上的主要区别是什么？</li>
</ol>
<h3 id="中等题"><a href="#中等题" class="headerlink" title="中等题"></a>中等题</h3><ol start="3">
<li>JVM 中方法区的作用是什么？在 JDK 8 中方法区的实现有什么变化？  </li>
<li>什么是直接内存（Direct Memory）？它的分配受什么限制？  </li>
<li>当 JVM 抛出 <code>OutOfMemoryError</code> 时，可能会在哪些内存区域发生？请列举并说明可能的原因。  </li>
<li>在多线程环境下，本地变量存储在哪个内存区域？线程安全性如何保证？  </li>
<li>在 JVM 中如何通过配置调整堆内存大小？分别说明初始堆大小和最大堆大小的配置参数。</li>
</ol>
<h3 id="困难题"><a href="#困难题" class="headerlink" title="困难题"></a>困难题</h3><ol start="8">
<li>当程序中频繁创建大量短生命周期的对象时，可能导致什么问题？如果程序出现了 <code>OutOfMemoryError: Java heap space</code>，该如何进行诊断和优化？  </li>
<li>请描述虚拟机栈溢出（<code>StackOverflowError</code>）的成因，并列举两个常见的引发场景。  </li>
<li>如果程序中需要频繁加载大量类，导致 <code>OutOfMemoryError: Metaspace</code>，你会如何分析和解决这个问题？</li>
</ol>
</blockquote>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JVM/">JVM</a></div><div class="post-share"><div class="social-share" data-image="/img/18.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/02/26/33%20Java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="33 Java设计模式"><img class="cover" src="/img/10.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">33 Java设计模式</div></div><div class="info-2"><div class="info-item-1">33 Java设计模式参考资料 Java之美[从菜鸟到高手演变]之设计模式   概览总体来说设计模式分为三大类： 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 其实还有两类：并发型模式和线程池模式。用一个图片来整体描述一下：  工厂模式普通工厂模式建立一个工厂类，该类会对实现了某一接口的类进行实例化。用户使用这个工具类时，传入需要创建类的类型，然后工厂类创建进行返回。  以这个为例，接口Sender的两个实现类Mail and Sms实现了接口定义的方法，那么在这个接口的工厂类中会这样写： 12345678910111213public class SendFactory &#123; 	public Sender produce(String type) &#123;		if...</div></div></div></a><a class="pagination-related" href="/2025/02/26/34-01%20%E6%95%B0%E6%8D%AE%E5%BA%93-%E8%BE%BE%E6%A2%A6%E6%95%B0%E6%8D%AE%E5%BA%93/" title="34-01 数据库-达梦数据库"><img class="cover" src="/img/2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">34-01 数据库-达梦数据库</div></div><div class="info-2"><div class="info-item-1">34-01 数据库-达梦数据库简介在信息安全日益重要的今天，国内很多部门都要求使用国产化的数据库来替代原先国外的数据库，在这里介绍一款国内较知名的数据库——达梦。 达梦数据库管理系统是达梦公司推出的具有完全自主知识产权的高性能数据库管理系统，简称DM。达梦数据库管理系统7.0版本，简称DM7。 达梦数据库安装这里介绍的是在Windows环境下安装DM数据库。 参考教程：Windows环境安装达梦数据库 按照过程一步一步的进行即可。 默认用户名：SYSDBA 默认密码：SYSDBA Ubuntu环境下安装达梦数据库参考资料：Linux安装达梦数据库&#x2F;DM8（附带客户端工具安装完整版） 创建安装与运行的Linux用户1234567891011121314151617# 1.创建安装用户组 dmsys[root@laizhenghua /]# groupadd dmsys# 2.创建安装用户 dmdba[root@laizhenghua /]# sudo useradd -g dmsys -m -d...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/02/28/75-20%20JIT/" title="75-20 JIT &amp; AOT"><img class="cover" src="/img/20.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-28</div><div class="info-item-2">75-20 JIT &amp; AOT</div></div><div class="info-2"><div class="info-item-1">75-20 JIT &amp; AOTJIT 是什么？JIT（Just-In-Time，即时编译器）是 Java 虚拟机（JVM）中的一项关键优化技术，它的作用是在运行时将字节码编译为机器码，从而提高 Java 程序的执行效率。 传统上，Java 代码的执行流程如下：  Java 源代码（.java） → 通过 Java 编译器（javac） 编译成 字节码（.class）。 字节码 由 JVM 的解释器（Interpreter） 按行解释执行，性能较低。   JIT 编译器的作用就是：  在运行时检测热点代码 将这些热点代码编译为机器码 让后续执行时直接运行机器码，提升性能  JIT 解决了什么问题？JVM 早期执行 Java 代码时，采用解释执行方式：  解释器逐行翻译字节码，转换为 CPU 可以执行的指令。 由于解释执行逐行转换，性能较低，尤其是热点代码需要被重复解释执行。  JIT 编译器引入后：  发现某段代码被**高频执行（热点代码）**时，JIT 会将其编译成机器码。 这样 JVM...</div></div></div></a><a class="pagination-related" href="/2025/02/26/01-%E4%BD%BF%E7%94%A8docker-compose%E5%AE%89%E8%A3%85ElasticSearch%E5%92%8Ckibana/" title="01 使用docker-compose安装ElasticSearch和kibana"><img class="cover" src="/img/8.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-26</div><div class="info-item-2">01 使用docker-compose安装ElasticSearch和kibana</div></div><div class="info-2"><div class="info-item-1">01 使用docker-compose安装ElasticSearch和kibanaES安装首先我们需要创建一个docker-compose.yml文件，内容如下： 123456789101112131415version: &#x27;3&#x27;services:  elasticsearch:    image: elasticsearch:7.7.0  #镜像    container_name: elk_elasticsearch  #定义容器名称    restart: always  #开机启动，失败也会一直重启    environment:      - &quot;cluster.name=elasticsearch&quot; #设置集群名称为elasticsearch      - &quot;discovery.type=single-node&quot; #以单一节点模式启动      - &quot;ES_JAVA_OPTS=-Xms512m -Xmx1024m&quot; #设置使用jvm内存大小    volumes:      -...</div></div></div></a><a class="pagination-related" href="/2025/02/26/02%20Nexus/" title="02 Nexus"><img class="cover" src="/img/20.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-26</div><div class="info-item-2">02 Nexus</div></div><div class="info-2"><div class="info-item-1">02 Nexus要介绍Nexus前，我们得先了解一下什么是Maven私服。 1 Maven私服Maven私服是一种特殊的Maven仓库，它是架设在局域网内的仓库服务，用来代理位于外部的远程仓库（中央仓库、其他远程公共仓库）。  从上面的图中可以看出，当需要某个组件时。会优先从maven私服中获取，如果Maven私服中不存在则会请求外部的远程仓库。 2...</div></div></div></a><a class="pagination-related" href="/2025/02/26/04%20Prometheus+Grafana%E7%9B%91%E6%8E%A7SpringBoot%E9%A1%B9%E7%9B%AEJVM%E4%BF%A1%E6%81%AF/" title="04 Prometheus+Grafana监控SpringBoot项目JVM信息"><img class="cover" src="/img/7.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-26</div><div class="info-item-2">04 Prometheus+Grafana监控SpringBoot项目JVM信息</div></div><div class="info-2"><div class="info-item-1">04 Prometheus+Grafana监控SpringBoot项目JVM信息1 使用docker-compose配置Prometheus&amp;Grafana 确保本地安装了dockers&amp;docker-compose; 在本机创建一个文件夹，自行命名。 在该文件夹下创建如下：    prometheus.yml文件内容如下：  12345678910111213# my global configglobal:  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.  # scrape_timeout is set to the global default (10s).# A scrape configuration containing...</div></div></div></a><a class="pagination-related" href="/2025/02/26/05%20%E5%9F%BA%E4%BA%8EPrometheus%E5%92%8CGrafana%E5%AF%B9%20CPU%E5%86%85%E5%AD%98%E4%BB%A5%E5%8F%8A%E5%8A%A0%E6%B2%B9%E7%AB%99%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8CJVM%E7%9B%91%E6%8E%A7/" title="05 基于Prometheus和Grafana对 CPU内存以及加油站微服务进行JVM监控"><img class="cover" src="/img/11.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-26</div><div class="info-item-2">05 基于Prometheus和Grafana对 CPU内存以及加油站微服务进行JVM监控</div></div><div class="info-2"><div class="info-item-1">05 基于Prometheus和Grafana对 CPU内存以及加油站微服务进行JVM监控简介关于这个任务，我进行了很多天，断断续续的也算基本完成。在这里记录一下关于这个任务遇到的一些问题以。先看一下效果图：  Windows环境下对CPU、内存等信息进行监控    加油站微服务JVM监控    Windows本地环境下对MySQL进行监控    Windows本地环境下对Redis进行监控   grafana图表模板号：  JVM模板号：4701 CPU硬件模板号：10467 MySQL模板号：7362 Redis模板号：763  Windows环境下对CPU等信息进行监控在之前进行配置时，我并没有添加node-exporter这个，docker-compose.yml文件中时如下内容： 1234567891011121314151617181920# docker-compose.ymlversion: &#x27;3&#x27;services:  prometheus:    image: prom/prometheus:latest    command:     ...</div></div></div></a><a class="pagination-related" href="/2025/02/26/07%20Docker/" title="07 Docker"><img class="cover" src="/img/20.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-02-26</div><div class="info-item-2">07 Docker</div></div><div class="info-2"><div class="info-item-1">07 Docker什么是Docker当我们谈论 Docker 时，你可以把它想象成一个巨大的、现代化的海运集装箱。这些集装箱可以装载各种各样的货物，从家具到电子设备再到食品，都可以放进去。而 Docker 则是一种类似于这样的集装箱，但是它装载的不是实物货物，而是软件应用程序及其所有必要的组件。 现在，让我们进一步解释一下这个类比。想象一下，你正在开发一个新的软件应用程序，它需要依赖于特定的操作系统、程序库和其他软件组件。在以前，为了确保你的应用程序在不同的计算机环境中能够正常运行，你可能需要手动安装和配置所有这些组件，这就像是把家具逐个放进货舱里，需要大量的时间和精力。 但是，有了 Docker，情况就完全不同了。你可以把你的应用程序和所有它需要的组件都放进一个 Docker 集装箱中。这个集装箱包括了你的应用程序、操作系统、程序库、配置文件等等，就像是把所有的货物都装进了一个标准化的集装箱里面一样。 更棒的是，Docker 集装箱是标准化的，这意味着它们可以在任何支持 Docker...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">徐行</div><div class="author-info-description">道阻且长</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">114</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">81</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/fangyaohui"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#32-JVM"><span class="toc-number">1.</span> <span class="toc-text">32 JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.1.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">JVM基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK-VS-JRE-VS-JVM"><span class="toc-number">1.2.1.</span> <span class="toc-text">JDK VS JRE VS JVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.2.</span> <span class="toc-text">概述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E8%BF%90%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%8C%BA"><span class="toc-number">1.3.</span> <span class="toc-text">JVM运行数据区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88Method-Area%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.1 方法区（Method Area）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Java%E5%A0%86%EF%BC%88Java-Heap%EF%BC%89"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.2 Java堆（Java Heap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%88Program-Counter-Register%EF%BC%89"><span class="toc-number">1.3.4.</span> <span class="toc-text">2.3 程序计数器（Program Counter Register）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%EF%BC%88Java-Virtual-Machine-Stacks%EF%BC%89"><span class="toc-number">1.3.5.</span> <span class="toc-text">2.4 Java虚拟机栈（Java Virtual Machine Stacks）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88%EF%BC%88Native-Method-Stack%EF%BC%89"><span class="toc-number">1.3.6.</span> <span class="toc-text">2.5 本地方法栈（Native Method Stack）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.4.</span> <span class="toc-text">类的加载过程详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">1.4.2.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">验证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">解析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">初始化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.4.</span> <span class="toc-text">双亲委派机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">JVM的垃圾回收机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-2"><span class="toc-number">1.5.1.</span> <span class="toc-text">参考资料</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE"><span class="toc-number">1.5.2.</span> <span class="toc-text">垃圾</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9E%83%E5%9C%BE"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">什么是垃圾</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%88%A4%E6%96%AD%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">垃圾判断算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="toc-number">1.5.2.2.1.</span> <span class="toc-text">引用计数法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">1.5.2.2.2.</span> <span class="toc-text">可达性分析法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">垃圾回收</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.1.</span> <span class="toc-text">标记-清除算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.2.</span> <span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.3.</span> <span class="toc-text">标记-整理算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.5.3.4.</span> <span class="toc-text">分代收集算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B0%E7%94%9F%E4%BB%A3"><span class="toc-number">1.5.3.4.1.</span> <span class="toc-text">新生代</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%80%81%E5%B9%B4%E4%BB%A3"><span class="toc-number">1.5.3.4.2.</span> <span class="toc-text">老年代</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC%E5%88%86%E7%B1%BB"><span class="toc-number">1.5.4.</span> <span class="toc-text">GC分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ChatGPT%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">ChatGPT面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.6.1.</span> <span class="toc-text">Java内存区域和内存溢出异常面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promote"><span class="toc-number">1.6.2.</span> <span class="toc-text">Promote</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">1.6.3.</span> <span class="toc-text">面试题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%A2%98"><span class="toc-number">1.6.4.</span> <span class="toc-text">简单题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E7%AD%89%E9%A2%98"><span class="toc-number">1.6.5.</span> <span class="toc-text">中等题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%B0%E9%9A%BE%E9%A2%98"><span class="toc-number">1.6.6.</span> <span class="toc-text">困难题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/31/79-05%20%E6%99%BA%E5%8D%B7%E4%BA%91%E9%97%AE%E9%A2%98%E5%8F%91%E7%8E%B0&amp;%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="79-05 智卷云问题发现&amp;解决方案"><img src="/img/25.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="79-05 智卷云问题发现&amp;解决方案"/></a><div class="content"><a class="title" href="/2025/03/31/79-05%20%E6%99%BA%E5%8D%B7%E4%BA%91%E9%97%AE%E9%A2%98%E5%8F%91%E7%8E%B0&amp;%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="79-05 智卷云问题发现&amp;解决方案">79-05 智卷云问题发现&amp;解决方案</a><time datetime="2025-03-31T07:58:17.000Z" title="发表于 2025-03-31 15:58:17">2025-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/29/79-04%20%E6%99%BA%E5%8D%B7%E4%BA%91%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/" title="79-04 智卷云后端架构设计方案"><img src="/img/2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="79-04 智卷云后端架构设计方案"/></a><div class="content"><a class="title" href="/2025/03/29/79-04%20%E6%99%BA%E5%8D%B7%E4%BA%91%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/" title="79-04 智卷云后端架构设计方案">79-04 智卷云后端架构设计方案</a><time datetime="2025-03-29T07:58:17.000Z" title="发表于 2025-03-29 15:58:17">2025-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/29/75-47%20Nacos%E6%9C%AC%E5%9C%B0%E6%BA%90%E7%A0%81%E9%83%A8%E7%BD%B2/" title="75-47 Nacos源码本地部署"><img src="/img/29.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="75-47 Nacos源码本地部署"/></a><div class="content"><a class="title" href="/2025/03/29/75-47%20Nacos%E6%9C%AC%E5%9C%B0%E6%BA%90%E7%A0%81%E9%83%A8%E7%BD%B2/" title="75-47 Nacos源码本地部署">75-47 Nacos源码本地部署</a><time datetime="2025-03-29T07:46:17.000Z" title="发表于 2025-03-29 15:46:17">2025-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/29/Untitled/" title="无标题"><img src="/img/12.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2025/03/29/Untitled/" title="无标题">无标题</a><time datetime="2025-03-29T06:37:33.652Z" title="发表于 2025-03-29 14:37:33">2025-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/29/79-03%20%E6%99%BA%E5%8D%B7%E4%BA%91%E8%AF%95%E5%8D%B7%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/" title="79-03 智卷云试卷生成方案"><img src="/img/19.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="79-03 智卷云试卷生成方案"/></a><div class="content"><a class="title" href="/2025/03/29/79-03%20%E6%99%BA%E5%8D%B7%E4%BA%91%E8%AF%95%E5%8D%B7%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/" title="79-03 智卷云试卷生成方案">79-03 智卷云试卷生成方案</a><time datetime="2025-03-29T05:58:17.000Z" title="发表于 2025-03-29 13:58:17">2025-03-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/index_img.png);"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">道阻且长</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>