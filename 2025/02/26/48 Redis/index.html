<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>48 Redis | 孤岛</title><meta name="author" content="徐行"><meta name="copyright" content="徐行"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="48 Redis前言Redis（Remote Dictionary Server )，即远程字典服务。是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 免费和开源！是当下最热门的 NoS">
<meta property="og:type" content="article">
<meta property="og:title" content="48 Redis">
<meta property="og:url" content="http://example.com/2025/02/26/48%20Redis/index.html">
<meta property="og:site_name" content="孤岛">
<meta property="og:description" content="48 Redis前言Redis（Remote Dictionary Server )，即远程字典服务。是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。 免费和开源！是当下最热门的 NoS">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/3.png">
<meta property="article:published_time" content="2025-02-26T10:58:17.000Z">
<meta property="article:modified_time" content="2025-03-12T13:53:55.515Z">
<meta property="article:author" content="徐行">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/3.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "48 Redis",
  "url": "http://example.com/2025/02/26/48%20Redis/",
  "image": "http://example.com/img/3.png",
  "datePublished": "2025-02-26T10:58:17.000Z",
  "dateModified": "2025-03-12T13:53:55.515Z",
  "author": [
    {
      "@type": "Person",
      "name": "徐行",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/02/26/48%20Redis/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@700&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '48 Redis',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">114</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">81</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/3.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">孤岛</span></a><a class="nav-page-title" href="/"><span class="site-name">48 Redis</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments-o"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">48 Redis</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-02-26T10:58:17.000Z" title="发表于 2025-02-26 18:58:17">2025-02-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-12T13:53:55.515Z" title="更新于 2025-03-12 21:53:55">2025-03-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">10k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="48-Redis"><a href="#48-Redis" class="headerlink" title="48 Redis"></a>48 Redis</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Redis（Remote Dictionary Server )，即远程字典服务。是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可<strong>持久化</strong>的日志型、Key-Value数据库，并提供多种语言的API。</p>
<p>redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。</p>
<p>免费和开源！是当下最热门的 NoSQL 技术之一！也被人们称之为<strong>结构化数据库</strong>！</p>
<ul>
<li>Redis能干嘛？<br>1、内存存储、持久化，内存中是断电即失、所以说持久化很重要（rdb、aof） 2、效率高，可以用于高速缓存<br>3、发布订阅系统<br>4、地图信息分析<br>5、计时器、计数器（浏览量！）<br>6、…</li>
</ul>
<h2 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h2><h3 id="技术选型方案"><a href="#技术选型方案" class="headerlink" title="技术选型方案"></a>技术选型方案</h3><ul>
<li>Memcached</li>
<li>Redis</li>
</ul>
<p>比较常用的是Redis，分布式缓存主要解决的是单机缓存的容量受服务器限制并且无法保存通用信息的问题，因为本地缓存只在当前服务里有效，比如你部署了两个相同的服务在两个不同的物理机上，那么这两个缓存数据是无法共同的。</p>
<p>它们两个的区别主要就是在Redis支持持久化，可以将内存中的数据保存到磁盘中，重启的时候可以再次加载进行使用，而Memcached并不支持持久化，一旦重启，内存中的数据会丢失。</p>
<p>而且Redis的功能更加丰富，比如Redis就具有更多的数据类型（kv，list，set，hash等） </p>
<p>那么为什么需要再项目中使用缓存呢？我们从高并发和高性能的角度来分析这一个问题，我们都清楚内存中的数据读取和写入是明显快于硬盘的，那么如果对于一个项目来说，它对某个数据具有大量的访问，那么每一次都需要从硬盘也就是数据库中读取，那么其效率会很低，而现在有一个数据库是运行在内存中的，每次读取都直接在内存中操作，其速度肯定是优于外存的，这就是高性能；那对于高并发呢？也哼明显，内存的并发量QPS肯定是高于外存，Redis的QPS可以达到30W+，而MySQL之类的数据库的QPS大概在10W+左右。</p>
<h2 id="Redis用途"><a href="#Redis用途" class="headerlink" title="Redis用途"></a>Redis用途</h2><ul>
<li>用于缓存</li>
<li>用于分布式锁</li>
<li>限流</li>
<li>消息队列</li>
<li>复杂业务场景</li>
</ul>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>参考资料：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fuzhongmin05/article/details/119251590?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522D3B5136A-DFFF-4ADD-826B-4D77DB204146%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=D3B5136A-DFFF-4ADD-826B-4D77DB204146&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119251590-null-null.142%5Ev100%5Epc_search_result_base2&utm_term=Redis%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81&spm=1018.2226.3001.4187">如何用Redis实现分布式锁</a></p>
<h4 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h4><p>假设我们在一个电商平台上遇到一个“秒杀”活动，用户在同一时间段内抢购限量商品。这时，我们需要保证同一时间只有一个用户能够购买到同一件商品，而不是多个用户同时购买导致超卖。这种场景下，Redis 分布式锁是一个非常有效的解决方案。</p>
<h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>Redis 提供了一个简单的<strong>SETNX</strong>（SET if Not Exists）命令，可以用于实现分布式锁。</p>
<ul>
<li><p><strong>步骤1</strong>：用户请求抢购商品时，首先使用 <code>SETNX</code>（SET if Not Exists）命令来加锁，表示该商品正在被处理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX lock:product:1001 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>步骤2</strong>：如果 <code>SETNX</code> 返回 <code>1</code>，表示成功获得锁，可以继续处理订单逻辑。</p>
</li>
<li><p><strong>步骤3</strong>：在处理订单完成后，通过 <code>DEL</code> 命令释放锁。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL lock:product:1001</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>防止死锁</strong>：可以为锁设置一个自动过期时间，防止由于服务异常导致锁未能释放的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock:product:1001 1 EX 10 NX</span><br></pre></td></tr></table></figure></li>
</ul>
<p>这样，Redis 的分布式锁确保了高并发场景下的资源独占，避免了超卖或库存不足的问题。</p>
<p>对于使用Redis作为分布式锁的话，可能会出现一些问题，下面就是对这些问题的一些简单的介绍。</p>
<p>在上面所介绍的如果直接加锁的话，那么如果在程序加锁之后，如果程序端出现了异常，导致锁没有来得及释放，那么就会导致死锁。</p>
<p>为了避免死锁，所以为为该锁添加了一个过期时间，那么程序崩溃之后，达到过期时间之后，该锁就会自动释放，这样死锁问题就解决了。</p>
<p>总之这两条命令如果不能保证是原子操作，就有潜在的风险导致过期时间设置失败，依旧有可能发生死锁问题。幸好在Redis 2.6.12之后，Redis扩展了SET命令的参数，可以在SET的同时指定EXPIRE时间，这条操作是原子的，例如以下命令是设置锁的过期时间为10秒。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key 1 EX 10 NX</span><br></pre></td></tr></table></figure>

<p>但是这样就会导致出现一些问题</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261956542.png" alt="image-20240910150402014"></p>
<p>这里存在两个严重的问题：</p>
<ul>
<li>锁过期</li>
<li>释放了别人的锁</li>
</ul>
<p><strong>为了避免释放了别人的锁</strong>，解决办法是，设置只有一个自己知道的唯一标识进去，比如自己的线程ID。</p>
<p>如果是redis实现，就是SET key unique_value EX 10 NX。之后在释放锁时，要先判断这把锁是否归自己持有，只有是自己的才能释放它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//释放锁 比较unique_value是否相等，避免误释放</span><br><span class="line">if redis.get(&quot;key&quot;) == unique_value then</span><br><span class="line">    return redis.del(&quot;key&quot;)</span><br></pre></td></tr></table></figure>

<p>可以看到这里有两个操作，一个是get和del，那么就又会出现原子性的问题。</p>
<blockquote>
<ol>
<li>客户端1执行GET，判断锁是自己的</li>
<li>客户端2执行了SET命令，强制获取到锁（虽然发生概念很低，但要严谨考虑锁的安全性）</li>
<li>客户端1执行DEL，却释放了客户端2的锁</li>
</ol>
</blockquote>
<p>那么如何解决呢？答案就是通过Lua脚本，可以把上面的逻辑写成Lua脚本，让Redis执行，因为Redis处理每个请求是单线程执行的，在执行一个Lua脚本其它必须等待，直到这个Lua脚本处理完成，这样一来get+del之间就只能用由一个进程来执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//Lua脚本语言，释放锁 比较unique_value是否相等，避免误释放</span><br><span class="line">if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then</span><br><span class="line">    return redis.call(&quot;del&quot;,KEYS[1])</span><br><span class="line">else</span><br><span class="line">    return 0</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>但是该如何确定锁的过期时间呢？</p>
<p>前面提到过，过期时间如果评估得不好，这个锁就会有提前过期的风险，一种妥协的解决方案是，尽量冗余过期时间，降低锁提前过期的概率，但这个方案并不能完美解决问题。是否可以设置这样的方案，加锁时，先设置一个预估的过期时间，然后开启一个守护线程，定时去检测这个锁的失效时间，如果锁快要过期了，操作共享资源还未完成，那么就自动对锁进行续期，重新设置过期时间。</p>
<p>这是一种比较好的方案，已经有一个库把这些工作都封装好了，它就是Redisson。Redisson是一个Java语言实现的Redis SDK客户端，在使用分布式锁时，它就采用了自动续期的方案来避免锁过期，这个守护线程我们一般叫它看门狗线程。这个SDK提供的API非常友好，它可以像操作本地锁一样操作分布式锁。客户端一旦加锁成功，就会启动一个watch dog看门狗线程，它是一个后台线程，会每隔一段时间（这段时间的长度与设置的锁的过期时间有关）检查一下，如果检查时客户端还持有锁key（也就是说还在操作共享资源），那么就会延长锁key的生存时间。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261956345.png" alt="img"></p>
<h4 id="Redis常见的部署方式对锁的影响"><a href="#Redis常见的部署方式对锁的影响" class="headerlink" title="Redis常见的部署方式对锁的影响"></a>Redis常见的部署方式对锁的影响</h4><ul>
<li>单机模式；</li>
<li>主从模式；</li>
<li>哨兵（sentinel）模式；</li>
<li>集群模式；</li>
</ul>
<p>我们使用Redis时，一般会采用主从集群+哨兵的模式部署，哨兵的作用就是监测redis节点的运行状态。普通的主从模式，当master崩溃时，需要手动切换让slave成为master，使用主从+哨兵结合的好处在于，当master异常宕机时，哨兵可以实现故障自动切换，把slave提升为新的master，继续提供服务，以此保证可用性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261956331.png" alt="img"></p>
<ol>
<li><p>客户端1在master上执行SET命令，加锁成功</p>
</li>
<li><p>此时，master异常宕机，SET命令还未同步到slave上（主从复制是异步的）</p>
</li>
<li><p>哨兵将slave提升为新的master，但这个锁在新的master上丢失了，导致客户端2来加锁成功了，两个客户端共同操作共享资源</p>
</li>
</ol>
<h4 id="集群模式-Redlock实现高可靠的分布式锁"><a href="#集群模式-Redlock实现高可靠的分布式锁" class="headerlink" title="集群模式+Redlock实现高可靠的分布式锁"></a>集群模式+Redlock实现高可靠的分布式锁</h4><p>为了避免Redis实例故障而导致的锁无法工作的问题，Redis的开发者 Antirez提出了分布式锁算法Redlock。Redlock算法的基本思路，是让客户端和多个独立的Redis实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁了，否则加锁失败。这样一来，即使有单个Redis实例发生故障，因为锁变量在其它实例上也有保存，所以，客户端仍然可以正常地进行锁操作，锁变量并不会丢失。</p>
<p>来具体看下Redlock算法的执行步骤。Redlock算法的实现要求Redis采用集群部署模式，无哨兵节点，需要有N个独立的Redis实例（官方推荐至少5个实例）。接下来，我们可以分成3步来完成加锁操作。</p>
<ol>
<li><p>第一步是，客户端获取当前时间。</p>
</li>
<li><p>第二步是，客户端按顺序依次向N个Redis实例执行加锁操作。</p>
</li>
</ol>
<p>这里的加锁操作和在单实例上执行的加锁操作一样，使用SET命令，带上NX、EX&#x2F;PX选项，以及带上客户端的唯一标识。当然，如果某个Redis实例发生故障了，为了保证在这种情况下，Redlock算法能够继续运行，我们需要给加锁操作设置一个超时时间。如果客户端在和一个Redis实例请求加锁时，一直到超时都没有成功，那么此时，客户端会和下一个Redis实例继续请求加锁。加锁操作的超时时间需要远远地小于锁的有效时间，一般也就是设置为几十毫秒。</p>
<p>第三步是，一旦客户端完成了和所有Redis实例的加锁操作，客户端就要计算整个加锁过程的总耗时。</p>
<p>客户端只有在满足两个条件时，才能认为是加锁成功，条件一是客户端从超过半数（大于等于 N&#x2F;2+1）的Redis实例上成功获取到了锁；条件二是客户端获取锁的总耗时没有超过锁的有效时间。</p>
<p>为什么大多数实例加锁成功才能算成功呢？多个Redis实例一起来用，其实就组成了一个分布式系统。在分布式系统中总会出现异常节点，所以在谈论分布式系统时，需要考虑异常节点达到多少个，也依旧不影响整个系统的正确运行。这是一个分布式系统的容错问题，这个问题的结论是：如果只存在故障节点，只要大多数节点正常，那么整个系统依旧可以提供正确服务。</p>
<p>在满足了这两个条件后，我们需要重新计算这把锁的有效时间，计算的结果是锁的最初有效时间减去客户端为获取锁的总耗时。如果锁的有效时间已经来不及完成共享数据的操作了，我们可以释放锁，以免出现还没完成共享资源操作，锁就过期了的情况。</p>
<p>当然，如果客户端在和所有实例执行完加锁操作后，没能同时满足这两个条件，那么，客户端就要向所有Redis节点发起释放锁的操作。为什么释放锁，要操作所有的节点呢，不能只操作那些加锁成功的节点吗？因为在某一个Redis节点加锁时，可能因为网络原因导致加锁失败，例如一个客户端在一个Redis实例上加锁成功，但在读取响应结果时由于网络问题导致读取失败，那这把锁其实已经在Redis上加锁成功了。所以释放锁时，不管之前有没有加锁成功，需要释放所有节点上的锁以保证清理节点上的残留的锁。</p>
<p>在Redlock算法中，释放锁的操作和在单实例上释放锁的操作一样，只要执行释放锁的 Lua脚本就可以了。这样一来，只要N个Redis实例中的半数以上实例能正常工作，就能保证分布式锁的正常工作了。所以，在实际的业务应用中，如果你想要提升分布式锁的可靠性，就可以通过Redlock算法来实现。</p>
<h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><p>参考资料：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA">我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！</a></p>
<p>一般是通过Redis和Lua脚本的方式来实现限流。</p>
<h4 id="限流方案"><a href="#限流方案" class="headerlink" title="限流方案"></a>限流方案</h4><h5 id="计数器"><a href="#计数器" class="headerlink" title="计数器"></a>计数器</h5><p>Java内部也可以通过原子类计数器<code>AtomicInteger</code>、<code>Semaphore</code>信号量来做简单的限流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 限流的个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 指定的时间内</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">interval</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line"><span class="comment">// 原子类计数器</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">atomicInteger</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 起始时间</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">limit</span><span class="params">(<span class="type">int</span> maxCount, <span class="type">int</span> interval)</span> &#123;</span><br><span class="line">    atomicInteger.addAndGet(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (atomicInteger.get() == <span class="number">1</span>) &#123;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        atomicInteger.addAndGet(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 超过了间隔时间，直接重新开始计数</span></span><br><span class="line">    <span class="keyword">if</span> (System.currentTimeMillis() - startTime &gt; interval * <span class="number">1000</span>) &#123;</span><br><span class="line">        startTime = System.currentTimeMillis();</span><br><span class="line">        atomicInteger.set(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 还在间隔时间内,check有没有超过限流的个数</span></span><br><span class="line">    <span class="keyword">if</span> (atomicInteger.get() &gt; maxCount) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h5><p>漏桶算法思路很简单，我们把水比作是<code>请求</code>，漏桶比作是<code>系统处理能力极限</code>，水先进入到漏桶里，漏桶里的水按一定速率流出，当流出的速率小于流入的速率时，由于漏桶容量有限，后续进入的水直接溢出（拒绝请求），以此实现限流。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261956880.png" alt="image-20240910153455239"></p>
<h5 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h5><p>令牌桶算法的原理也比较简单，我们可以理解成医院的挂号看病，只有拿到号以后才可以进行诊病。</p>
<p>系统会维护一个令牌（<code>token</code>）桶，以一个恒定的速度往桶里放入令牌（<code>token</code>），这时如果有请求进来想要被处理，则需要先从桶里获取一个令牌（<code>token</code>），当桶里没有令牌（<code>token</code>）可取时，则该请求将被拒绝服务。令牌桶算法通过控制桶的容量、发放令牌的速率，来达到对请求的限制。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261956127.png" alt="image-20240910153705064"></p>
<h5 id="Redis-Lua"><a href="#Redis-Lua" class="headerlink" title="Redis + Lua"></a>Redis + Lua</h5><p>很多同学不知道<code>Lua</code>是啥？个人理解，<code>Lua</code>脚本和 <code>MySQL</code>数据库的存储过程比较相似，他们执行一组命令，所有命令的执行要么全部成功或者失败，以此达到原子性。也可以把<code>Lua</code>脚本理解为，一段具有业务逻辑的代码块。</p>
<p>而<code>Lua</code>本身就是一种编程语言，虽然<code>redis</code> 官方没有直接提供限流相应的<code>API</code>，但却支持了 <code>Lua</code> 脚本的功能，可以使用它实现复杂的令牌桶或漏桶算法，也是分布式系统中实现限流的主要方式之一。</p>
<p>相比<code>Redis</code>事务，<code>Lua脚本</code>的优点：</p>
<ul>
<li>减少网络开销：使用<code>Lua</code>脚本，无需向<code>Redis</code> 发送多次请求，执行一次即可，减少网络传输</li>
<li>原子操作：<code>Redis</code> 将整个<code>Lua</code>脚本作为一个命令执行，原子，无需担心并发</li>
<li>复用：<code>Lua</code>脚本一旦执行，会永久保存 <code>Redis</code> 中,，其他客户端可复用</li>
</ul>
<p><code>Lua</code>脚本大致逻辑如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-- 获取调用脚本时传入的第一个key值（用作限流的 key）</span><br><span class="line">local key = KEYS[1]</span><br><span class="line">-- 获取调用脚本时传入的第一个参数值（限流大小）</span><br><span class="line">local limit = tonumber(ARGV[1])</span><br><span class="line"></span><br><span class="line">-- 获取当前流量大小</span><br><span class="line">local curentLimit = tonumber(redis.call(&#x27;get&#x27;, key) or &quot;0&quot;)</span><br><span class="line"></span><br><span class="line">-- 是否超出限流</span><br><span class="line">if curentLimit + 1 &gt; limit then</span><br><span class="line">    -- 返回(拒绝)</span><br><span class="line">    return 0</span><br><span class="line">else</span><br><span class="line">    -- 没有超出 value + 1</span><br><span class="line">    redis.call(&quot;INCRBY&quot;, key, 1)</span><br><span class="line">    -- 设置过期时间</span><br><span class="line">    redis.call(&quot;EXPIRE&quot;, key, 2)</span><br><span class="line">    -- 返回(放行)</span><br><span class="line">    return 1</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<ul>
<li>通过<code>KEYS[1]</code> 获取传入的key参数</li>
<li>通过<code>ARGV[1]</code>获取传入的<code>limit</code>参数</li>
<li><code>redis.call</code>方法，从缓存中<code>get</code>和<code>key</code>相关的值，如果为<code>null</code>那么就返回0</li>
<li>接着判断缓存中记录的数值是否会大于限制大小，如果超出表示该被限流，返回0</li>
<li>如果未超过，那么该key的缓存值+1，并设置过期时间为1秒钟以后，并返回缓存值+1</li>
</ul>
<p>这种方式是本文推荐的方案，具体实现会在后边做细说。</p>
<h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>Redis ⾃带的 list 数据结构可以作为⼀个简单的队列使⽤。Redis 5.0 中增加的 Stream 类型的数据结构更加适合⽤来做消息队列。它⽐᫾类似于 Kafka，有主题和消费组的概 念，⽀持消息持久化以及 ACK 机制。</p>
<p>Redis可以做消息队列，Redis 5.0 新增加的⼀个数据结构 Stream 可以⽤来做消息队列， Stream ⽀持：</p>
<ul>
<li>发布 &#x2F; 订阅模式 </li>
<li>按照消费者组进⾏消费 </li>
<li>消息持久化（ RDB 和 AOF）</li>
</ul>
<p>不过，和专业的消息队列相⽐，还是有很多⽋缺的地⽅⽐如消息丢失和堆积问题不好解决。因此，我们通常建议是不使⽤ Redis 来做消息队列的，你完全可以选择市⾯上⽐成熟的⼀些消息队列⽐如 RocketMQ、Kafka。</p>
<h3 id="复杂业务场景"><a href="#复杂业务场景" class="headerlink" title="复杂业务场景"></a>复杂业务场景</h3><p>通过 Redis 以及 Redis 扩展（⽐如 Redisson）提供的数据结构，我们可以很⽅ 便地完成很多复杂的业务场景⽐如通过 bitmap 统计活跃⽤户、通过 sorted set 维护排⾏榜。</p>
<h2 id="Redis的五大数据类型"><a href="#Redis的五大数据类型" class="headerlink" title="Redis的五大数据类型"></a>Redis的五大数据类型</h2><p>Redis是key-value存储系统，key一般为string类型的字符串，value是redis对象(object)。Redis 共有 5 种基本数据类型：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261956596.png" alt="在这里插入图片描述"></p>
<h3 id="String-还是-Hash-存储对象数据更好呢？"><a href="#String-还是-Hash-存储对象数据更好呢？" class="headerlink" title="String 还是 Hash 存储对象数据更好呢？"></a>String 还是 Hash 存储对象数据更好呢？</h3><ul>
<li><p>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省⽹络流量。如果对象中某些 字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就⾮常适合。</p>
</li>
<li><p>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的 ⼀半。并且，存储具有多层嵌套的对象时也⽅便很多。如果系统对性能和资源消耗⾮常敏感的 话，String 就⾮常适合。</p>
</li>
</ul>
<p>在绝⼤部分情况，我们建议使⽤ String 来存储对象数据即可！ 那根据你的介绍，购物⻋信息⽤ String 还是 Hash 存储更好呢？</p>
<p>购物⻋信息建议使⽤ Hash 存储： ⽤户 id 为 key 商品 id 为 field，商品数量为 value 由于购物⻋中的商品频繁修改和变动，这个时候 Hash 就⾮常适合了！</p>
<h2 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h2><p>对于读写命令来说，Redis ⼀直是单线程模型。不过，在 Redis 4.0 版本之后引⼊了多线程来执⾏⼀ 些⼤键值对的异步删除操作， Redis 6.0 版本之后引⼊了多线程来处理⽹络请求（提⾼⽹络 IO 读写 性能）。</p>
<p>Redis单线程模型了解？</p>
<p>Redis基于单线程，那么是怎么监听大量的客户端连接呢？</p>
<blockquote>
<p>Redis通过IO多路复用程序来监听来自客户端的大量连接，或者说是监听多个socket，它会将感兴趣的事件即类型注册到内核中并监听每个事件是否发生。</p>
</blockquote>
<p>这样的好处非常明显：I&#x2F;O多路复用技术的使用让Redis不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和NIO中的Selector组件很像）。</p>
<p>另外，Redis服务器是一个事件驱动程序，服务器需要处理两类事件：</p>
<ul>
<li>⽂件事件(file event) ：⽤于处理 Redis 服务器和客户端之间的⽹络 IO。 </li>
<li>时间事件(time eveat) ：Redis 服务器中的⼀些操作（⽐如 serverCron 函数）需要在给定的时 间点执⾏，⽽时间事件就是处理这类定时操作的。</li>
</ul>
<p>时间事件不需要多花时间了解，我们接触最多的还是 ⽂件事件（客户端进⾏读取写⼊等操作，涉及 ⼀系列⽹络通信）。</p>
<blockquote>
<p>Redis 基于 Reactor 模式开发了⾃⼰的⽹络事件处理器：这个处理器被称为⽂件事件处理器 （file event handler）。⽂件事件处理器使⽤ I&#x2F;O 多路复⽤（multiplexing）程序来同时监听多 个套接字，并根据套接字⽬前执⾏的任务来为套接字关联不同的事件处理器。 当被监听的套接字准备好执⾏连接应答（accept）、读取（read）、写⼊（write）、关 闭 （close）等操作时，与操作相对应的⽂件事件就会产⽣，这时⽂件事件处理器就会调⽤套接字 之前关联好的事件处理器来处理这些事件。 虽然⽂件事件处理器以单线程⽅式运⾏，但通过使⽤ I&#x2F;O 多路复⽤程序来监听多个套接字，⽂ 件事件处理器既实现了⾼性能的⽹络通信模型，⼜可以很好地与 Redis 服务器中其他同样以单 线程⽅式运⾏的模块进⾏对接，这保持了 Redis 内部单线程设计的简单性。</p>
</blockquote>
<p>可以看出，⽂件事件处理器（file event handler）主要是包含 4 个部分： </p>
<ul>
<li>多个 socket（客户端连接） </li>
<li>IO 多路复⽤程序（⽀持多个客户端连接的关键） </li>
<li>⽂件事件分派器（将 socket 关联到相应的事件处理器） </li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<h2 id="Redis内存管理"><a href="#Redis内存管理" class="headerlink" title="Redis内存管理"></a>Redis内存管理</h2><p>Redis 通过⼀个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是⼀个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261956718.png" alt="image-20240910171943654"></p>
<h3 id="过期的数据的删除策略了解么？"><a href="#过期的数据的删除策略了解么？" class="headerlink" title="过期的数据的删除策略了解么？"></a>过期的数据的删除策略了解么？</h3><p>过期数据删除策略就两个：</p>
<ol>
<li><strong>惰性删除</strong>：只会在取出 key 的时候才对数据进⾏过期检查。这样对 CPU 最友好，但是可能会 造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong>：每隔⼀段时间抽取⼀批 key 执⾏删除过期 key 操作。并且，Redis 底层会通过限制 删除操作执⾏的时⻓和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对CPU更加友好，两者各有千秋，<strong>所以Redis采用的是定期删除+惰性删除。</strong></p>
<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了 很多过期 key 的情况。这样就导致⼤量过期 key 堆积在内存⾥，然后就 Out of memory 了。</p>
<p> 怎么解决这个问题呢？答案就是：Redis 内存淘汰机制。</p>
<h3 id="Redis内存淘汰机制了解么？"><a href="#Redis内存淘汰机制了解么？" class="headerlink" title="***Redis内存淘汰机制了解么？"></a>***Redis内存淘汰机制了解么？</h3><p>Redis提供6种数据淘汰策略：</p>
<ul>
<li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选**最近最少使⽤**的数据淘汰；</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰；</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰；</li>
<li><strong>allkeys-lru</strong>：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最近最少使⽤的 key（这个是最常⽤的）；</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰；</li>
<li><strong>no-eviction</strong>：禁⽌驱逐数据，也就是说当内存不⾜以容纳新写⼊数据时，新写⼊操作会报错。 这个应该没⼈使⽤吧！</li>
<li><strong>volatile-lfu</strong>（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中 挑选最不经常使⽤的数据淘汰 </li>
<li><strong>allkeys-lfu</strong>（least frequently used）：当内存不⾜以容纳新写⼊数据时，在键空间中，移除最 不经常使⽤的 key；</li>
</ul>
<blockquote>
<p>在 Redis 中，<code>volatile-lfu</code> 和 <code>volatile-lru</code> 是两种不同的内存淘汰策略，用于在内存达到限制时决定哪些键值对应该被淘汰。这两者的主要区别在于它们如何选择要淘汰的数据。</p>
<h3 id="1-volatile-lfu（Least-Frequently-Used）"><a href="#1-volatile-lfu（Least-Frequently-Used）" class="headerlink" title="1. volatile-lfu（Least Frequently Used）"></a>1. <strong>volatile-lfu</strong>（Least Frequently Used）</h3><ul>
<li><p><strong>解释</strong>：<code>volatile-lfu</code> 策略会选择那些<strong>使用频率最少</strong>的数据进行淘汰。Redis 通过记录键被访问的次数来决定哪些数据不经常使用。</p>
</li>
<li><p><strong>适用场景</strong>：适合那些有”热点”数据的场景。某些数据可能一段时间内被频繁访问，而其他数据很少被访问，<code>LFU</code> 能更好地保持频繁使用的数据，淘汰那些长期不被使用的数据。</p>
</li>
<li><p><strong>行为示例</strong>：<br>假设 Redis 中有以下键值对及其访问频率（在过期键集合 <code>expires</code> 中）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key1 -&gt; 10 (访问次数)</span><br><span class="line">key2 -&gt; 5  (访问次数)</span><br><span class="line">key3 -&gt; 1  (访问次数)</span><br><span class="line">key4 -&gt; 20 (访问次数)</span><br></pre></td></tr></table></figure>

<p>当 Redis 内存不够用，需要淘汰键时，<code>volatile-lfu</code> 会选择访问频率最低的 <code>key3</code> 进行淘汰，因为它的使用次数是最少的。</p>
</li>
</ul>
<h3 id="2-volatile-lru（Least-Recently-Used）"><a href="#2-volatile-lru（Least-Recently-Used）" class="headerlink" title="2. volatile-lru（Least Recently Used）"></a>2. <strong>volatile-lru</strong>（Least Recently Used）</h3><ul>
<li><p><strong>解释</strong>：<code>volatile-lru</code> 策略会淘汰那些<strong>最近最少使用</strong>的数据，而不是看数据的访问频率。Redis 会记录每个键最后一次被访问的时间，选择那些长时间未被访问的键进行淘汰。</p>
</li>
<li><p><strong>适用场景</strong>：适合那些访问数据的”新鲜度”很重要的场景。即使一个键曾经被频繁访问，但如果长时间未被访问，也可能不再有价值，这时 <code>LRU</code> 策略就会将其淘汰。</p>
</li>
<li><p><strong>行为示例</strong>：<br>假设 Redis 中有以下键值对及其最近访问时间（在过期键集合 <code>expires</code> 中）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key1 -&gt; 2 分钟前访问</span><br><span class="line">key2 -&gt; 5 分钟前访问</span><br><span class="line">key3 -&gt; 1 小时前访问</span><br><span class="line">key4 -&gt; 10 秒前访问</span><br></pre></td></tr></table></figure>

<p>当 Redis 内存不足时，<code>volatile-lru</code> 会选择 <code>key3</code> 进行淘汰，因为它是最近最少被访问的。</p>
</li>
</ul>
<h3 id="3-区别总结"><a href="#3-区别总结" class="headerlink" title="3. 区别总结"></a>3. <strong>区别总结</strong></h3><ul>
<li><strong>volatile-lfu</strong>：根据<strong>访问频率</strong>选择最不常使用的键进行淘汰。适合需要保留最常访问数据的场景。</li>
<li><strong>volatile-lru</strong>：根据<strong>最后一次访问时间</strong>选择最近最少使用的键进行淘汰。适合需要保留最新访问数据的场景。</li>
</ul>
<h3 id="4-示例代码说明"><a href="#4-示例代码说明" class="headerlink" title="4. 示例代码说明"></a>4. 示例代码说明</h3><p>假设我们使用 Java 模拟 Redis 的这两种策略（伪代码）。</p>
<h4 id="volatile-lfu-示例："><a href="#volatile-lfu-示例：" class="headerlink" title="volatile-lfu 示例："></a>volatile-lfu 示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileLFU</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; frequency = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        data.put(key, value.hashCode());</span><br><span class="line">        frequency.put(key, frequency.getOrDefault(key, <span class="number">0</span>) + <span class="number">1</span>);  <span class="comment">// 更新访问频率</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evict</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">leastUsedKey</span> <span class="operator">=</span> Collections.min(frequency.entrySet(), Map.Entry.comparingByValue()).getKey();</span><br><span class="line">        data.remove(leastUsedKey);</span><br><span class="line">        frequency.remove(leastUsedKey);</span><br><span class="line">        System.out.println(<span class="string">&quot;Evicted key with least frequency: &quot;</span> + leastUsedKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">VolatileLFU</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileLFU</span>();</span><br><span class="line">        cache.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        cache.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        cache.put(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        cache.evict();  <span class="comment">// 淘汰访问次数最少的键</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="volatile-lru-示例："><a href="#volatile-lru-示例：" class="headerlink" title="volatile-lru 示例："></a>volatile-lru 示例：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileLRU</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; data = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Long&gt; lastAccessed = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">        data.put(key, value.hashCode());</span><br><span class="line">        lastAccessed.put(key, System.currentTimeMillis());  <span class="comment">// 更新最后访问时间</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">evict</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">leastRecentlyUsedKey</span> <span class="operator">=</span> Collections.min(lastAccessed.entrySet(), Map.Entry.comparingByValue()).getKey();</span><br><span class="line">        data.remove(leastRecentlyUsedKey);</span><br><span class="line">        lastAccessed.remove(leastRecentlyUsedKey);</span><br><span class="line">        System.out.println(<span class="string">&quot;Evicted least recently used key: &quot;</span> + leastRecentlyUsedKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">VolatileLRU</span> <span class="variable">cache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VolatileLRU</span>();</span><br><span class="line">        cache.put(<span class="string">&quot;key1&quot;</span>, <span class="string">&quot;value1&quot;</span>);</span><br><span class="line">        cache.put(<span class="string">&quot;key2&quot;</span>, <span class="string">&quot;value2&quot;</span>);</span><br><span class="line">        cache.put(<span class="string">&quot;key3&quot;</span>, <span class="string">&quot;value3&quot;</span>);</span><br><span class="line"></span><br><span class="line">        cache.evict();  <span class="comment">// 淘汰最近最少访问的键</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul>
<li><strong>volatile-lfu</strong>：基于访问频率淘汰键，适合那些有“热点”数据的场景。</li>
<li><strong>volatile-lru</strong>：基于最后访问时间淘汰键，适合那些数据”新鲜度”较重要的场景。</li>
</ul>
</blockquote>
<h2 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h2><h3 id="怎么保证Redis挂掉之后再重启数据可以进行恢复吗？"><a href="#怎么保证Redis挂掉之后再重启数据可以进行恢复吗？" class="headerlink" title="怎么保证Redis挂掉之后再重启数据可以进行恢复吗？"></a>怎么保证Redis挂掉之后再重启数据可以进行恢复吗？</h3><p>Redis 的⼀种持久化⽅式叫快照（snapshotting，RDB），另⼀种⽅式是只追加⽂件 （append-only file, AOF）。</p>
<p>Redis 提供了两个命令来⽣成 RDB 快照⽂件： </p>
<ul>
<li>save : 主线程执⾏，会阻塞主线程； </li>
<li>bgsave : ⼦线程执⾏，不会阻塞主线程，默认选项</li>
</ul>
<h3 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h3><p>RDB利用的就是操作系统中的COW（写时复制)来实现的。</p>
<p>RDB是基于快照一次的全量备份，即<strong>周期性</strong>的把redis当前内存中的全量数据写入到一个快照文件中(周期时间可以通过配置来调整)。redis是单线程程序，这个线程要同时负责多个客户端的读写请求，还要负责周期性的把当前内存中的数据写到快照文件中RDB中，数据写到<strong>RDB</strong>文件是IO操作，IO操作会严重影响redis的性能，甚至在持久化的过程中，读写请求会阻塞，为了解决这些问题，Redis采用多进程来同时进行读写请求和持久化操作。这样又会导致另外的问题，持久化的过程中，内存中的数据还在改变，假如redis正在进行持久化一个大的数据结构，在这个过程中客户端发送一个删除请求，把这个大的数据结构删掉了，这时候持久化的动作还没有完成，那么redis该怎么办呢？</p>
<p><strong>redis</strong>使用操作系统的多进程<strong>COW</strong>(Copy On Write)机制来实现快照的持久化，在持久化过程中调用 glibc(Linux下的C函数库) 的函数fork()产生一个子进程，快照持久化完全交给子进程来处理，父进程继续处理客户端的读写请求。子进程刚刚产生时，和父进程共享内存里面的代码段和数据段，这是Linux操作系统的机制，为了节约内存资源，所以尽可能让父子进程共享内存，这样在进程分离的一瞬间，内存的增长几乎没有明显变化。</p>
<h3 id="AOP持久化"><a href="#AOP持久化" class="headerlink" title="AOP持久化"></a>AOP持久化</h3><p>与快照持久化相⽐，AOF 持久化的实时性更好，因此已成为主流的持久化⽅案。默认情况下 Redis 没有开启 AOF（append only file）⽅式的持久化，可以通过 appendonly 参数开启：</p>
<p>在关系型数据库通常都是执行命令之前记录日志（方便故障恢复），而Redis AOF持久化机制是在执行完命令之后再记录日志。</p>
<p>这是为了避免额外的检查开销，AOF记录日志会对命令进行语法检查；在命令执行完之后再记录，不会阻塞当前命令的执行。</p>
<p>但是这样也会导致出现Redis宕机从而对应的修改丢失，可能也会阻塞后续其它命令的执行，AOF记录日志实在Redis主线程中进行的。</p>
<p>AOF 重写了解吗？ AOF 重写可以产⽣⼀个新的 AOF ⽂件，这个新的 AOF ⽂件和原有的 AOF ⽂件所保存的数据库状 态⼀样，但体积更⼩。 AOF 重写是⼀个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序⽆须对现有 AOF ⽂件进⾏任何读⼊、分析或者写⼊操作。</p>
<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis 可以通过 MULTI ， EXEC ， DISCARD 和 WATCH 等命令来实现事务(transaction)功能。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET USER &quot;Guide哥&quot;</span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET USER</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) &quot;Guide哥&quot;</span><br></pre></td></tr></table></figure>

<p>DISCARD取消一个事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; SET USER &quot;Guide哥&quot;</span><br><span class="line">QUEUED</span><br><span class="line">&gt; GET USER</span><br><span class="line">QUEUED</span><br><span class="line">&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>WATCH 命令⽤于监听指定的键，当调⽤ EXEC 命令执⾏事务时，如果⼀个被 WATCH 命令监 视的键被修改的话，整个事务都不会执⾏，直接返回失败。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; WATCH USER</span><br><span class="line">OK</span><br><span class="line">&gt; MULTI</span><br><span class="line">&gt; SET USER &quot;Guide哥&quot;</span><br><span class="line">OK</span><br><span class="line">&gt; GET USER</span><br><span class="line">Guide哥</span><br><span class="line">&gt; EXEC</span><br><span class="line">ERR EXEC without MULTI</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关系型数据库事务的四大特性：原子性、持久性、隔离性和一致性；但是Redis不满足在事务运行错误的情况下进行回滚，即不满足原子性，Redis也定不满足持久性。</p>
<p>Redis事务提供一种将多个命令打包的功能，然后再按顺序执行打包的所有命令，并且不会被中途打断。</p>
<p>除了不满⾜原⼦性之外，事务中的每条命令都会与 Redis 服务器进⾏⽹络交互，这是⽐᫾浪费资源 的⾏为。 因此，Redis 事务是不建议在⽇常开发中使⽤的。</p>
<p>为了解决这个问题，在Redis2.6之后提出了Lua机制，通过使用Lua脚本来批量执行多条Redis命令，而且这些Redis会一次性打包到Redis服务器中执行。</p>
<p>但是通过Lua脚本执行的命令也不会满足原子性，这是因为在一个Lua脚本中的命令如果出现执行错误的命令则会停止执行接下来的命令，但是之前的命令不会回滚。</p>
<h2 id="Redis优化"><a href="#Redis优化" class="headerlink" title="Redis优化"></a>Redis优化</h2><h3 id="Redis-bigkey"><a href="#Redis-bigkey" class="headerlink" title="Redis bigkey"></a>Redis bigkey</h3><p>什么是 bigkey？ 简单来说，如果⼀个 key 对应的 value 所占⽤的内存比较大，那这个 key 就可以看作是 bigkey。具 体多⼤才算⼤呢？有⼀个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不⼀定包含的元素越多，占⽤的内存 就越多）。</p>
<p>bigkey对性能的影响很大，在实际的开发中应该尽量避免bigkey。</p>
<p>通过分析RDB文件来得到bigkey，前提是Redis采用的是RDB持久化。</p>
<h3 id="大量key集中过期问题"><a href="#大量key集中过期问题" class="headerlink" title="大量key集中过期问题"></a>大量key集中过期问题</h3><p>这一问题是在某一时刻遇到了大量的key过期，而这个清除Redis过期数据是由Redis主线程中执行的，导致客户端请求响应速度减慢。</p>
<p>针对key在某一时刻同时过期，我们提出：为key设置一个随机过期时间，避免造成拥堵；</p>
<p>针对清除过期key导致主线程阻塞，那么我们可以让清除过期key交给一个子线程，避免阻塞主线程，我们称这个方法为lazy-free（惰性删除&#x2F;延迟释放）</p>
<h2 id="Redis生产问题"><a href="#Redis生产问题" class="headerlink" title="Redis生产问题"></a>Redis生产问题</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><h4 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h4><p>简单的说就是大量的请求key不存在缓存中，导致大量的请求直接打到了数据库上，导致数据库压力激增。解决办法如下：</p>
<ol>
<li><p>缓存无效的key；</p>
<blockquote>
<p>如果缓存和数据库都查不到某个 key 的数据就写⼀个到 Redis 中去并设置过期时间，具体命令如 下： SET key value EX 10086 。这种⽅式可以解决请求的 key 变化不频繁的情况，如果⿊客恶意攻 击，每次构建不同的请求 key，会导致 Redis 中缓存⼤量⽆效的 key 。很明显，这种⽅案并不能从 根本上解决此问题。如果⾮要⽤这种⽅式来解决穿透问题的话，尽量将⽆效的 key 的过期时间设置 短⼀点⽐如 1 分钟。 另外，这⾥多说⼀嘴，⼀般情况下我们是这样设计 key 的： 表名:列名:主键名:主键值 。</p>
</blockquote>
</li>
<li><p>布隆过滤器；</p>
<blockquote>
<p>布隆过滤器说某个元素存 在，⼩概率会误判。布隆过滤器说某个元素不在，那么这个元素⼀定不在。</p>
<p>布隆过滤器的本质是哈希函数，因为是哈希函数，那么就存在一定的几率出现哈希冲突，所以就会出现布隆过滤器说它不在它一定不在，说它在它不一定在。</p>
</blockquote>
</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存在同⼀时间⼤⾯积的失效，后⾯的请求都直 接落到了数据库上，造成数据库短时间内承受⼤量请求。 这就好⽐雪崩⼀样，摧枯拉朽之势，数据 库的压⼒可想⽽知，可能直接就被这么多请求弄宕机了。</p>
<blockquote>
<p>可以发现缓存雪崩和缓存穿透的区别就是这个key是否真实有效存在的。</p>
</blockquote>
<p>有哪些解决办法？ 针对 Redis 服务不可⽤的情况： </p>
<ol>
<li>采⽤ Redis 集群，避免单机出现问题整个缓存服务都没办法使⽤。 </li>
<li>限流，避免同时处理⼤量的请求。</li>
</ol>
<p>针对热点缓存失效的情况： </p>
<ol>
<li>设置不同的失效时间⽐如随机设置缓存的失效时间。</li>
<li>缓存永不失效</li>
</ol>
<h2 id="如何保证缓存和数据库数据的一致性"><a href="#如何保证缓存和数据库数据的一致性" class="headerlink" title="如何保证缓存和数据库数据的一致性"></a>如何保证缓存和数据库数据的一致性</h2><p>参考资料：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd">缓存和数据库一致性问题，看这篇就够了</a></p>
<p>我们首先就需要明确一下为什么引入缓存之后会出现缓存和数据库数据一致性的问题，在引入缓存之前，我们存取数据都是在一个数据库中进行操作的，但是如果我们引入了缓存之后，系统读的时候会优先从缓存中读取，那么如果缓存中的数据和磁盘中的数据不一致该如何是好？</p>
<p>所以我们就需要认真思考一下该如何解决缓存和数据库数据一致性的问题。</p>
<p>在这里我们需要面对下面几个选择：</p>
<ul>
<li>更新缓存 OR 删除缓存</li>
<li>如果是更新缓存，是先更新缓存还是先更新数据库；</li>
<li>如果是删除缓存，是先删除缓存还是先更新数据库再删除缓存；</li>
</ul>
<p>下面我们依次来看看这些方案分别会出现什么问题。</p>
<h3 id="更新缓存"><a href="#更新缓存" class="headerlink" title="更新缓存"></a>更新缓存</h3><p>如果我们选择更新缓存这一大方案，那么我们就会出现下面几个选择：先更新数据库再更新缓存OR先更新缓存再更新数据库。</p>
<p>在高并发的情况下，无论是先更新缓存再更新数据库还是先更新数据库再更新缓存都回出现下面这个问题，下面我们以先更新缓存再更新数据库为例来介绍其可能会出现的问题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261957695.png" alt="image-20240911115932602"></p>
<h3 id="删除缓存"><a href="#删除缓存" class="headerlink" title="删除缓存"></a>删除缓存</h3><h4 id="先删除缓存，后更新数据库"><a href="#先删除缓存，后更新数据库" class="headerlink" title="先删除缓存，后更新数据库"></a>先删除缓存，后更新数据库</h4><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261957053.png" alt="image-20240911120051711"></p>
<h4 id="先更新数据库，后删除缓存"><a href="#先更新数据库，后删除缓存" class="headerlink" title="先更新数据库，后删除缓存"></a>先更新数据库，后删除缓存</h4><p>如果先更新数据库再删除缓存，是不会出现上面这种情况的，但是还会出现下面这个问题：</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261957387.png" alt="image-20240911122040552"></p>
<p>所以为了解决并发情况的最好解决方案是：先更新数据库后删除缓存；</p>
<p>但是无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。</p>
<p>保证第二步成功执行就是解决问题的关键，最简单的办法是<strong>重试</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261957109.png" alt="image-20240911122740355"></p>
<h3 id="异步重试"><a href="#异步重试" class="headerlink" title="异步重试"></a>异步重试</h3><p><img src="https://cdn.jsdelivr.net/gh/fangyaohui/Pictures@main/img/202502261957752.png" alt="image-20240911122814117"></p>
<p><strong>至此，我们可以得出结论，想要保证数据库和缓存一致性，推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做。</strong></p>
<h2 id="Bug解决"><a href="#Bug解决" class="headerlink" title="Bug解决"></a>Bug解决</h2><h3 id="解决Rediis客户端无法连接服务器上Redis服务问题"><a href="#解决Rediis客户端无法连接服务器上Redis服务问题" class="headerlink" title="解决Rediis客户端无法连接服务器上Redis服务问题"></a><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_51295655/article/details/128791852?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-128791852-blog-82425785.235%5Ev43%5Econtrol&spm=1001.2101.3001.4242.1&utm_relevant_index=1">解决Rediis客户端无法连接服务器上Redis服务问题</a></h3></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share" data-image="/img/3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/02/26/40%20IDEA/" title="40 IDEA"><img class="cover" src="/img/12.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">40 IDEA</div></div><div class="info-2"><div class="info-item-1">40 IDEAJAVA注解 1234567*** @Description $Param$$returns$* @Author yaoHui* @Date $date$*/   1groovyScript(&quot;if(\&quot;$&#123;_1&#125;\&quot;.length() == 2) &#123;return &#x27;&#x27;;&#125; else &#123;def result=&#x27;&#x27;; def params=\&quot;$&#123;_1&#125;\&quot;.replaceAll(&#x27;[\\\\[|\\\\]|\\\\s]&#x27;, &#x27;&#x27;).split(&#x27;,&#x27;).toList();for(i = 0; i &lt; params.size(); i++) &#123;if(i==0)&#123;result+=&#x27;* @param &#x27; + params[i] + &#x27; ...</div></div></div></a><a class="pagination-related" href="/2025/02/26/49%20Java%20JDBC/" title="49 Java JDBC"><img class="cover" src="/img/2.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">49 Java JDBC</div></div><div class="info-2"><div class="info-item-1">49 Java JDBC参考资料 JavaJDBC：连接池 springboot集成Druid，配置详解新手必须读  前言数据库连接池顾名思义就是存放数据库连接状态的池子，在该技术提出之前，如果需要连接数据库，就会创建一个JDBC连接对象，当结束的时候，该对象就会被回收。所以如果重复的创建同样的数据库连接，就会造成资源的极大浪费，数据库连接池应运而生。 在数据库连接池中存放一定数量的数据库连接，当用户需要连接时，并非创建一个新的连接，而是查看连接池中是否已经存在了该连接，如果有则会直接拿出使用，从而提高效率。 连接池优点：  减少连接创建时间：虽然与其它数据库相比 GBase 提供了较为快速连接功能，但是创建新的 JDBC 连接仍会招致网络和 JDBC 驱动的开销。如果这类连接是“循环”使用的，使用该方式这些花销就可避免 简化的编程模式：当使用连接池时，每一个单独的线程能够像创建了一个自己的 JDBC...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/03/05/75-28%20Zset/" title="75-28 Zset"><img class="cover" src="/img/25.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-05</div><div class="info-item-2">75-28 Zset</div></div><div class="info-2"><div class="info-item-1">75-28 Zset前言有序集合 Zset 与 普通集合 Set 类似 , 都是 没有重复元素的集合 ; 有序集合 Zset 中的 元素排序 , 是 根据 评分 进行排序 , 每个成员 都关联了一个 评分 , 在该 有序集合 中 , 根据 评分 由低到高 进行排序 ; Zset 中的元素 是 不可重复的 , 但是 元素 关联 的 评分 是可以重复的 , 也就是说 存在 两个不同的元素 关联着 相同的 评分 ; Zset 中的元素 是 有序 的 , 根据 排序的索引 或者 元素的评分 可以获取 指定范围 的 成员 ; 如 : 获取 中间元素 ; 查询 Zset 所有数据 其它请详看：【Redis】Redis 有序集合 Zset 操作 ( 简介 | 查询操作 | 增加操作 | 删除操作 | 修改操作 ) 可以使用Redis的Zset来实现Redis的延时消息Redis可以通过使用zset（有序集合）来实现延时消息功能。具体来说，可以将消息的发送时间作为score，消息内容作为value存储在zset中，然后通过轮询zset，检查当前时间是否达到消息的发送时间，来实现延时消息的投递。 </div></div></div></a><a class="pagination-related" href="/2025/03/27/75-44%20%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98/" title="75-44 分布式锁超时问题"><img class="cover" src="/img/23.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-27</div><div class="info-item-2">75-44 分布式锁超时问题</div></div><div class="info-2"><div class="info-item-1">75-44 分布式锁超时问题前言关于Redis分布式锁，可能就会存在一个问题，A线程获取到了一个锁，并把这个锁设置了超时时间，为了避免死锁的问题，但是我们对应的业务处理耗时是不定的，所以可能这次的耗时比超时时间长，导致锁超时自动释放了，这时候B线程同样来获取这个锁，结果就是可以获取到这个锁，所以就会出现问题。 布式锁最基本的性质相违背: 在任意一个时刻, 只有一个客户端持有锁, 即独享 使用Redisson来解决锁超时的问题那么久有一个疑问了，Redisson是如何对锁超时问题进行解决的呢？那么这里就涉及到Redisson中提出的看门狗机制了。 一图见  Redisson 锁的加锁机制如上图所示，线程去获取锁，获取成功则执行lua脚本，保存数据到redis数据库。如果获取失败: 一直通过while循环尝试获取锁(可自定义等待时间，超时后返回失败)，获取成功后，执行lua脚本，保存数据到redis数据库。Redisson提供的分布式锁是支持锁自动续期的，也就是说，如果线程仍旧没有执行完，那么redisson会自动给redis中的目标key延长超时时间，这在Redisson中称之为...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">徐行</div><div class="author-info-description">道阻且长</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">114</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">81</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/fangyaohui"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#48-Redis"><span class="toc-number">1.</span> <span class="toc-text">48 Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98"><span class="toc-number">1.2.</span> <span class="toc-text">分布式缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.1.</span> <span class="toc-text">技术选型方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%94%A8%E9%80%94"><span class="toc-number">1.3.</span> <span class="toc-text">Redis用途</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.3.1.</span> <span class="toc-text">分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">场景描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">实现过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E5%B8%B8%E8%A7%81%E7%9A%84%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F%E5%AF%B9%E9%94%81%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">Redis常见的部署方式对锁的影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E6%A8%A1%E5%BC%8F-Redlock%E5%AE%9E%E7%8E%B0%E9%AB%98%E5%8F%AF%E9%9D%A0%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">集群模式+Redlock实现高可靠的分布式锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E6%B5%81"><span class="toc-number">1.3.2.</span> <span class="toc-text">限流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">限流方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">计数器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">漏桶算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95"><span class="toc-number">1.3.2.1.3.</span> <span class="toc-text">令牌桶算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis-Lua"><span class="toc-number">1.3.2.1.4.</span> <span class="toc-text">Redis + Lua</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.3.3.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.4.</span> <span class="toc-text">复杂业务场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">Redis的五大数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E8%BF%98%E6%98%AF-Hash-%E5%AD%98%E5%82%A8%E5%AF%B9%E8%B1%A1%E6%95%B0%E6%8D%AE%E6%9B%B4%E5%A5%BD%E5%91%A2%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">String 还是 Hash 存储对象数据更好呢？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">Redis线程模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">Redis内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E5%88%A0%E9%99%A4%E7%AD%96%E7%95%A5%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="toc-number">1.6.1.</span> <span class="toc-text">过期的数据的删除策略了解么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3%E4%B9%88%EF%BC%9F"><span class="toc-number">1.6.2.</span> <span class="toc-text">***Redis内存淘汰机制了解么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-volatile-lfu%EF%BC%88Least-Frequently-Used%EF%BC%89"><span class="toc-number">1.6.3.</span> <span class="toc-text">1. volatile-lfu（Least Frequently Used）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-volatile-lru%EF%BC%88Least-Recently-Used%EF%BC%89"><span class="toc-number">1.6.4.</span> <span class="toc-text">2. volatile-lru（Least Recently Used）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8C%BA%E5%88%AB%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.5.</span> <span class="toc-text">3. 区别总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E"><span class="toc-number">1.6.6.</span> <span class="toc-text">4. 示例代码说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-lfu-%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.6.6.1.</span> <span class="toc-text">volatile-lfu 示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-lru-%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">1.6.6.2.</span> <span class="toc-text">volatile-lru 示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93"><span class="toc-number">1.6.7.</span> <span class="toc-text">5. 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.</span> <span class="toc-text">Redis持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81Redis%E6%8C%82%E6%8E%89%E4%B9%8B%E5%90%8E%E5%86%8D%E9%87%8D%E5%90%AF%E6%95%B0%E6%8D%AE%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E6%81%A2%E5%A4%8D%E5%90%97%EF%BC%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">怎么保证Redis挂掉之后再重启数据可以进行恢复吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB%E5%BF%AB%E7%85%A7"><span class="toc-number">1.7.2.</span> <span class="toc-text">RDB快照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">1.7.3.</span> <span class="toc-text">AOP持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.8.</span> <span class="toc-text">Redis事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BC%98%E5%8C%96"><span class="toc-number">1.9.</span> <span class="toc-text">Redis优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-bigkey"><span class="toc-number">1.9.1.</span> <span class="toc-text">Redis bigkey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E9%87%8Fkey%E9%9B%86%E4%B8%AD%E8%BF%87%E6%9C%9F%E9%97%AE%E9%A2%98"><span class="toc-number">1.9.2.</span> <span class="toc-text">大量key集中过期问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.</span> <span class="toc-text">Redis生产问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">1.10.1.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">1.10.1.1.</span> <span class="toc-text">什么是缓存穿透</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">1.10.2.</span> <span class="toc-text">缓存雪崩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.11.</span> <span class="toc-text">如何保证缓存和数据库数据的一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E7%BC%93%E5%AD%98"><span class="toc-number">1.11.1.</span> <span class="toc-text">更新缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98"><span class="toc-number">1.11.2.</span> <span class="toc-text">删除缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98%EF%BC%8C%E5%90%8E%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.11.2.1.</span> <span class="toc-text">先删除缓存，后更新数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%90%8E%E5%88%A0%E9%99%A4%E7%BC%93%E5%AD%98"><span class="toc-number">1.11.2.2.</span> <span class="toc-text">先更新数据库，后删除缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%87%8D%E8%AF%95"><span class="toc-number">1.11.3.</span> <span class="toc-text">异步重试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Bug%E8%A7%A3%E5%86%B3"><span class="toc-number">1.12.</span> <span class="toc-text">Bug解决</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3Rediis%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8ARedis%E6%9C%8D%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">1.12.1.</span> <span class="toc-text">解决Rediis客户端无法连接服务器上Redis服务问题</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/31/79-05%20%E6%99%BA%E5%8D%B7%E4%BA%91%E9%97%AE%E9%A2%98%E5%8F%91%E7%8E%B0&amp;%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="79-05 智卷云问题发现&amp;解决方案"><img src="/img/25.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="79-05 智卷云问题发现&amp;解决方案"/></a><div class="content"><a class="title" href="/2025/03/31/79-05%20%E6%99%BA%E5%8D%B7%E4%BA%91%E9%97%AE%E9%A2%98%E5%8F%91%E7%8E%B0&amp;%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" title="79-05 智卷云问题发现&amp;解决方案">79-05 智卷云问题发现&amp;解决方案</a><time datetime="2025-03-31T07:58:17.000Z" title="发表于 2025-03-31 15:58:17">2025-03-31</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/29/79-04%20%E6%99%BA%E5%8D%B7%E4%BA%91%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/" title="79-04 智卷云后端架构设计方案"><img src="/img/2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="79-04 智卷云后端架构设计方案"/></a><div class="content"><a class="title" href="/2025/03/29/79-04%20%E6%99%BA%E5%8D%B7%E4%BA%91%E5%90%8E%E7%AB%AF%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88/" title="79-04 智卷云后端架构设计方案">79-04 智卷云后端架构设计方案</a><time datetime="2025-03-29T07:58:17.000Z" title="发表于 2025-03-29 15:58:17">2025-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/29/75-47%20Nacos%E6%9C%AC%E5%9C%B0%E6%BA%90%E7%A0%81%E9%83%A8%E7%BD%B2/" title="75-47 Nacos源码本地部署"><img src="/img/29.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="75-47 Nacos源码本地部署"/></a><div class="content"><a class="title" href="/2025/03/29/75-47%20Nacos%E6%9C%AC%E5%9C%B0%E6%BA%90%E7%A0%81%E9%83%A8%E7%BD%B2/" title="75-47 Nacos源码本地部署">75-47 Nacos源码本地部署</a><time datetime="2025-03-29T07:46:17.000Z" title="发表于 2025-03-29 15:46:17">2025-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/29/Untitled/" title="无标题"><img src="/img/12.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无标题"/></a><div class="content"><a class="title" href="/2025/03/29/Untitled/" title="无标题">无标题</a><time datetime="2025-03-29T06:37:33.652Z" title="发表于 2025-03-29 14:37:33">2025-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/29/79-03%20%E6%99%BA%E5%8D%B7%E4%BA%91%E8%AF%95%E5%8D%B7%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/" title="79-03 智卷云试卷生成方案"><img src="/img/19.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="79-03 智卷云试卷生成方案"/></a><div class="content"><a class="title" href="/2025/03/29/79-03%20%E6%99%BA%E5%8D%B7%E4%BA%91%E8%AF%95%E5%8D%B7%E7%94%9F%E6%88%90%E6%96%B9%E6%A1%88/" title="79-03 智卷云试卷生成方案">79-03 智卷云试卷生成方案</a><time datetime="2025-03-29T05:58:17.000Z" title="发表于 2025-03-29 13:58:17">2025-03-29</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/index_img.png);"><div id="footer-wrap"><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.3</a></div><div class="footer_custom_text">道阻且长</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = true;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>